{"meta": {"problem_id": "industryOR_0", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 3050.0}, "ir_dict": {"meta": {"problem_id": "industryOR_0", "source": "IndustryOR", "description": "The Zhang family has 6 children, Harry, Hermione, Ron, Fred, George, and Ginny. The cost of taking Harry is $1200, Hermione is $1650, Ron is $750, Fred is $800, George is $800, and Ginny is $1500. Which children should the couple take to minimize the total cost of taking the children?\n\nThey can take a maximum of 4 children on the upcoming trip.\n\nGinny is the youngest, so the Zhang family will definitely take her.\n\nIf the couple takes Harry, they will not take Fred because Harry doesn't get along with him.\n\nIf the couple takes Harry, they will not take George because Harry doesn't get along with him.\n\nIf they take George, they must also take Fred.\n\nIf they take George, they must also take Hermione.\n\nAlthough this will cost them a lot of money, the Zhang family has decided to take at least three children.", "sense": "min", "version": "v1"}, "sets": [{"name": "Children", "elements": ["Harry", "Hermione", "Ron", "Fred", "George", "Ginny"], "description": "The children in the Zhang family."}], "params": [{"name": "cost", "indices": ["Children"], "values": {"Harry": 1200.0, "Hermione": 1650.0, "Ron": 750.0, "Fred": 800.0, "George": 800.0, "Ginny": 1500.0}, "description": "Cost of taking each child."}], "vars": [{"name": "take", "indices": ["Children"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary decision variable indicating if a child is taken."}], "objective": {"name": "min_cost", "sense": "min", "expr": "quicksum(cost[child] * take[child] for child in Children)", "description": "Minimize the total cost of taking the children."}, "constraints": [{"name": "max_children", "expr_lhs": "quicksum(take[child] for child in Children)", "sense": "<=", "expr_rhs": "4.0", "description": "Can take a maximum of 4 children."}, {"name": "take_ginny", "expr_lhs": "take['Ginny']", "sense": "==", "expr_rhs": "1.0", "description": "Ginny must be taken."}, {"name": "no_harry_fred", "expr_lhs": "take['Harry'] + take['Fred']", "sense": "<=", "expr_rhs": "1.0", "description": "If Harry is taken, Fred cannot be taken."}, {"name": "no_harry_george", "expr_lhs": "take['Harry'] + take['George']", "sense": "<=", "expr_rhs": "1.0", "description": "If Harry is taken, George cannot be taken."}, {"name": "george_fred", "expr_lhs": "take['George'] - take['Fred']", "sense": "<=", "expr_rhs": "0.0", "description": "If George is taken, Fred must also be taken."}, {"name": "george_hermione", "expr_lhs": "take['George'] - take['Hermione']", "sense": "<=", "expr_rhs": "0.0", "description": "If George is taken, Hermione must also be taken."}, {"name": "min_children", "expr_lhs": "quicksum(take[child] for child in Children)", "sense": ">=", "expr_rhs": "3.0", "description": "At least three children must be taken."}]}, "eval": {"ground_truth_raw": "3050.0", "ground_truth_value": 3050.0, "obj_value": 3050.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_1", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 135000.0}, "ir_dict": {"meta": {"problem_id": "industryOR_1", "source": "IndustryOR", "description": "The Li family plans to invest their retirement fund in commercial real estate. Property 1 has an annual income of $12,500, Property 2 has an annual income of $35,000, Property 3 has an annual income of $23,000, and Property 4 has an annual income of $100,000. The decision to be made is whether to buy or not buy each property, not the quantity, as there is only one property per property. Help them decide which properties to purchase to maximize their annual income.\nProperty 1 costs $1.5 million, Property 2 costs $2.1 million, Property 3 costs $2.3 million, and Property 4 costs $4.2 million. The Li family's budget is $7 million.\n\nIf they purchase Property 4, then they cannot purchase Property 3.", "sense": "max", "version": "v1"}, "sets": [{"name": "P", "elements": ["1", "2", "3", "4"], "description": "Properties available for investment"}], "params": [{"name": "income", "indices": ["P"], "values": {"1": 12500.0, "2": 35000.0, "3": 23000.0, "4": 100000.0}, "description": "Annual income from each property"}, {"name": "cost", "indices": ["P"], "values": {"1": 1.5, "2": 2.1, "3": 2.3, "4": 4.2}, "description": "Cost of each property in millions"}], "vars": [{"name": "buy", "indices": ["P"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Decision to buy (1) or not buy (0) each property"}], "objective": {"name": "max_income", "sense": "max", "expr": "quicksum(income[p] * buy[p] for p in P)", "description": "Maximize total annual income from purchased properties"}, "constraints": [{"name": "budget_constraint", "expr_lhs": "quicksum(cost[p] * buy[p] for p in P)", "sense": "<=", "expr_rhs": "7.0", "description": "Total cost of purchased properties must not exceed $7 million"}, {"name": "mutual_exclusivity_3_4", "expr_lhs": "buy['3'] + buy['4']", "sense": "<=", "expr_rhs": "1.0", "description": "Cannot purchase both Property 3 and Property 4"}]}, "eval": {"ground_truth_raw": "135000.0", "ground_truth_value": 135000.0, "obj_value": 135000.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_2", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 30400.0}, "ir_dict": {"meta": {"problem_id": "industryOR_2", "source": "IndustryOR", "description": "A farmer needs to decide how many cows, sheep, and chickens to raise in order to maximize profit. The farmer can sell cows, sheep, and chickens for $500, $200, and $8 respectively. The feed costs for each cow, sheep, and chicken are $100, $80, and $5 respectively. Profit is the difference between the selling price and the feed cost. Cows, sheep, and chickens produce 10, 5, and 3 units of manure per day respectively. Due to limited time for farm employees to clean the farm, they can clean a maximum of 800 units of manure per day. Additionally, due to the limited size of the farm, the farmer can raise a maximum of 50 chickens. Furthermore, the farmer must have at least 10 cows to meet customer demand. The farmer must also have at least 20 sheep. Finally, the total number of animals cannot exceed 100.", "sense": "max", "version": "v1"}, "sets": [{"name": "Animals", "elements": ["cows", "sheep", "chickens"], "description": null}], "params": [{"name": "selling_price", "indices": ["Animals"], "values": {"cows": 500.0, "sheep": 200.0, "chickens": 8.0}, "description": null}, {"name": "feed_cost", "indices": ["Animals"], "values": {"cows": 100.0, "sheep": 80.0, "chickens": 5.0}, "description": null}, {"name": "manure_production", "indices": ["Animals"], "values": {"cows": 10.0, "sheep": 5.0, "chickens": 3.0}, "description": null}], "vars": [{"name": "num_animals", "indices": ["Animals"], "vartype": "integer", "lb": 0.0, "ub": null, "description": null}], "objective": {"name": "profit", "sense": "max", "expr": "quicksum((selling_price[a] - feed_cost[a]) * num_animals[a] for a in Animals)", "description": null}, "constraints": [{"name": "manure_limit", "expr_lhs": "quicksum(manure_production[a] * num_animals[a] for a in Animals)", "sense": "<=", "expr_rhs": "800.0", "description": "Manure production limit"}, {"name": "chicken_limit", "expr_lhs": "num_animals['chickens']", "sense": "<=", "expr_rhs": "50.0", "description": "Maximum number of chickens"}, {"name": "min_cows", "expr_lhs": "num_animals['cows']", "sense": ">=", "expr_rhs": "10.0", "description": "Minimum number of cows"}, {"name": "min_sheep", "expr_lhs": "num_animals['sheep']", "sense": ">=", "expr_rhs": "20.0", "description": "Minimum number of sheep"}, {"name": "total_animals_limit", "expr_lhs": "quicksum(num_animals[a] for a in Animals)", "sense": "<=", "expr_rhs": "100.0", "description": "Total number of animals limit"}]}, "eval": {"ground_truth_raw": "30400.0", "ground_truth_value": 30400.0, "obj_value": 30400.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_3", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 23000.0}, "ir_dict": {"meta": {"problem_id": "industryOR_3", "source": "IndustryOR", "description": "A company wants to hire new employees for their team. The salary requirements of candidates A, B, C, D, and E are $8100, $20000, $21000, $3000, and $8000 respectively. They need to decide whether to hire each candidate. The team wants to minimize the total amount paid to the candidates.\n\nThey want to hire a maximum of 3 new employees.\n\nThe team has a limited budget of $35,000. They need to ensure that the total payment to the selected candidates does not exceed the budget.\n\nThe qualifications of the five candidates are as follows:\nCandidate A: Bachelor's degree;\nCandidate B: Master's degree;\nCandidate C: PhD degree;\nCandidate D: No degree;\nCandidate E: No degree.\nThey will select at least one candidate with a master's or PhD degree.\n\nThe work experience of the five candidates is as follows:\nCandidate A: 3 years of work experience;\nCandidate B: 10 years of work experience;\nCandidate C: 4 years of work experience;\nCandidate D: 3 years of work experience;\nCandidate E: 7 years of work experience.\nThey want the total work experience of the selected candidates to be at least 12 years.\n\nDue to the similar professional skills of candidates A and E, the company will choose at most one of them.\n\nThey will hire at least 2 new employees.", "sense": "min", "version": "v1"}, "sets": [{"name": "Candidates", "elements": ["A", "B", "C", "D", "E"], "description": "List of candidates"}], "params": [{"name": "salary", "indices": ["Candidates"], "values": {"A": 8100.0, "B": 20000.0, "C": 21000.0, "D": 3000.0, "E": 8000.0}, "description": "Salary requirements of candidates"}, {"name": "experience", "indices": ["Candidates"], "values": {"A": 3.0, "B": 10.0, "C": 4.0, "D": 3.0, "E": 7.0}, "description": "Work experience of candidates"}, {"name": "degree", "indices": ["Candidates"], "values": {"A": "Bachelor", "B": "Master", "C": "PhD", "D": "None", "E": "None"}, "description": "Qualifications of candidates"}], "vars": [{"name": "hire", "indices": ["Candidates"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Decision to hire candidate"}], "objective": {"name": "total_salary", "sense": "min", "expr": "quicksum(salary[c] * hire[c] for c in Candidates)", "description": "Minimize total salary of hired candidates"}, "constraints": [{"name": "max_hires", "expr_lhs": "quicksum(hire[c] for c in Candidates)", "sense": "<=", "expr_rhs": "3.0", "description": "Hire at most 3 candidates"}, {"name": "budget_limit", "expr_lhs": "quicksum(salary[c] * hire[c] for c in Candidates)", "sense": "<=", "expr_rhs": "35000.0", "description": "Total salary must not exceed budget"}, {"name": "min_degree", "expr_lhs": "hire['B'] + hire['C']", "sense": ">=", "expr_rhs": "1.0", "description": "At least one candidate with Master or PhD"}, {"name": "min_experience", "expr_lhs": "quicksum(experience[c] * hire[c] for c in Candidates)", "sense": ">=", "expr_rhs": "12.0", "description": "Total work experience of hired candidates must be at least 12 years"}, {"name": "exclusive_A_E", "expr_lhs": "hire['A'] + hire['E']", "sense": "<=", "expr_rhs": "1.0", "description": "At most one of A or E can be hired"}, {"name": "min_hires", "expr_lhs": "quicksum(hire[c] for c in Candidates)", "sense": ">=", "expr_rhs": "2.0", "description": "Hire at least 2 candidates"}]}, "eval": {"ground_truth_raw": "23000.0", "ground_truth_value": 23000.0, "obj_value": 23000.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_4", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": ["integrality_sanity"], "repairs": ["integrality_sanity"]}, "solver": {"status_name": "OPTIMAL", "obj_value": 180000.0}, "ir_dict": {"meta": {"problem_id": "industryOR_4", "source": "IndustryOR", "description": "Tom and Jerry have just bought a farm in Sunshine Valley and are considering using it to grow corn, wheat, soybeans, and sorghum. The profit from planting one acre of corn is $1500, one acre of wheat is $1200, one acre of soybeans is $1800, and one acre of sorghum is $1600. To maximize profit, how many acres of land should Tom and Jerry use to plant each crop?\n\nThe total area of Tom and Jerry's farm is 100 acres.\n\nThe area of land used for planting corn should be at least twice the area of land used for planting wheat.\n\nThe area of land used for planting soybeans should be at least half the area of land used for planting sorghum.\n\nThe area of land used for planting wheat must be three times the area of land used for planting sorghum.", "sense": "max", "version": "v1"}, "sets": [{"name": "Crops", "elements": ["corn", "wheat", "soybeans", "sorghum"], "description": "Types of crops"}], "params": [{"name": "profit", "indices": ["Crops"], "values": {"corn": 1500.0, "wheat": 1200.0, "soybeans": 1800.0, "sorghum": 1600.0}, "description": "Profit per acre for each crop"}], "vars": [{"name": "area", "indices": ["Crops"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Area of land used for each crop"}], "objective": {"name": "max_profit", "sense": "max", "expr": "quicksum(profit[crop] * area[crop] for crop in Crops)", "description": "Maximize total profit from all crops"}, "constraints": [{"name": "total_area", "expr_lhs": "quicksum(area[crop] for crop in Crops)", "sense": "<=", "expr_rhs": "100.0", "description": "Total area of the farm"}, {"name": "corn_wheat_ratio", "expr_lhs": "area['corn']", "sense": ">=", "expr_rhs": "2 * area['wheat']", "description": "Corn area at least twice the wheat area"}, {"name": "soybeans_sorghum_ratio", "expr_lhs": "area['soybeans']", "sense": ">=", "expr_rhs": "0.5 * area['sorghum']", "description": "Soybeans area at least half the sorghum area"}, {"name": "wheat_sorghum_ratio", "expr_lhs": "area['wheat']", "sense": "==", "expr_rhs": "3 * area['sorghum']", "description": "Wheat area must be three times the sorghum area"}]}, "eval": {"ground_truth_raw": "180000", "ground_truth_value": 180000.0, "obj_value": 180000.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_5", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 1600.0}, "ir_dict": {"meta": {"problem_id": "industryOR_5", "source": "IndustryOR", "description": "The Lee family has 5 children, Alice, Bob, Charlie, Diana, and Ella. The cost of taking Alice is $1000, Bob is $900, Charlie is $600, Diana is $500, and Ella is $700. Which children should the couple take to minimize the total cost of taking the children?\nThey can take a maximum of 3 children together on the upcoming trip.\n\nBob is the youngest, so the Lee family will definitely take him.\n\nIf the couple takes Alice, they will not take Diana because Alice and Diana do not get along.\n\nIf the couple takes Bob, they will not take Charlie because Bob and Charlie do not get along.\n\nIf they take Charlie, they must also take Diana.\n\nIf they take Diana, they must also take Ella.\n\nAlthough it will cost them a lot of money, the Lee family has decided to take at least two children.", "sense": "min", "version": "v1"}, "sets": [{"name": "Children", "elements": ["Alice", "Bob", "Charlie", "Diana", "Ella"], "description": null}], "params": [{"name": "cost", "indices": ["Children"], "values": {"Alice": 1000.0, "Bob": 900.0, "Charlie": 600.0, "Diana": 500.0, "Ella": 700.0}, "description": null}], "vars": [{"name": "take", "indices": ["Children"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if the child is taken, 0 otherwise"}], "objective": {"name": "min_cost", "sense": "min", "expr": "quicksum(cost[child] * take[child] for child in Children)", "description": "Minimize the total cost of taking the children"}, "constraints": [{"name": "max_3_children", "expr_lhs": "quicksum(take[child] for child in Children)", "sense": "<=", "expr_rhs": "3.0", "description": "Can take a maximum of 3 children"}, {"name": "take_bob", "expr_lhs": "take['Bob']", "sense": "==", "expr_rhs": "1.0", "description": "Bob must be taken"}, {"name": "alice_not_with_diana", "expr_lhs": "take['Alice'] + take['Diana']", "sense": "<=", "expr_rhs": "1.0", "description": "Alice and Diana cannot be taken together"}, {"name": "bob_not_with_charlie", "expr_lhs": "take['Bob'] + take['Charlie']", "sense": "<=", "expr_rhs": "1.0", "description": "Bob and Charlie cannot be taken together"}, {"name": "charlie_with_diana", "expr_lhs": "take['Charlie']", "sense": "<=", "expr_rhs": "take['Diana']", "description": "If Charlie is taken, Diana must also be taken"}, {"name": "diana_with_ella", "expr_lhs": "take['Diana']", "sense": "<=", "expr_rhs": "take['Ella']", "description": "If Diana is taken, Ella must also be taken"}, {"name": "at_least_2_children", "expr_lhs": "quicksum(take[child] for child in Children)", "sense": ">=", "expr_rhs": "2.0", "description": "At least two children must be taken"}]}, "eval": {"ground_truth_raw": "1600.0", "ground_truth_value": 1600.0, "obj_value": 1600.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_6", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 90000.0}, "ir_dict": {"meta": {"problem_id": "industryOR_6", "source": "IndustryOR", "description": "The Zhang family has decided to invest in several different restaurants. Restaurant A has an annual income of $15,000, Restaurant B has an annual income of $40,000, Restaurant C has an annual income of $30,000, and Restaurant D has an annual income of $50,000. They need to decide whether to purchase each restaurant, and each restaurant can only be purchased once. Help them decide which restaurants to purchase to maximize their annual income.\nThe cost of Restaurant A is $1.6 million, the cost of Restaurant B is $2.5 million, the cost of Restaurant C is $1.8 million, and the cost of Restaurant D is $3 million. The Zhang family's investment budget is $6 million.\n\nIf they purchase Restaurant D, they cannot purchase Restaurant A.", "sense": "max", "version": "v1"}, "sets": [{"name": "R", "elements": ["A", "B", "C", "D"], "description": "Set of restaurants"}], "params": [{"name": "income", "indices": ["R"], "values": {"A": 15000.0, "B": 40000.0, "C": 30000.0, "D": 50000.0}, "description": "Annual income from each restaurant"}, {"name": "cost", "indices": ["R"], "values": {"A": 1.6, "B": 2.5, "C": 1.8, "D": 3.0}, "description": "Cost in millions to purchase each restaurant"}], "vars": [{"name": "purchase", "indices": ["R"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary decision to purchase each restaurant"}], "objective": {"name": "max_income", "sense": "max", "expr": "quicksum(income[r] * purchase[r] for r in R)", "description": "Maximize total annual income from purchased restaurants"}, "constraints": [{"name": "budget_constraint", "expr_lhs": "quicksum(cost[r] * purchase[r] for r in R)", "sense": "<=", "expr_rhs": "6.0", "description": "Total cost of purchased restaurants must not exceed budget"}, {"name": "mutual_exclusivity_AD", "expr_lhs": "purchase['A'] + purchase['D']", "sense": "<=", "expr_rhs": "1.0", "description": "Cannot purchase both Restaurant A and Restaurant D"}]}, "eval": {"ground_truth_raw": "90000.0", "ground_truth_value": 90000.0, "obj_value": 90000.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_7", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 600.0}, "ir_dict": {"meta": {"problem_id": "industryOR_7", "source": "IndustryOR", "description": "A company plans to transport goods between a city and suburb and needs to choose the most environmentally friendly mode of transportation. The company can choose from the following three options: motorcycles, small trucks, and large trucks. Each motorcycle trip produces 40 units of pollution, each small truck trip produces 70 units of pollution, and each large truck trip produces 100 units of pollution. The company's goal is to minimize total pollution.\n\nThe company can only choose two modes of transportation from these three options.\n\nDue to certain road restrictions, the number of motorcycle trips cannot exceed 8.\n\nEach motorcycle trip can transport 10 units of products, each small truck trip can transport 20 units of products, and each large truck trip can transport 50 units of products. The company needs to transport at least 300 units of products.\n\nThe total number of trips must be less than or equal to 20.", "sense": "min", "version": "v1"}, "sets": [{"name": "Modes", "elements": ["motorcycle", "small_truck", "large_truck"], "description": "Transportation modes"}], "params": [{"name": "pollution", "indices": ["Modes"], "values": {"motorcycle": 40.0, "small_truck": 70.0, "large_truck": 100.0}, "description": "Pollution per trip for each mode"}, {"name": "capacity", "indices": ["Modes"], "values": {"motorcycle": 10.0, "small_truck": 20.0, "large_truck": 50.0}, "description": "Capacity per trip for each mode"}], "vars": [{"name": "trips", "indices": ["Modes"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of trips for each mode"}, {"name": "y", "indices": ["Modes"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a mode is chosen"}], "objective": {"name": "minimize_pollution", "sense": "min", "expr": "quicksum(pollution[m] * trips[m] for m in Modes)", "description": "Minimize total pollution"}, "constraints": [{"name": "choose_two_modes", "expr_lhs": "quicksum(y[m] for m in Modes)", "sense": "==", "expr_rhs": "2.0", "description": "Choose exactly two modes of transportation"}, {"name": "motorcycle_trip_limit", "expr_lhs": "trips['motorcycle']", "sense": "<=", "expr_rhs": "8.0", "description": "Motorcycle trips cannot exceed 8"}, {"name": "product_transport_requirement", "expr_lhs": "quicksum(capacity[m] * trips[m] for m in Modes)", "sense": ">=", "expr_rhs": "300.0", "description": "Transport at least 300 units of products"}, {"name": "total_trip_limit", "expr_lhs": "quicksum(trips[m] for m in Modes)", "sense": "<=", "expr_rhs": "20.0", "description": "Total number of trips must be less than or equal to 20"}, {"name": "mode_activation_motorcycle", "expr_lhs": "trips['motorcycle']", "sense": "<=", "expr_rhs": "8.0 * y['motorcycle']", "description": "Activate motorcycle mode if trips are made"}, {"name": "mode_activation_small_truck", "expr_lhs": "trips['small_truck']", "sense": "<=", "expr_rhs": "20.0 * y['small_truck']", "description": "Activate small truck mode if trips are made"}, {"name": "mode_activation_large_truck", "expr_lhs": "trips['large_truck']", "sense": "<=", "expr_rhs": "20.0 * y['large_truck']", "description": "Activate large truck mode if trips are made"}]}, "eval": {"ground_truth_raw": "600", "ground_truth_value": 600.0, "obj_value": 600.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_8", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 9800.0}, "ir_dict": {"meta": {"problem_id": "industryOR_8", "source": "IndustryOR", "description": "A furniture factory needs to determine how many tables, chairs, and bookshelves to produce in order to maximize profit. The factory can sell tables for $200 each, chairs for $50 each, and bookshelves for $150 each. The manufacturing costs for each table, chair, and bookshelf are $120, $20, and $90, respectively. Profit is the difference between the selling price and the manufacturing cost. Tables, chairs, and bookshelves each occupy 5, 2, and 3 square meters of warehouse space, respectively. Due to limited warehouse space, the total space cannot exceed 500 square meters. Additionally, due to market demand, the factory needs to produce at least 10 tables and 20 bookshelves. Finally, the total number of items produced by the furniture factory cannot exceed 200.", "sense": "max", "version": "v1"}, "sets": [{"name": "Products", "elements": ["tables", "chairs", "bookshelves"], "description": null}], "params": [{"name": "selling_price", "indices": ["Products"], "values": {"tables": 200.0, "chairs": 50.0, "bookshelves": 150.0}, "description": null}, {"name": "manufacturing_cost", "indices": ["Products"], "values": {"tables": 120.0, "chairs": 20.0, "bookshelves": 90.0}, "description": null}, {"name": "space", "indices": ["Products"], "values": {"tables": 5.0, "chairs": 2.0, "bookshelves": 3.0}, "description": null}], "vars": [{"name": "production", "indices": ["Products"], "vartype": "integer", "lb": 0.0, "ub": null, "description": null}], "objective": {"name": "profit", "sense": "max", "expr": "quicksum((selling_price[p] - manufacturing_cost[p]) * production[p] for p in Products)", "description": null}, "constraints": [{"name": "warehouse_space", "expr_lhs": "quicksum(space[p] * production[p] for p in Products)", "sense": "<=", "expr_rhs": "500.0", "description": null}, {"name": "min_tables", "expr_lhs": "production['tables']", "sense": ">=", "expr_rhs": "10.0", "description": null}, {"name": "min_bookshelves", "expr_lhs": "production['bookshelves']", "sense": ">=", "expr_rhs": "20.0", "description": null}, {"name": "max_total_items", "expr_lhs": "quicksum(production[p] for p in Products)", "sense": "<=", "expr_rhs": "200.0", "description": null}]}, "eval": {"ground_truth_raw": "9800.0", "ground_truth_value": 9800.0, "obj_value": 9800.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_9", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 38000.0}, "ir_dict": {"meta": {"problem_id": "industryOR_9", "source": "IndustryOR", "description": "A company needs to decide whether to hire some of the five candidates to join their research and development team. The salary requirements for candidates F, G, H, I, and J are $12,000, $15,000, $18,000, $5,000, and $10,000 respectively. The company wants to minimize the total amount paid to the candidates while staying within the budget.\n\nThe company has a budget of $40,000 and wants to hire a maximum of 4 new employees.\n\nThe skill levels of the candidates are as follows:\nCandidate F: Level 2\nCandidate G: Level 3\nCandidate H: Level 4\nCandidate I: Level 1\nCandidate J: Level 2\nThe company needs to ensure that the total skill level of the hired employees is at least 8.\n\nThe project management experience in years for each candidate is as follows:\nCandidate F: 1 year\nCandidate G: 2 years\nCandidate H: 2 years\nCandidate I: 5 years\nCandidate J: 4 years\nThey want the total project management experience in the team to be at least 8 years.\n\nDue to the similar technical backgrounds of candidates G and J, the company can only choose one of them at most.", "sense": "min", "version": "v1"}, "sets": [{"name": "Candidates", "elements": ["F", "G", "H", "I", "J"], "description": "List of candidates for hiring"}], "params": [{"name": "salary", "indices": ["Candidates"], "values": {"F": 12000.0, "G": 15000.0, "H": 18000.0, "I": 5000.0, "J": 10000.0}, "description": "Salary requirements for each candidate"}, {"name": "skill_level", "indices": ["Candidates"], "values": {"F": 2.0, "G": 3.0, "H": 4.0, "I": 1.0, "J": 2.0}, "description": "Skill level of each candidate"}, {"name": "experience", "indices": ["Candidates"], "values": {"F": 1.0, "G": 2.0, "H": 2.0, "I": 5.0, "J": 4.0}, "description": "Project management experience in years for each candidate"}], "vars": [{"name": "hire", "indices": ["Candidates"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary decision variable for hiring each candidate"}], "objective": {"name": "minimize_salary", "sense": "min", "expr": "quicksum(salary[c] * hire[c] for c in Candidates)", "description": "Minimize total salary of hired candidates"}, "constraints": [{"name": "budget_constraint", "expr_lhs": "quicksum(salary[c] * hire[c] for c in Candidates)", "sense": "<=", "expr_rhs": "40000.0", "description": "Total salary must not exceed the budget"}, {"name": "max_hires", "expr_lhs": "quicksum(hire[c] for c in Candidates)", "sense": "<=", "expr_rhs": "4.0", "description": "Maximum of 4 candidates can be hired"}, {"name": "skill_requirement", "expr_lhs": "quicksum(skill_level[c] * hire[c] for c in Candidates)", "sense": ">=", "expr_rhs": "8.0", "description": "Total skill level of hired candidates must be at least 8"}, {"name": "experience_requirement", "expr_lhs": "quicksum(experience[c] * hire[c] for c in Candidates)", "sense": ">=", "expr_rhs": "8.0", "description": "Total project management experience must be at least 8 years"}, {"name": "mutual_exclusion_G_J", "expr_lhs": "hire['G'] + hire['J']", "sense": "<=", "expr_rhs": "1.0", "description": "At most one of candidates G and J can be hired"}]}, "eval": {"ground_truth_raw": "38000", "ground_truth_value": 38000.0, "obj_value": 38000.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_10", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 25000.0}, "ir_dict": {"meta": {"problem_id": "industryOR_10", "source": "IndustryOR", "description": "A toy company manufactures three types of tabletop golf toy, each requiring different manufacturing techniques. The advanced type requires 17 hours of processing and assembly labor, 8 hours of inspection, and a profit of 300 yuan per unit. The intermediate type requires 10 hours of labor, 4 hours of inspection, and a profit of 200 yuan. The basic type requires 2 hours of labor, 2 hours of inspection, and a profit of 100 yuan. There are 1000 hours of processing labor and 500 hours of inspection available. Furthermore, market forecasts indicate that the demand for the advanced type does not exceed 50 units, for the intermediate type does not exceed 80 units, and for the basic type does not exceed 150 units. Determine the company's production plan to maximize profit.", "sense": "max", "version": "v1"}, "sets": [{"name": "T", "elements": ["advanced", "intermediate", "basic"], "description": "Types of tabletop golf toys"}], "params": [{"name": "labor_hours", "indices": ["T"], "values": {"advanced": 17.0, "intermediate": 10.0, "basic": 2.0}, "description": "Labor hours required per unit for each type"}, {"name": "inspection_hours", "indices": ["T"], "values": {"advanced": 8.0, "intermediate": 4.0, "basic": 2.0}, "description": "Inspection hours required per unit for each type"}, {"name": "profit", "indices": ["T"], "values": {"advanced": 300.0, "intermediate": 200.0, "basic": 100.0}, "description": "Profit per unit for each type"}, {"name": "max_demand", "indices": ["T"], "values": {"advanced": 50.0, "intermediate": 80.0, "basic": 150.0}, "description": "Maximum demand for each type"}], "vars": [{"name": "x", "indices": ["T"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of units to produce for each type"}], "objective": {"name": "total_profit", "sense": "max", "expr": "quicksum(profit[t] * x[t] for t in T)", "description": "Maximize total profit"}, "constraints": [{"name": "labor_limit", "expr_lhs": "quicksum(labor_hours[t] * x[t] for t in T)", "sense": "<=", "expr_rhs": "1000.0", "description": "Total labor hours constraint"}, {"name": "inspection_limit", "expr_lhs": "quicksum(inspection_hours[t] * x[t] for t in T)", "sense": "<=", "expr_rhs": "500.0", "description": "Total inspection hours constraint"}, {"name": "demand_advanced", "expr_lhs": "x['advanced']", "sense": "<=", "expr_rhs": "max_demand['advanced']", "description": "Demand constraint for advanced type"}, {"name": "demand_intermediate", "expr_lhs": "x['intermediate']", "sense": "<=", "expr_rhs": "max_demand['intermediate']", "description": "Demand constraint for intermediate type"}, {"name": "demand_basic", "expr_lhs": "x['basic']", "sense": "<=", "expr_rhs": "max_demand['basic']", "description": "Demand constraint for basic type"}]}, "eval": {"ground_truth_raw": "25000", "ground_truth_value": 25000.0, "obj_value": 25000.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_11", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 53.0}, "ir_dict": {"meta": {"problem_id": "industryOR_11", "source": "IndustryOR", "description": "A certain 24-hour convenience store requires a certain number of salespersons during each time period as follows: 2:00-6:00 - 10 people, 6:00-10:00 - 15 people, 10:00-14:00 - 25 people, 14:00-18:00 - 20 people, 18:00-22:00 - 18 people, 22:00-2:00 - 12 people. Salespersons work at 2:00, 6:00, 10:00, 14:00, 18:00, and 22:00, and work continuously for 8 hours. Determine the minimum number of salespersons needed to meet the requirements.", "sense": "min", "version": "v1"}, "sets": [{"name": "T", "elements": ["2:00", "6:00", "10:00", "14:00", "18:00", "22:00"], "description": "Time periods when salespersons start their shifts"}], "params": [{"name": "demand", "indices": ["T"], "values": {"2:00": 10.0, "6:00": 15.0, "10:00": 25.0, "14:00": 20.0, "18:00": 18.0, "22:00": 12.0}, "description": "Number of salespersons required during each time period"}], "vars": [{"name": "x", "indices": ["T"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of salespersons starting their shift at each time period"}], "objective": {"name": "min_salespersons", "sense": "min", "expr": "quicksum(x[t] for t in T)", "description": "Minimize the total number of salespersons"}, "constraints": [{"name": "demand_2:00", "expr_lhs": "x['2:00'] + x['22:00']", "sense": ">=", "expr_rhs": "demand['2:00']", "description": "Meet demand for 2:00-6:00"}, {"name": "demand_6:00", "expr_lhs": "x['6:00'] + x['2:00']", "sense": ">=", "expr_rhs": "demand['6:00']", "description": "Meet demand for 6:00-10:00"}, {"name": "demand_10:00", "expr_lhs": "x['10:00'] + x['6:00']", "sense": ">=", "expr_rhs": "demand['10:00']", "description": "Meet demand for 10:00-14:00"}, {"name": "demand_14:00", "expr_lhs": "x['14:00'] + x['10:00']", "sense": ">=", "expr_rhs": "demand['14:00']", "description": "Meet demand for 14:00-18:00"}, {"name": "demand_18:00", "expr_lhs": "x['18:00'] + x['14:00']", "sense": ">=", "expr_rhs": "demand['18:00']", "description": "Meet demand for 18:00-22:00"}, {"name": "demand_22:00", "expr_lhs": "x['22:00'] + x['18:00']", "sense": ">=", "expr_rhs": "demand['22:00']", "description": "Meet demand for 22:00-2:00"}]}, "eval": {"ground_truth_raw": "53", "ground_truth_value": 53.0, "obj_value": 53.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_12", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 4700.0}, "ir_dict": {"meta": {"problem_id": "industryOR_12", "source": "IndustryOR", "description": "A wood storage and transportation company has a large warehouse for storing and selling wood. Due to the fluctuation in wood prices each quarter, the company purchases wood at the beginning of each quarter, sells a portion within the same quarter, and stores the remaining amount for future sales. It is known that the maximum wood storage capacity of the company's warehouse is 200,000 $\\mathrm{m}^3$, and the storage cost is $(a+b u)$ yuan per $\\mathrm{m}^3$, where $a=70$, $b=100$, and $u$ is the storage time in quarters. The buying and selling prices for each quarter and the projected maximum sales volume are shown in Table 1-18.\nTable 1-18\n\\begin{tabular}{c|c|c|c}\n\\hline Quarter & Buying Price (10,000 yuan/$10,000 \\mathrm{m}^2$) & Selling Price (10,000 yuan/$10,000 \\mathrm{m}^2$) & Projected Maximum Sales Volume ($10,000 \\mathrm{m}^3$) \\\\\n\\hline Winter & 410 & 425 & 100 \\\\\nSpring & 430 & 440 & 140 \\\\\nSummer & 460 & 465 & 200 \\\\\nAutumn & 450 & 455 & 160 \\\\\n\\hline\n\\end{tabular}\n\nDue to the unsuitability of long-term wood storage, all inventory wood should be sold by the end of each autumn. Establish a linear programming model for this problem to maximize the company's annual profit.", "sense": "max", "version": "v1"}, "sets": [{"name": "Quarters", "elements": ["Winter", "Spring", "Summer", "Autumn"], "description": "The four quarters of the year."}], "params": [{"name": "buying_price", "indices": ["Quarters"], "values": {"Winter": 410.0, "Spring": 430.0, "Summer": 460.0, "Autumn": 450.0}, "description": "Buying price per 10,000 m^3 in each quarter."}, {"name": "selling_price", "indices": ["Quarters"], "values": {"Winter": 425.0, "Spring": 440.0, "Summer": 465.0, "Autumn": 455.0}, "description": "Selling price per 10,000 m^3 in each quarter."}, {"name": "max_sales", "indices": ["Quarters"], "values": {"Winter": 100.0, "Spring": 140.0, "Summer": 200.0, "Autumn": 160.0}, "description": "Projected maximum sales volume in 10,000 m^3 for each quarter."}, {"name": "storage_cost_a", "indices": [], "values": 70.0, "description": "Fixed storage cost per m^3."}, {"name": "storage_cost_b", "indices": [], "values": 100.0, "description": "Variable storage cost per m^3 per quarter."}, {"name": "max_storage", "indices": [], "values": 200.0, "description": "Maximum storage capacity in 10,000 m^3."}], "vars": [{"name": "purchase", "indices": ["Quarters"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Amount of wood purchased in 10,000 m^3 in each quarter."}, {"name": "sell", "indices": ["Quarters"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Amount of wood sold in 10,000 m^3 in each quarter."}, {"name": "inventory", "indices": ["Quarters"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Amount of wood in inventory in 10,000 m^3 at the end of each quarter."}], "objective": {"name": "profit", "sense": "max", "expr": "quicksum((selling_price[q] * sell[q] - buying_price[q] * purchase[q] - (storage_cost_a + storage_cost_b * (i+1)) * inventory[q]) for i, q in enumerate(Quarters))", "description": "Maximize the annual profit considering buying, selling, and storage costs."}, "constraints": [{"name": "inventory_balance_Winter", "expr_lhs": "inventory['Winter']", "sense": "==", "expr_rhs": "purchase['Winter'] - sell['Winter']", "description": "Inventory balance for Winter."}, {"name": "inventory_balance_Spring", "expr_lhs": "inventory['Spring']", "sense": "==", "expr_rhs": "inventory['Winter'] + purchase['Spring'] - sell['Spring']", "description": "Inventory balance for Spring."}, {"name": "inventory_balance_Summer", "expr_lhs": "inventory['Summer']", "sense": "==", "expr_rhs": "inventory['Spring'] + purchase['Summer'] - sell['Summer']", "description": "Inventory balance for Summer."}, {"name": "inventory_balance_Autumn", "expr_lhs": "inventory['Autumn']", "sense": "==", "expr_rhs": "inventory['Summer'] + purchase['Autumn'] - sell['Autumn']", "description": "Inventory balance for Autumn."}, {"name": "max_sales_Winter", "expr_lhs": "sell['Winter']", "sense": "<=", "expr_rhs": "max_sales['Winter']", "description": "Sales limit for Winter."}, {"name": "max_sales_Spring", "expr_lhs": "sell['Spring']", "sense": "<=", "expr_rhs": "max_sales['Spring']", "description": "Sales limit for Spring."}, {"name": "max_sales_Summer", "expr_lhs": "sell['Summer']", "sense": "<=", "expr_rhs": "max_sales['Summer']", "description": "Sales limit for Summer."}, {"name": "max_sales_Autumn", "expr_lhs": "sell['Autumn']", "sense": "<=", "expr_rhs": "max_sales['Autumn']", "description": "Sales limit for Autumn."}, {"name": "max_storage_Winter", "expr_lhs": "inventory['Winter']", "sense": "<=", "expr_rhs": "max_storage", "description": "Storage capacity limit for Winter."}, {"name": "max_storage_Spring", "expr_lhs": "inventory['Spring']", "sense": "<=", "expr_rhs": "max_storage", "description": "Storage capacity limit for Spring."}, {"name": "max_storage_Summer", "expr_lhs": "inventory['Summer']", "sense": "<=", "expr_rhs": "max_storage", "description": "Storage capacity limit for Summer."}, {"name": "max_storage_Autumn", "expr_lhs": "inventory['Autumn']", "sense": "<=", "expr_rhs": "max_storage", "description": "Storage capacity limit for Autumn."}, {"name": "end_inventory_Autumn", "expr_lhs": "inventory['Autumn']", "sense": "==", "expr_rhs": "0.0", "description": "All inventory must be sold by the end of Autumn."}]}, "eval": {"ground_truth_raw": "4700", "ground_truth_value": 4700.0, "obj_value": 4700.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_13", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 3.0}, "ir_dict": {"meta": {"problem_id": "industryOR_13", "source": "IndustryOR", "description": "A convenience store plans to open several chain stores in a new residential area in the northwest suburbs of the city. To facilitate shopping, the distance from any residential area to one of the chain stores should not exceed $800 \\mathrm{~m}$. Table 5-1 gives the newly built residential areas and the various areas within a radius of $800 \\mathrm{~m}$ of each residential area. How many chain stores should the supermarket build in the above-mentioned areas and in which areas should they be built?\nTable 5-1\n\\begin{tabular}{c|c}\n\\hline Area Code & Areas within $800 \\mathrm{~m}$ radius \\\\\n\\hline A & A C E G H I \\\\\nB & B H I \\\\\nC & A C G H I \\\\\nD & D J \\\\\nE & A E G \\\\\nF & F J K \\\\\nG & A C E G \\\\\nH & A B C H I \\\\\nI & A B C H I \\\\\nJ & D F J K L \\\\\nK & F J K L \\\\\nL & J K L \\\\\n\\hline\n\\end{tabular}", "sense": "min", "version": "v1"}, "sets": [{"name": "Areas", "elements": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"], "description": "Residential areas where stores can be opened"}], "params": [{"name": "coverage", "indices": ["Areas"], "values": {"A": ["A", "C", "E", "G", "H", "I"], "B": ["B", "H", "I"], "C": ["A", "C", "G", "H", "I"], "D": ["D", "J"], "E": ["A", "E", "G"], "F": ["F", "J", "K"], "G": ["A", "C", "E", "G"], "H": ["A", "B", "C", "H", "I"], "I": ["A", "B", "C", "H", "I"], "J": ["D", "F", "J", "K", "L"], "K": ["F", "J", "K", "L"], "L": ["J", "K", "L"]}, "description": "Areas within 800m radius of each area"}], "vars": [{"name": "y", "indices": ["Areas"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if a store is opened in the area, 0 otherwise"}], "objective": {"name": "min_stores", "sense": "min", "expr": "quicksum(y[i] for i in Areas)", "description": "Minimize the number of stores opened"}, "constraints": [{"name": "coverage_A", "expr_lhs": "y['A'] + y['C'] + y['E'] + y['G'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1.0", "description": "Area A must be covered by at least one store"}, {"name": "coverage_B", "expr_lhs": "y['B'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1.0", "description": "Area B must be covered by at least one store"}, {"name": "coverage_C", "expr_lhs": "y['A'] + y['C'] + y['G'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1.0", "description": "Area C must be covered by at least one store"}, {"name": "coverage_D", "expr_lhs": "y['D'] + y['J']", "sense": ">=", "expr_rhs": "1.0", "description": "Area D must be covered by at least one store"}, {"name": "coverage_E", "expr_lhs": "y['A'] + y['E'] + y['G']", "sense": ">=", "expr_rhs": "1.0", "description": "Area E must be covered by at least one store"}, {"name": "coverage_F", "expr_lhs": "y['F'] + y['J'] + y['K']", "sense": ">=", "expr_rhs": "1.0", "description": "Area F must be covered by at least one store"}, {"name": "coverage_G", "expr_lhs": "y['A'] + y['C'] + y['E'] + y['G']", "sense": ">=", "expr_rhs": "1.0", "description": "Area G must be covered by at least one store"}, {"name": "coverage_H", "expr_lhs": "y['A'] + y['B'] + y['C'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1.0", "description": "Area H must be covered by at least one store"}, {"name": "coverage_I", "expr_lhs": "y['A'] + y['B'] + y['C'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1.0", "description": "Area I must be covered by at least one store"}, {"name": "coverage_J", "expr_lhs": "y['D'] + y['F'] + y['J'] + y['K'] + y['L']", "sense": ">=", "expr_rhs": "1.0", "description": "Area J must be covered by at least one store"}, {"name": "coverage_K", "expr_lhs": "y['F'] + y['J'] + y['K'] + y['L']", "sense": ">=", "expr_rhs": "1.0", "description": "Area K must be covered by at least one store"}, {"name": "coverage_L", "expr_lhs": "y['J'] + y['K'] + y['L']", "sense": ">=", "expr_rhs": "1.0", "description": "Area L must be covered by at least one store"}]}, "eval": {"ground_truth_raw": "3", "ground_truth_value": 3.0, "obj_value": 3.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_14", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 37000.0}, "ir_dict": {"meta": {"problem_id": "industryOR_14", "source": "IndustryOR", "description": "A product can be processed on any one of the four devices A, B, C, or D. The setup completion cost for each device when it is activated, the unit cost of production for the product, and the maximum processing capacity for each device are known as shown in Table 5-7. How can the total cost be minimized to produce 2000 units of the product? Try to establish a mathematical model.\nTable 5-7\n\\begin{tabular}{c|c|c|c}\n\\hline Device & Setup Completion Cost (in yuan) & Production Cost (in yuan per unit) & Maximum Processing Capacity (units) \\\\\\hline A & 1000 & 20 & 900 \\\nB & 920 & 24 & 1000 \\\nC & 800 & 16 & 1200 \\\nD & 700 & 28 & 1600 \\\n\\hline\n\\end{tabular}", "sense": "min", "version": "v1"}, "sets": [{"name": "Devices", "elements": ["A", "B", "C", "D"], "description": "Set of devices available for production"}], "params": [{"name": "setup_cost", "indices": ["Devices"], "values": {"A": 1000.0, "B": 920.0, "C": 800.0, "D": 700.0}, "description": "Setup completion cost for each device"}, {"name": "production_cost", "indices": ["Devices"], "values": {"A": 20.0, "B": 24.0, "C": 16.0, "D": 28.0}, "description": "Production cost per unit for each device"}, {"name": "max_capacity", "indices": ["Devices"], "values": {"A": 900.0, "B": 1000.0, "C": 1200.0, "D": 1600.0}, "description": "Maximum processing capacity for each device"}], "vars": [{"name": "x", "indices": ["Devices"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of units produced by each device"}, {"name": "y", "indices": ["Devices"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a device is used"}], "objective": {"name": "total_cost", "sense": "min", "expr": "quicksum(setup_cost[d] * y[d] + production_cost[d] * x[d] for d in Devices)", "description": "Minimize total setup and production cost"}, "constraints": [{"name": "demand", "expr_lhs": "quicksum(x[d] for d in Devices)", "sense": "==", "expr_rhs": "2000.0", "description": "Total production must meet demand of 2000 units"}, {"name": "capacity_A", "expr_lhs": "x['A']", "sense": "<=", "expr_rhs": "max_capacity['A'] * y['A']", "description": "Production on device A cannot exceed its capacity if used"}, {"name": "capacity_B", "expr_lhs": "x['B']", "sense": "<=", "expr_rhs": "max_capacity['B'] * y['B']", "description": "Production on device B cannot exceed its capacity if used"}, {"name": "capacity_C", "expr_lhs": "x['C']", "sense": "<=", "expr_rhs": "max_capacity['C'] * y['C']", "description": "Production on device C cannot exceed its capacity if used"}, {"name": "capacity_D", "expr_lhs": "x['D']", "sense": "<=", "expr_rhs": "max_capacity['D'] * y['D']", "description": "Production on device D cannot exceed its capacity if used"}]}, "eval": {"ground_truth_raw": "37000", "ground_truth_value": 37000.0, "obj_value": 37000.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_15", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 4.0}, "ir_dict": {"meta": {"problem_id": "industryOR_15", "source": "IndustryOR", "description": "A master's student majoring in Operations Research at a certain university is required to take two math courses, two operations research courses, and two computer courses out of a total of seven courses: calculus, operations research, data structures, management statistics, computer simulation, computer programming, and forecasting. Some courses belong to only one category: calculus belongs to the math category, and computer programming belongs to the computer category. However, some courses are cross-categories: operations research belongs to both the operations research and math categories, data structures belong to both the computer and math categories, management statistics belongs to both the math and operations research categories, computer simulation belongs to both the computer and operations research categories, and forecasting belongs to both the operations research and math categories. For courses that belong to two categories, taking the course can be considered as taking one course in each category. In addition, some courses require prerequisite courses: computer simulation or data structures must be taken after taking computer programming, management statistics must be taken after taking calculus, and forecasting must be taken after taking management statistics. The question is: how many and which courses should a master's student take at minimum to meet the above requirements?", "sense": "min", "version": "v1"}, "sets": [{"name": "Courses", "elements": ["calculus", "operations_research", "data_structures", "management_statistics", "computer_simulation", "computer_programming", "forecasting"], "description": "List of available courses"}, {"name": "Categories", "elements": ["math", "operations_research", "computer"], "description": "Course categories"}], "params": [{"name": "category_requirements", "indices": ["Categories"], "values": {"math": 2, "operations_research": 2, "computer": 2}, "description": "Number of courses required per category"}, {"name": "course_categories", "indices": ["Courses"], "values": {"calculus": ["math"], "operations_research": ["operations_research", "math"], "data_structures": ["computer", "math"], "management_statistics": ["math", "operations_research"], "computer_simulation": ["computer", "operations_research"], "computer_programming": ["computer"], "forecasting": ["operations_research", "math"]}, "description": "Categories each course belongs to"}, {"name": "prerequisites", "indices": ["Courses"], "values": {"computer_simulation": ["computer_programming"], "data_structures": ["computer_programming"], "management_statistics": ["calculus"], "forecasting": ["management_statistics"]}, "description": "Prerequisite courses for each course"}], "vars": [{"name": "x", "indices": ["Courses"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if course is taken, 0 otherwise"}], "objective": {"name": "minimize_courses", "sense": "min", "expr": "quicksum(x[c] for c in Courses)", "description": "Minimize the number of courses taken"}, "constraints": [{"name": "math_requirement", "expr_lhs": "quicksum(x[c] for c in Courses if 'math' in course_categories[c])", "sense": ">=", "expr_rhs": "category_requirements['math']", "description": "Meet math course requirement"}, {"name": "operations_research_requirement", "expr_lhs": "quicksum(x[c] for c in Courses if 'operations_research' in course_categories[c])", "sense": ">=", "expr_rhs": "category_requirements['operations_research']", "description": "Meet operations research course requirement"}, {"name": "computer_requirement", "expr_lhs": "quicksum(x[c] for c in Courses if 'computer' in course_categories[c])", "sense": ">=", "expr_rhs": "category_requirements['computer']", "description": "Meet computer course requirement"}, {"name": "prerequisite_computer_simulation", "expr_lhs": "x['computer_simulation']", "sense": "<=", "expr_rhs": "x['computer_programming']", "description": "Computer simulation requires computer programming"}, {"name": "prerequisite_data_structures", "expr_lhs": "x['data_structures']", "sense": "<=", "expr_rhs": "x['computer_programming']", "description": "Data structures requires computer programming"}, {"name": "prerequisite_management_statistics", "expr_lhs": "x['management_statistics']", "sense": "<=", "expr_rhs": "x['calculus']", "description": "Management statistics requires calculus"}, {"name": "prerequisite_forecasting", "expr_lhs": "x['forecasting']", "sense": "<=", "expr_rhs": "x['management_statistics']", "description": "Forecasting requires management statistics"}]}, "eval": {"ground_truth_raw": "4", "ground_truth_value": 4.0, "obj_value": 4.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_16", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 20300.0}, "ir_dict": {"meta": {"problem_id": "industryOR_16", "source": "IndustryOR", "description": "Red Star Plastic Factory produces 6 types of plastic containers, with their capacities, demands, and variable costs shown in Table 5-11.\nTable 5-11\n\\begin{tabular}{c|c|c|c|c|c|c}\n\\hline Container Code & 1 & 2 & 3 & 4 & 5 & 6 \\\n\\hline Capacity $(\\mathrm{cm}^3)$ & 1500 & 2500 & 4000 & 6000 & 9000 & 12000 \\\nDemand/units & 500 & 550 & 700 & 900 & 400 & 300 \\\nVariable Cost/(/unit) & 5 & 8 & 10 & 12 & 16 & 18 \\\n\\hline\n\\end{tabular}\n\nEach type of container is produced using different dedicated equipment, with a fixed cost of 1200. When the quantity of a certain container cannot meet the demand, containers with larger capacities can be used as substitutes. How should production be organized to minimize the total cost while meeting the demand?", "sense": "min", "version": "v1"}, "sets": [{"name": "C", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Container types"}], "params": [{"name": "capacity", "indices": ["C"], "values": {"1": 1500.0, "2": 2500.0, "3": 4000.0, "4": 6000.0, "5": 9000.0, "6": 12000.0}, "description": "Capacity of each container type in cm^3"}, {"name": "demand", "indices": ["C"], "values": {"1": 500.0, "2": 550.0, "3": 700.0, "4": 900.0, "5": 400.0, "6": 300.0}, "description": "Demand for each container type in units"}, {"name": "variable_cost", "indices": ["C"], "values": {"1": 5.0, "2": 8.0, "3": 10.0, "4": 12.0, "5": 16.0, "6": 18.0}, "description": "Variable cost per unit for each container type"}, {"name": "fixed_cost", "indices": [], "values": 1200.0, "description": "Fixed cost for using equipment for each container type"}], "vars": [{"name": "x", "indices": ["C"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of units produced for each container type"}, {"name": "y", "indices": ["C"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if equipment for a container type is used"}], "objective": {"name": "total_cost", "sense": "min", "expr": "quicksum(variable_cost[c] * x[c] + fixed_cost * y[c] for c in C)", "description": "Minimize total production cost"}, "constraints": [{"name": "demand_satisfaction_1", "expr_lhs": "x['1']", "sense": ">=", "expr_rhs": "demand['1']", "description": "Meet demand for container type 1"}, {"name": "demand_satisfaction_2", "expr_lhs": "x['2'] + x['3'] + x['4'] + x['5'] + x['6']", "sense": ">=", "expr_rhs": "demand['2']", "description": "Meet demand for container type 2, allowing substitution"}, {"name": "demand_satisfaction_3", "expr_lhs": "x['3'] + x['4'] + x['5'] + x['6']", "sense": ">=", "expr_rhs": "demand['3']", "description": "Meet demand for container type 3, allowing substitution"}, {"name": "demand_satisfaction_4", "expr_lhs": "x['4'] + x['5'] + x['6']", "sense": ">=", "expr_rhs": "demand['4']", "description": "Meet demand for container type 4, allowing substitution"}, {"name": "demand_satisfaction_5", "expr_lhs": "x['5'] + x['6']", "sense": ">=", "expr_rhs": "demand['5']", "description": "Meet demand for container type 5, allowing substitution"}, {"name": "demand_satisfaction_6", "expr_lhs": "x['6']", "sense": ">=", "expr_rhs": "demand['6']", "description": "Meet demand for container type 6"}, {"name": "equipment_usage_1", "expr_lhs": "x['1']", "sense": "<=", "expr_rhs": "demand['1'] * y['1']", "description": "Link production and equipment usage for container type 1"}, {"name": "equipment_usage_2", "expr_lhs": "x['2']", "sense": "<=", "expr_rhs": "demand['2'] * y['2']", "description": "Link production and equipment usage for container type 2"}, {"name": "equipment_usage_3", "expr_lhs": "x['3']", "sense": "<=", "expr_rhs": "demand['3'] * y['3']", "description": "Link production and equipment usage for container type 3"}, {"name": "equipment_usage_4", "expr_lhs": "x['4']", "sense": "<=", "expr_rhs": "demand['4'] * y['4']", "description": "Link production and equipment usage for container type 4"}, {"name": "equipment_usage_5", "expr_lhs": "x['5']", "sense": "<=", "expr_rhs": "demand['5'] * y['5']", "description": "Link production and equipment usage for container type 5"}, {"name": "equipment_usage_6", "expr_lhs": "x['6']", "sense": "<=", "expr_rhs": "demand['6'] * y['6']", "description": "Link production and equipment usage for container type 6"}]}, "eval": {"ground_truth_raw": "43700", "ground_truth_value": 43700.0, "obj_value": 20300.0, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_17", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 6800.0}, "ir_dict": {"meta": {"problem_id": "industryOR_17", "source": "IndustryOR", "description": "A production base needs to extract raw materials from warehouses A and B every day for production. The required amounts of raw materials are: at least 240 units of material A, at least 80 kg of material B, and at least 120 tons of material C. It is known that each truck from warehouse A can transport 4 units of material A, 2 kg of material B, and 6 tons of material C, with a freight cost of $200 per truck. Each truck from warehouse B can transport 7 units of material A, 2 kg of material B, and 2 tons of material C, with a freight cost of $160 per truck. The question is: to meet the production needs, how many trucks should the production base send to warehouses A and B each day to minimize the total freight cost?", "sense": "min", "version": "v1"}, "sets": [{"name": "Warehouses", "elements": ["A", "B"], "description": "Warehouses from which materials are transported"}, {"name": "Materials", "elements": ["MaterialA", "MaterialB", "MaterialC"], "description": "Types of materials to be transported"}], "params": [{"name": "transport_capacity", "indices": ["Warehouses", "Materials"], "values": {"A": {"MaterialA": 4.0, "MaterialB": 2.0, "MaterialC": 6.0}, "B": {"MaterialA": 7.0, "MaterialB": 2.0, "MaterialC": 2.0}}, "description": "Transport capacity of each truck from each warehouse for each material"}, {"name": "freight_cost", "indices": ["Warehouses"], "values": {"A": 200.0, "B": 160.0}, "description": "Freight cost per truck from each warehouse"}, {"name": "demand", "indices": ["Materials"], "values": {"MaterialA": 240.0, "MaterialB": 80.0, "MaterialC": 120.0}, "description": "Minimum required amount of each material"}], "vars": [{"name": "trucks", "indices": ["Warehouses"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of trucks to send from each warehouse"}], "objective": {"name": "minimize_cost", "sense": "min", "expr": "quicksum(freight_cost[w] * trucks[w] for w in Warehouses)", "description": "Minimize the total freight cost"}, "constraints": [{"name": "materialA_requirement", "expr_lhs": "quicksum(transport_capacity[w]['MaterialA'] * trucks[w] for w in Warehouses)", "sense": ">=", "expr_rhs": "demand['MaterialA']", "description": "Ensure enough Material A is transported"}, {"name": "materialB_requirement", "expr_lhs": "quicksum(transport_capacity[w]['MaterialB'] * trucks[w] for w in Warehouses)", "sense": ">=", "expr_rhs": "demand['MaterialB']", "description": "Ensure enough Material B is transported"}, {"name": "materialC_requirement", "expr_lhs": "quicksum(transport_capacity[w]['MaterialC'] * trucks[w] for w in Warehouses)", "sense": ">=", "expr_rhs": "demand['MaterialC']", "description": "Ensure enough Material C is transported"}]}, "eval": {"ground_truth_raw": "6800", "ground_truth_value": 6800.0, "obj_value": 6800.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_18", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 150.0}, "ir_dict": {"meta": {"problem_id": "industryOR_18", "source": "IndustryOR", "description": "The number of drivers and crew members required for each time period of a certain day and night service bus route is shown in Table 1-17.\nTable 1-17\n\\begin{tabular}{c|c|c}\n\\hline Shift & Time & Number Required \\\\\n\\hline 1 & $6: 00 \\sim 10: 00$ & 60 \\\\\n\\hline 2 & $10: 00 \\sim 14: 00$ & 70 \\\\\n\\hline 3 & $14: 00 \\sim 18: 00$ & 60 \\\\\n\\hline 4 & $22: 00 \\sim 22: 00$ & 50 \\\\\n\\hline 5 & $22: 00 \\sim 2: 00$ & 20 \\\\\n\\hline 6 & $2: 00 \\sim 6: 00$ & 30 \\\\\n\\hline\n\\end{tabular}\n\nAssuming the drivers and crew members start working at the beginning of each time period and work continuously for eight hours, how many drivers and crew members should be equipped for this bus route at least? Provide the linear programming model for this problem.", "sense": "min", "version": "v1"}, "sets": [{"name": "Shifts", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Time periods for the bus route"}], "params": [{"name": "required", "indices": ["Shifts"], "values": {"1": 60, "2": 70, "3": 60, "4": 50, "5": 20, "6": 30}, "description": "Number of drivers and crew members required for each shift"}], "vars": [{"name": "x", "indices": ["Shifts"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of drivers and crew members starting at each shift"}], "objective": {"name": "minimize_crew", "sense": "min", "expr": "quicksum(x[s] for s in Shifts)", "description": "Minimize the total number of drivers and crew members"}, "constraints": [{"name": "shift_1_requirement", "expr_lhs": "x['1'] + x['5'] + x['6']", "sense": ">=", "expr_rhs": "required['1']", "description": "Meet the requirement for shift 1"}, {"name": "shift_2_requirement", "expr_lhs": "x['1'] + x['2']", "sense": ">=", "expr_rhs": "required['2']", "description": "Meet the requirement for shift 2"}, {"name": "shift_3_requirement", "expr_lhs": "x['2'] + x['3']", "sense": ">=", "expr_rhs": "required['3']", "description": "Meet the requirement for shift 3"}, {"name": "shift_4_requirement", "expr_lhs": "x['3'] + x['4']", "sense": ">=", "expr_rhs": "required['4']", "description": "Meet the requirement for shift 4"}, {"name": "shift_5_requirement", "expr_lhs": "x['4'] + x['5']", "sense": ">=", "expr_rhs": "required['5']", "description": "Meet the requirement for shift 5"}, {"name": "shift_6_requirement", "expr_lhs": "x['5'] + x['6']", "sense": ">=", "expr_rhs": "required['6']", "description": "Meet the requirement for shift 6"}]}, "eval": {"ground_truth_raw": "150", "ground_truth_value": 150.0, "obj_value": 150.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_19", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 1030.0}, "ir_dict": {"meta": {"problem_id": "industryOR_19", "source": "IndustryOR", "description": "There are two coal mines, A and B, with monthly coal supplies of at least 80 tons and 100 tons, respectively. They are responsible for supplying coal to three residential areas, which require 55 tons, 75 tons, and 50 tons of coal per month, respectively. The distances between mine A and these three residential areas are 10 kilometers, 5 kilometers, and 6 kilometers. The distances between mine B and these three residential areas are 4 kilometers, 8 kilometers, and 15 kilometers. How should these two coal mines distribute the coal to the three residential areas to minimize the ton-kilometers of transportation?", "sense": "min", "version": "v1"}, "sets": [{"name": "M", "elements": ["A", "B"], "description": "Coal mines"}, {"name": "R", "elements": ["R1", "R2", "R3"], "description": "Residential areas"}], "params": [{"name": "supply", "indices": ["M"], "values": {"A": 80.0, "B": 100.0}, "description": "Monthly coal supply from each mine"}, {"name": "demand", "indices": ["R"], "values": {"R1": 55.0, "R2": 75.0, "R3": 50.0}, "description": "Monthly coal demand for each residential area"}, {"name": "distance", "indices": ["M", "R"], "values": {"A": {"R1": 10.0, "R2": 5.0, "R3": 6.0}, "B": {"R1": 4.0, "R2": 8.0, "R3": 15.0}}, "description": "Distances from mines to residential areas"}], "vars": [{"name": "x", "indices": ["M", "R"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Amount of coal transported from mine to residential area"}], "objective": {"name": "min_transport_cost", "sense": "min", "expr": "quicksum(distance[m][r] * x[m][r] for m in M for r in R)", "description": "Minimize the total transportation cost in ton-kilometers"}, "constraints": [{"name": "supply_A", "expr_lhs": "quicksum(x['A'][r] for r in R)", "sense": "<=", "expr_rhs": "supply['A']", "description": "Supply constraint for mine A"}, {"name": "supply_B", "expr_lhs": "quicksum(x['B'][r] for r in R)", "sense": "<=", "expr_rhs": "supply['B']", "description": "Supply constraint for mine B"}, {"name": "demand_R1", "expr_lhs": "x['A']['R1'] + x['B']['R1']", "sense": "==", "expr_rhs": "demand['R1']", "description": "Demand constraint for residential area R1"}, {"name": "demand_R2", "expr_lhs": "x['A']['R2'] + x['B']['R2']", "sense": "==", "expr_rhs": "demand['R2']", "description": "Demand constraint for residential area R2"}, {"name": "demand_R3", "expr_lhs": "x['A']['R3'] + x['B']['R3']", "sense": "==", "expr_rhs": "demand['R3']", "description": "Demand constraint for residential area R3"}]}, "eval": {"ground_truth_raw": "1030", "ground_truth_value": 1030.0, "obj_value": 1030.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_20", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 57.0}, "ir_dict": {"meta": {"problem_id": "industryOR_20", "source": "IndustryOR", "description": "There are two products, A and B, which both require two chemical reaction processes: one before and one after. Each unit of product A requires 2 hours for the front process and 3 hours for the back process. Each unit of product B requires 3 hours for the front process and 4 hours for the back process. There are 16 hours available for the front process and 24 hours available for the back process.\n\nFor each unit of product B produced, two units of byproduct C are generated, which do not require any additional cost. Up to 5 units of byproduct C can be sold, while the remaining units must be disposed of, with a disposal cost of $2 per unit.\n\nSelling one unit of product A yields a profit of $4, selling one unit of product B yields a profit of $10, and selling one unit of byproduct C yields a profit of $3.\n\nTo maximize the total profit obtained, establish the linear programming model for this problem.", "sense": "max", "version": "v1"}, "sets": [{"name": "Products", "elements": ["A", "B"], "description": "Set of products"}], "params": [{"name": "front_time", "indices": ["Products"], "values": {"A": 2.0, "B": 3.0}, "description": "Time required for front process per unit of product"}, {"name": "back_time", "indices": ["Products"], "values": {"A": 3.0, "B": 4.0}, "description": "Time required for back process per unit of product"}, {"name": "profit", "indices": ["Products"], "values": {"A": 4.0, "B": 10.0}, "description": "Profit per unit of product sold"}, {"name": "byproduct_profit", "indices": [], "values": 3.0, "description": "Profit per unit of byproduct C sold"}, {"name": "disposal_cost", "indices": [], "values": 2.0, "description": "Cost per unit of byproduct C disposed"}, {"name": "max_front_hours", "indices": [], "values": 16.0, "description": "Maximum available hours for front process"}, {"name": "max_back_hours", "indices": [], "values": 24.0, "description": "Maximum available hours for back process"}, {"name": "max_byproduct_sales", "indices": [], "values": 5.0, "description": "Maximum units of byproduct C that can be sold"}], "vars": [{"name": "x", "indices": ["Products"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Units of product produced"}, {"name": "y", "indices": [], "vartype": "integer", "lb": 0.0, "ub": 5.0, "description": "Units of byproduct C sold"}], "objective": {"name": "total_profit", "sense": "max", "expr": "quicksum(profit[p] * x[p] for p in Products) + byproduct_profit * y - disposal_cost * (2 * x['B'] - y)", "description": "Maximize total profit from products and byproduct sales"}, "constraints": [{"name": "front_process_hours", "expr_lhs": "quicksum(front_time[p] * x[p] for p in Products)", "sense": "<=", "expr_rhs": "max_front_hours", "description": "Front process hours constraint"}, {"name": "back_process_hours", "expr_lhs": "quicksum(back_time[p] * x[p] for p in Products)", "sense": "<=", "expr_rhs": "max_back_hours", "description": "Back process hours constraint"}, {"name": "byproduct_balance", "expr_lhs": "y", "sense": "<=", "expr_rhs": "2 * x['B']", "description": "Byproduct C sales cannot exceed production"}]}, "eval": {"ground_truth_raw": "57", "ground_truth_value": 57.0, "obj_value": 57.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_21", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 57.099999999999994}, "ir_dict": {"meta": {"problem_id": "industryOR_21", "source": "IndustryOR", "description": "On Danzig Street, vehicles can park on both sides of the street. Mr. Edmunds, who lives at number 1, is organizing a party with about 30 attendees who will arrive in 15 cars. The length of the i-th car, denoted as $\\lambda_i$, is given in meters as follows:\ni 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n$\\lambda_i$ 4 4.5 5 4.1 2.4 5.2 3.7 3.5 3.2 4.5 2.3 3.3 3.8 4.6 3\n\nTo avoid disturbing the neighbors, Mr. Edmunds wants to arrange the parking on both sides of the street in such a way that the total length of the street occupied by his friends' cars is minimized. Please provide a mathematical programming formulation and solve this problem using AMPL.\nIf the vehicles on one side of the street cannot occupy more than 15 meters exactly, how would the program change?", "sense": "min", "version": "v1"}, "sets": [{"name": "Cars", "elements": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"], "description": "Set of cars"}, {"name": "Sides", "elements": ["left", "right"], "description": "Sides of the street"}], "params": [{"name": "length", "indices": ["Cars"], "values": {"1": 4.0, "2": 4.5, "3": 5.0, "4": 4.1, "5": 2.4, "6": 5.2, "7": 3.7, "8": 3.5, "9": 3.2, "10": 4.5, "11": 2.3, "12": 3.3, "13": 3.8, "14": 4.6, "15": 3.0}, "description": "Length of each car in meters"}], "vars": [{"name": "x", "indices": ["Cars", "Sides"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if car i is parked on side j"}], "objective": {"name": "minimize_total_length", "sense": "min", "expr": "quicksum(length[i] * (x[i]['left'] + x[i]['right']) for i in Cars)", "description": "Minimize the total length of the street occupied by cars"}, "constraints": [{"name": "one_side_constraint", "expr_lhs": "quicksum(length[i] * x[i]['left'] for i in Cars)", "sense": "<=", "expr_rhs": "15.0", "description": "The total length of cars on the left side cannot exceed 15 meters"}, {"name": "one_car_one_side", "expr_lhs": "x['1']['left'] + x['1']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 1 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['2']['left'] + x['2']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 2 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['3']['left'] + x['3']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 3 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['4']['left'] + x['4']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 4 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['5']['left'] + x['5']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 5 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['6']['left'] + x['6']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 6 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['7']['left'] + x['7']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 7 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['8']['left'] + x['8']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 8 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['9']['left'] + x['9']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 9 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['10']['left'] + x['10']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 10 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['11']['left'] + x['11']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 11 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['12']['left'] + x['12']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 12 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['13']['left'] + x['13']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 13 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['14']['left'] + x['14']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 14 must be parked on exactly one side"}, {"name": "one_car_one_side", "expr_lhs": "x['15']['left'] + x['15']['right']", "sense": "==", "expr_rhs": "1.0", "description": "Car 15 must be parked on exactly one side"}]}, "eval": {"ground_truth_raw": "42.1", "ground_truth_value": 42.1, "obj_value": 57.099999999999994, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_22", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": ["unroll_free_index_constraints", "type_template_rescue"], "repairs": ["unroll_free_index_constraints", "type_template_rescue"]}, "solver": {"status_name": "OPTIMAL", "obj_value": 14.0}, "ir_dict": {"meta": {"problem_id": "industryOR_22", "source": "IndustryOR", "description": "Now we need to determine 4 out of 5 workers to each complete one of the four tasks. Since each worker has different skill sets, the amount of time required for each worker to complete each task is also different. The time required for each worker to complete each task is shown in Table 5-2.\nTable 5-2\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline Task Time Required & $A$ & $B$ & $C$ & $D$ \\\\\n\\hline Worker & & & & \\\\\n\\hline I & 9 & 4 & 3 & 7 \\\\\n\\hline II & 4 & 6 & 5 & 6 \\\\\n\\hline III & 5 & 4 & 7 & 5 \\\\\n\\hline IV & 7 & 5 & 2 & 3 \\\\\n\\hline V & 10 & 6 & 7 & 4 \\\\\n\\hline\n\\end{tabular}\n\nTry to find a work assignment plan that minimizes the total working hours.", "sense": "min", "version": "v1"}, "sets": [{"name": "Workers", "elements": ["I", "II", "III", "IV", "V"], "description": "Set of workers"}, {"name": "Tasks", "elements": ["A", "B", "C", "D"], "description": "Set of tasks"}], "params": [{"name": "time", "indices": ["Workers", "Tasks"], "values": {"I": {"A": 9, "B": 4, "C": 3, "D": 7}, "II": {"A": 4, "B": 6, "C": 5, "D": 6}, "III": {"A": 5, "B": 4, "C": 7, "D": 5}, "IV": {"A": 7, "B": 5, "C": 2, "D": 3}, "V": {"A": 10, "B": 6, "C": 7, "D": 4}}, "description": "Time required for each worker to complete each task"}], "vars": [{"name": "assign", "indices": ["Workers", "Tasks"], "vartype": "binary", "lb": 0, "ub": 1, "description": "1 if worker is assigned to task, 0 otherwise"}], "objective": {"name": "total_time", "sense": "min", "expr": "quicksum(time[w][t] * assign[w][t] for w in Workers for t in Tasks)", "description": "Minimize total working hours"}, "constraints": [{"name": "task_assignment", "expr_lhs": "quicksum(assign[w][t] for w in Workers)", "sense": "==", "expr_rhs": "1", "description": "Each task is assigned to exactly one worker"}, {"name": "worker_limit", "expr_lhs": "quicksum(assign[w][t] for t in Tasks)", "sense": "<=", "expr_rhs": "1", "description": "Each worker is assigned to at most one task"}, {"name": "total_workers", "expr_lhs": "quicksum(assign[w][t] for w in Workers for t in Tasks)", "sense": "==", "expr_rhs": "4", "description": "Exactly 4 workers are assigned in total"}]}, "eval": {"ground_truth_raw": "14", "ground_truth_value": 14.0, "obj_value": 14.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_23", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 1000.0}, "ir_dict": {"meta": {"problem_id": "industryOR_23", "source": "IndustryOR", "description": "A manufacturing company needs to transport 1800 units of products from the warehouse to three different sales points. The company has four transportation options to choose from: trucks, vans, motorcycles, and electric vehicles. Due to the high energy consumption of vans and electric vehicles, the company wants to choose only one of these two transportation options. Trucks generate 100 units of pollution per trip, vans generate 50 units of pollution, motorcycles generate 10 units of pollution, and electric vehicles generate 0 units of pollution. The total pollution generated by all trips must not exceed 2000 units. Trucks must be used at least 10 times. Trucks, vans, motorcycles, and electric vehicles can carry 100 units, 80 units, 40 units, and 60 units of products per trip, respectively. The company needs to ensure that the total quantity of products transported is at least 1800 units.", "sense": "min", "version": "v1"}, "sets": [{"name": "Vehicles", "elements": ["trucks", "vans", "motorcycles", "electric_vehicles"], "description": null}], "params": [{"name": "pollution", "indices": ["Vehicles"], "values": {"trucks": 100.0, "vans": 50.0, "motorcycles": 10.0, "electric_vehicles": 0.0}, "description": null}, {"name": "capacity", "indices": ["Vehicles"], "values": {"trucks": 100.0, "vans": 80.0, "motorcycles": 40.0, "electric_vehicles": 60.0}, "description": null}], "vars": [{"name": "trips", "indices": ["Vehicles"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of trips for each vehicle type"}, {"name": "use_van_or_ev", "indices": [], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable to choose between van and electric vehicle"}], "objective": {"name": "minimize_pollution", "sense": "min", "expr": "quicksum(pollution[v] * trips[v] for v in Vehicles)", "description": "Minimize total pollution"}, "constraints": [{"name": "total_units", "expr_lhs": "quicksum(capacity[v] * trips[v] for v in Vehicles)", "sense": ">=", "expr_rhs": "1800.0", "description": "Ensure at least 1800 units are transported"}, {"name": "pollution_limit", "expr_lhs": "quicksum(pollution[v] * trips[v] for v in Vehicles)", "sense": "<=", "expr_rhs": "2000.0", "description": "Total pollution must not exceed 2000 units"}, {"name": "trucks_minimum", "expr_lhs": "trips['trucks']", "sense": ">=", "expr_rhs": "10.0", "description": "Trucks must be used at least 10 times"}, {"name": "van_or_ev_choice", "expr_lhs": "trips['vans']", "sense": "<=", "expr_rhs": "1000.0 * use_van_or_ev", "description": "Choose only one between vans and electric vehicles"}, {"name": "ev_or_van_choice", "expr_lhs": "trips['electric_vehicles']", "sense": "<=", "expr_rhs": "1000.0 * (1 - use_van_or_ev)", "description": "Choose only one between electric vehicles and vans"}]}, "eval": {"ground_truth_raw": "1000.0", "ground_truth_value": 1000.0, "obj_value": 1000.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_24", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": -5700.0}, "ir_dict": {"meta": {"problem_id": "industryOR_24", "source": "IndustryOR", "description": "A company that produces only one product has 40 workers. Each worker produces 20 units per month. The demand for the semester changes according to the following table:\n\n| Month | 1 | 2 | 3 | 4 | 5 | 6 |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Demand (units) | 700 | 600 | 500 | 800 | 900 | 800 |\n\nTo adjust production based on demand, the company can offer some (paid) additional working hours (each worker can produce a maximum of 6 extra units per month, with a unit cost of 5 euros), use warehouse space (10 euros per unit per month), and hire or lay off employees (the number of employees can vary by a maximum of $\\\\pm 5$ per month, with a hiring cost of 500 euros per person and a layoff cost of 700 euros per person).\n\nInitially, the warehouse space is empty, and we require it to be empty at the end of the semester as well. Develop a mathematical program to maximize revenue and solve it using COPTPY. How does the objective function change when all variables are relaxed to continuous?", "sense": "max", "version": "v1"}, "sets": [{"name": "T", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Months in the semester"}], "params": [{"name": "demand", "indices": ["T"], "values": {"1": 700, "2": 600, "3": 500, "4": 800, "5": 900, "6": 800}, "description": "Demand for each month"}, {"name": "initial_workers", "indices": [], "values": 40, "description": "Initial number of workers"}, {"name": "production_per_worker", "indices": [], "values": 20, "description": "Units produced per worker per month"}, {"name": "extra_production_cost", "indices": [], "values": 5, "description": "Cost per extra unit produced"}, {"name": "storage_cost", "indices": [], "values": 10, "description": "Cost per unit stored per month"}, {"name": "hiring_cost", "indices": [], "values": 500, "description": "Cost per worker hired"}, {"name": "layoff_cost", "indices": [], "values": 700, "description": "Cost per worker laid off"}, {"name": "max_worker_change", "indices": [], "values": 5, "description": "Maximum change in number of workers per month"}, {"name": "max_extra_units", "indices": [], "values": 6, "description": "Maximum extra units a worker can produce per month"}], "vars": [{"name": "extra_units", "indices": ["T"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Extra units produced each month"}, {"name": "stored_units", "indices": ["T"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Units stored at the end of each month"}, {"name": "hired_workers", "indices": ["T"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Workers hired each month"}, {"name": "laid_off_workers", "indices": ["T"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Workers laid off each month"}, {"name": "workers", "indices": ["T"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of workers each month"}], "objective": {"name": "revenue", "sense": "max", "expr": "quicksum(production_per_worker * workers[t] + extra_units[t] - extra_production_cost * extra_units[t] - storage_cost * stored_units[t] - hiring_cost * hired_workers[t] - layoff_cost * laid_off_workers[t] for t in T)", "description": "Maximize revenue by balancing production, storage, hiring, and layoffs"}, "constraints": [{"name": "production_balance_1", "expr_lhs": "production_per_worker * workers['1'] + extra_units['1'] - stored_units['1']", "sense": "==", "expr_rhs": "demand['1']", "description": "Production balance for month 1"}, {"name": "production_balance_2", "expr_lhs": "production_per_worker * workers['2'] + extra_units['2'] + stored_units['1'] - stored_units['2']", "sense": "==", "expr_rhs": "demand['2']", "description": "Production balance for month 2"}, {"name": "production_balance_3", "expr_lhs": "production_per_worker * workers['3'] + extra_units['3'] + stored_units['2'] - stored_units['3']", "sense": "==", "expr_rhs": "demand['3']", "description": "Production balance for month 3"}, {"name": "production_balance_4", "expr_lhs": "production_per_worker * workers['4'] + extra_units['4'] + stored_units['3'] - stored_units['4']", "sense": "==", "expr_rhs": "demand['4']", "description": "Production balance for month 4"}, {"name": "production_balance_5", "expr_lhs": "production_per_worker * workers['5'] + extra_units['5'] + stored_units['4'] - stored_units['5']", "sense": "==", "expr_rhs": "demand['5']", "description": "Production balance for month 5"}, {"name": "production_balance_6", "expr_lhs": "production_per_worker * workers['6'] + extra_units['6'] + stored_units['5']", "sense": "==", "expr_rhs": "demand['6']", "description": "Production balance for month 6"}, {"name": "initial_workers", "expr_lhs": "workers['1']", "sense": "==", "expr_rhs": "initial_workers + hired_workers['1'] - laid_off_workers['1']", "description": "Initial workers setup"}, {"name": "worker_balance_2", "expr_lhs": "workers['2']", "sense": "==", "expr_rhs": "workers['1'] + hired_workers['2'] - laid_off_workers['2']", "description": "Worker balance for month 2"}, {"name": "worker_balance_3", "expr_lhs": "workers['3']", "sense": "==", "expr_rhs": "workers['2'] + hired_workers['3'] - laid_off_workers['3']", "description": "Worker balance for month 3"}, {"name": "worker_balance_4", "expr_lhs": "workers['4']", "sense": "==", "expr_rhs": "workers['3'] + hired_workers['4'] - laid_off_workers['4']", "description": "Worker balance for month 4"}, {"name": "worker_balance_5", "expr_lhs": "workers['5']", "sense": "==", "expr_rhs": "workers['4'] + hired_workers['5'] - laid_off_workers['5']", "description": "Worker balance for month 5"}, {"name": "worker_balance_6", "expr_lhs": "workers['6']", "sense": "==", "expr_rhs": "workers['5'] + hired_workers['6'] - laid_off_workers['6']", "description": "Worker balance for month 6"}, {"name": "max_worker_change_1", "expr_lhs": "hired_workers['1'] + laid_off_workers['1']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 1"}, {"name": "max_worker_change_2", "expr_lhs": "hired_workers['2'] + laid_off_workers['2']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 2"}, {"name": "max_worker_change_3", "expr_lhs": "hired_workers['3'] + laid_off_workers['3']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 3"}, {"name": "max_worker_change_4", "expr_lhs": "hired_workers['4'] + laid_off_workers['4']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 4"}, {"name": "max_worker_change_5", "expr_lhs": "hired_workers['5'] + laid_off_workers['5']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 5"}, {"name": "max_worker_change_6", "expr_lhs": "hired_workers['6'] + laid_off_workers['6']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 6"}, {"name": "max_extra_units_1", "expr_lhs": "extra_units['1']", "sense": "<=", "expr_rhs": "max_extra_units * workers['1']", "description": "Max extra units for month 1"}, {"name": "max_extra_units_2", "expr_lhs": "extra_units['2']", "sense": "<=", "expr_rhs": "max_extra_units * workers['2']", "description": "Max extra units for month 2"}, {"name": "max_extra_units_3", "expr_lhs": "extra_units['3']", "sense": "<=", "expr_rhs": "max_extra_units * workers['3']", "description": "Max extra units for month 3"}, {"name": "max_extra_units_4", "expr_lhs": "extra_units['4']", "sense": "<=", "expr_rhs": "max_extra_units * workers['4']", "description": "Max extra units for month 4"}, {"name": "max_extra_units_5", "expr_lhs": "extra_units['5']", "sense": "<=", "expr_rhs": "max_extra_units * workers['5']", "description": "Max extra units for month 5"}, {"name": "max_extra_units_6", "expr_lhs": "extra_units['6']", "sense": "<=", "expr_rhs": "max_extra_units * workers['6']", "description": "Max extra units for month 6"}, {"name": "final_storage", "expr_lhs": "stored_units['6']", "sense": "==", "expr_rhs": "0.0", "description": "Final storage must be zero"}]}, "eval": {"ground_truth_raw": "10000", "ground_truth_value": 10000.0, "obj_value": -5700.0, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_25", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": ["unroll_free_index_constraints"], "repairs": ["unroll_free_index_constraints"]}, "solver": {"status_name": "OPTIMAL", "obj_value": 10755.0}, "ir_dict": {"meta": {"problem_id": "industryOR_25", "source": "IndustryOR", "description": "A company has three types of products, I, II, and III. The contract orders for each quarter of the next year are shown in Table 1-23. At the beginning of the first quarter, there is no inventory, and it is required to have 150 units of each product in inventory at the end of the fourth quarter. It is known that the company has 15,000 hours of production time per quarter, and it takes 2 hours, 4 hours, and 3 hours to produce one unit of products I, II, and III, respectively. Due to the replacement of production equipment, product I cannot be produced in the second quarter. It is specified that if the products cannot be delivered on time, a compensation of $20 per unit per quarter is required for products I and II, and $10 for product III. If the produced products are not delivered in the same quarter, a storage fee of $5 per unit per quarter is incurred. How should the company arrange production to minimize the total compensation and storage fee?\n\nTable 1-23\n\\begin{tabular}{c|c|c|c|c}\n\\hline \\multirow{2}{*}{Product} & \\multicolumn{4}{|c}{Contract Orders for Each Quarter} \\\\\n\\cline { 2 - 5 } & 1 & 2 & 3 & 4 \\\\\n\\hline I & 1500 & 1000 & 2000 & 1200 \\\\\nII & 1500 & 1500 & 1200 & 1500 \\\\\nIII & 1000 & 2000 & 1500 & 2500 \\\\\n\\hline\n\\end{tabular}", "sense": "min", "version": "v1"}, "sets": [{"name": "Products", "elements": ["I", "II", "III"], "description": "Types of products"}, {"name": "Quarters", "elements": ["1", "2", "3", "4"], "description": "Quarters of the year"}], "params": [{"name": "contract_orders", "indices": ["Products", "Quarters"], "values": {"I": {"1": 1500, "2": 1000, "3": 2000, "4": 1200}, "II": {"1": 1500, "2": 1500, "3": 1200, "4": 1500}, "III": {"1": 1000, "2": 2000, "3": 1500, "4": 2500}}, "description": "Contract orders for each product and quarter"}, {"name": "production_time", "indices": ["Products"], "values": {"I": 2, "II": 4, "III": 3}, "description": "Production time required per unit of each product"}, {"name": "compensation_cost", "indices": ["Products"], "values": {"I": 20, "II": 20, "III": 10}, "description": "Compensation cost per unit per quarter for late delivery"}, {"name": "storage_cost", "indices": [], "values": 5, "description": "Storage cost per unit per quarter"}, {"name": "production_hours", "indices": [], "values": 15000, "description": "Total production hours available per quarter"}], "vars": [{"name": "produce", "indices": ["Products", "Quarters"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units of product produced in each quarter"}, {"name": "inventory", "indices": ["Products", "Quarters"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units of product in inventory at the end of each quarter"}, {"name": "compensation", "indices": ["Products", "Quarters"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units of product not delivered on time"}], "objective": {"name": "total_cost", "sense": "min", "expr": "quicksum(compensation_cost[p] * compensation[p][q] for p in Products for q in Quarters) + quicksum(storage_cost * inventory[p][q] for p in Products for q in Quarters)", "description": "Minimize total compensation and storage costs"}, "constraints": [{"name": "inventory_balance_1", "expr_lhs": "inventory[p]['1']", "sense": "==", "expr_rhs": "produce[p]['1'] - contract_orders[p]['1'] + compensation[p]['1']", "description": "Inventory balance for quarter 1"}, {"name": "inventory_balance_2", "expr_lhs": "inventory[p]['2']", "sense": "==", "expr_rhs": "inventory[p]['1'] + produce[p]['2'] - contract_orders[p]['2'] + compensation[p]['2']", "description": "Inventory balance for quarter 2"}, {"name": "inventory_balance_3", "expr_lhs": "inventory[p]['3']", "sense": "==", "expr_rhs": "inventory[p]['2'] + produce[p]['3'] - contract_orders[p]['3'] + compensation[p]['3']", "description": "Inventory balance for quarter 3"}, {"name": "inventory_balance_4", "expr_lhs": "inventory[p]['4']", "sense": "==", "expr_rhs": "inventory[p]['3'] + produce[p]['4'] - contract_orders[p]['4'] + compensation[p]['4']", "description": "Inventory balance for quarter 4"}, {"name": "end_inventory_requirement", "expr_lhs": "inventory[p]['4']", "sense": "==", "expr_rhs": "150", "description": "End of year inventory requirement for each product"}, {"name": "production_capacity_1", "expr_lhs": "quicksum(production_time[p] * produce[p]['1'] for p in Products)", "sense": "<=", "expr_rhs": "production_hours", "description": "Production capacity constraint for quarter 1"}, {"name": "production_capacity_2", "expr_lhs": "quicksum(production_time[p] * produce[p]['2'] for p in Products)", "sense": "<=", "expr_rhs": "production_hours", "description": "Production capacity constraint for quarter 2"}, {"name": "production_capacity_3", "expr_lhs": "quicksum(production_time[p] * produce[p]['3'] for p in Products)", "sense": "<=", "expr_rhs": "production_hours", "description": "Production capacity constraint for quarter 3"}, {"name": "production_capacity_4", "expr_lhs": "quicksum(production_time[p] * produce[p]['4'] for p in Products)", "sense": "<=", "expr_rhs": "production_hours", "description": "Production capacity constraint for quarter 4"}, {"name": "no_production_I_q2", "expr_lhs": "produce['I']['2']", "sense": "==", "expr_rhs": "0", "description": "No production of product I in quarter 2"}]}, "eval": {"ground_truth_raw": "8505", "ground_truth_value": 8505.0, "obj_value": 10755.0, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_26", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 0.032435897435897434}, "ir_dict": {"meta": {"problem_id": "industryOR_26", "source": "IndustryOR", "description": "Suppose an animal needs at least $700 \\mathrm{~g}$ of protein, $30 \\mathrm{~g}$ of minerals, and $100 \\mathrm{mg}$ of vitamins per day. There are 5 types of feed to choose from, and the contents of each nutrient per gram and the unit price of each feed are shown in Table 1-5. Try to establish a linear programming model that not only meets the animal's growth needs but also minimizes the cost of selecting feed.\n\nTable 1-6\n\\begin{tabular}{|c|c|c|c|c||c|c|c|c|c|}\n\\hline Feed & \\begin{tabular}{c} \nProtein \\\\\n$/ \\mathrm{g}$\n\\end{tabular} & \\begin{tabular}{c} \nMinerals \\\\\n$/ \\mathrm{g}$\n\\end{tabular} & \\begin{tabular}{c} \nVitamins \\\\\n$/ \\mathrm{mg}$\n\\end{tabular} & \\begin{tabular}{c} \nPrice \\\\\n$/$ (yuan $/ \\mathrm{kg})$\n\\end{tabular} & Feed & \\begin{tabular}{c} \nProtein \\\\\n$/ \\mathrm{g}$\n\\end{tabular} & \\begin{tabular}{c} \nMinerals \\\\\n$/ \\mathrm{g}$\n\\end{tabular} & \\begin{tabular}{c} \nVitamins \\\\\n$/ \\mathrm{mg}$\n\\end{tabular} & \\begin{tabular}{c} \nPrice \\\\\n$/($ yuan $/ \\mathrm{kg})$\n\\end{tabular} \\\\\n\\hline 1 & 3 & 1 & 0.5 & 0.2 & 4 & 6 & 2 & 2 & 0.3 \\\\\n\\hline 2 & 2 & 0.5 & 1 & 0.7 & 5 & 18 & 0.5 & 0.8 & 0.8 \\\\\n\\hline 3 & 1 & 0.2 & 0.2 & 0.4 & & & & & \\\\\n\\hline\n\\end{tabular}", "sense": "min", "version": "v1"}, "sets": [{"name": "F", "elements": ["1", "2", "3", "4", "5"], "description": "Types of feed"}], "params": [{"name": "protein", "indices": ["F"], "values": {"1": 3.0, "2": 2.0, "3": 1.0, "4": 6.0, "5": 18.0}, "description": "Protein content per gram of feed"}, {"name": "minerals", "indices": ["F"], "values": {"1": 1.0, "2": 0.5, "3": 0.2, "4": 2.0, "5": 0.5}, "description": "Minerals content per gram of feed"}, {"name": "vitamins", "indices": ["F"], "values": {"1": 0.5, "2": 1.0, "3": 0.2, "4": 2.0, "5": 0.8}, "description": "Vitamins content per mg of feed"}, {"name": "price", "indices": ["F"], "values": {"1": 0.2, "2": 0.7, "3": 0.4, "4": 0.3, "5": 0.8}, "description": "Price per kg of feed"}], "vars": [{"name": "x", "indices": ["F"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Amount of feed in kg"}], "objective": {"name": "min_cost", "sense": "min", "expr": "quicksum(price[f] * x[f] for f in F)", "description": "Minimize the total cost of feed"}, "constraints": [{"name": "protein_requirement", "expr_lhs": "quicksum(protein[f] * x[f] * 1000 for f in F)", "sense": ">=", "expr_rhs": "700.0", "description": "Protein requirement in grams"}, {"name": "minerals_requirement", "expr_lhs": "quicksum(minerals[f] * x[f] * 1000 for f in F)", "sense": ">=", "expr_rhs": "30.0", "description": "Minerals requirement in grams"}, {"name": "vitamins_requirement", "expr_lhs": "quicksum(vitamins[f] * x[f] * 1000 for f in F)", "sense": ">=", "expr_rhs": "100.0", "description": "Vitamins requirement in mg"}]}, "eval": {"ground_truth_raw": "32.436", "ground_truth_value": 32.436, "obj_value": 0.032435897435897434, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_27", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": -1087.75}, "ir_dict": {"meta": {"problem_id": "industryOR_27", "source": "IndustryOR", "description": "A factory produces three types of products: I, II, and III. Each product requires two processing steps, A and B. The factory has two types of equipment for step A, represented by A1 and A2, and three types of equipment for step B, represented by B1, B2, and B3. Product I can be processed on any type of A equipment and any type of B equipment. Product II can be processed on any type of A equipment, but for step B, it can only be processed on B1 equipment. Product III can only be processed on A2 and B2 equipment. The unit processing time, raw material cost, selling price, equipment available time, and equipment cost at full load for each type of equipment are shown in Table 1-18. Determine the optimal production plan to maximize the profit for the factory.\n\nTable 1-18\n\\begin{tabular}{c|c|c|c|c|c}\n\\hline \\multirow{2}{*}{ Equipment } & \\multicolumn{3}{|c|}{ Product } & \\multirow{2}{*}{ Equipment Available Time } & \\multirow{2}{*}{\\begin{tabular}{c} \nEquipment Cost at \\\\\nFull Load (CNY)\n\\end{tabular}} \\\\\n\\cline { 2 - 4 } & I & II & III & 6000 & 300 \\\\\n$A_1$ & 5 & 10 & & 10000 & 321 \\\\\n$A_2$ & 7 & 9 & 12 & 4000 & 250 \\\\\n$B_1$ & 6 & 8 & & 7000 & 783 \\\\\n$B_2$ & 4 & & 11 & 4000 & 200 \\\\\n$B_3$ & 7 & & & & \\\\\n\\hline Raw Material Cost (CNY / unit) & 0.25 & 0.35 & 0.50 & & \\\\\nUnit Price (CNY / unit) & 1.25 & 2.00 & 2.80 & & \\\\\n\\hline\n\\end{tabular}", "sense": "max", "version": "v1"}, "sets": [{"name": "Products", "elements": ["I", "II", "III"], "description": "Types of products"}, {"name": "EquipmentA", "elements": ["A1", "A2"], "description": "Types of equipment for step A"}, {"name": "EquipmentB", "elements": ["B1", "B2", "B3"], "description": "Types of equipment for step B"}], "params": [{"name": "processing_time_A", "indices": ["EquipmentA", "Products"], "values": {"A1": {"I": 5, "II": 10, "III": 0}, "A2": {"I": 7, "II": 9, "III": 12}}, "description": "Processing time for step A"}, {"name": "processing_time_B", "indices": ["EquipmentB", "Products"], "values": {"B1": {"I": 6, "II": 8, "III": 0}, "B2": {"I": 4, "II": 0, "III": 11}, "B3": {"I": 7, "II": 0, "III": 0}}, "description": "Processing time for step B"}, {"name": "equipment_available_time", "indices": ["EquipmentA", "EquipmentB"], "values": {"A1": 10000, "A2": 4000, "B1": 7000, "B2": 4000, "B3": 6000}, "description": "Available time for each equipment"}, {"name": "equipment_cost", "indices": ["EquipmentA", "EquipmentB"], "values": {"A1": 321, "A2": 250, "B1": 783, "B2": 200, "B3": 300}, "description": "Cost at full load for each equipment"}, {"name": "raw_material_cost", "indices": ["Products"], "values": {"I": 0.25, "II": 0.35, "III": 0.5}, "description": "Raw material cost per unit"}, {"name": "unit_price", "indices": ["Products"], "values": {"I": 1.25, "II": 2.0, "III": 2.8}, "description": "Selling price per unit"}], "vars": [{"name": "x", "indices": ["Products"], "vartype": "integer", "lb": 0, "ub": null, "description": "Production quantity for each product"}], "objective": {"name": "profit", "sense": "max", "expr": "quicksum((unit_price[p] - raw_material_cost[p]) * x[p] for p in Products) - quicksum(equipment_cost[a] for a in EquipmentA) - quicksum(equipment_cost[b] for b in EquipmentB)", "description": "Maximize profit"}, "constraints": [{"name": "A1_capacity", "expr_lhs": "quicksum(processing_time_A['A1'][p] * x[p] for p in Products)", "sense": "<=", "expr_rhs": "equipment_available_time['A1']", "description": "Capacity constraint for A1"}, {"name": "A2_capacity", "expr_lhs": "quicksum(processing_time_A['A2'][p] * x[p] for p in Products)", "sense": "<=", "expr_rhs": "equipment_available_time['A2']", "description": "Capacity constraint for A2"}, {"name": "B1_capacity", "expr_lhs": "quicksum(processing_time_B['B1'][p] * x[p] for p in Products)", "sense": "<=", "expr_rhs": "equipment_available_time['B1']", "description": "Capacity constraint for B1"}, {"name": "B2_capacity", "expr_lhs": "quicksum(processing_time_B['B2'][p] * x[p] for p in Products)", "sense": "<=", "expr_rhs": "equipment_available_time['B2']", "description": "Capacity constraint for B2"}, {"name": "B3_capacity", "expr_lhs": "quicksum(processing_time_B['B3'][p] * x[p] for p in Products)", "sense": "<=", "expr_rhs": "equipment_available_time['B3']", "description": "Capacity constraint for B3"}]}, "eval": {"ground_truth_raw": "1146.6", "ground_truth_value": 1146.6, "obj_value": -1087.75, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_28", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 9350.0}, "ir_dict": {"meta": {"problem_id": "industryOR_28", "source": "IndustryOR", "description": "A product consists of three components, which are produced by four workshops. The total number of production hours available for each workshop is limited. Table 1.4 shows the productivity of the three components. The objective is to determine how many hours should be allocated to each component in each workshop in order to maximize the number of completed products. Represent this problem as a linear programming problem.\n\nTable 1.4\n\n| Workshop | Production Capacity <br> (hours) | Productivity (units/hour) |  |  |\n| :---: | :---: | :---: | :---: | :---: |\n|  |  | Component 1 | Component 2 | Component 3 |\n| A | 100 | 10 | 15 | 5 |\n| B | 150 | 15 | 10 | 5 |\n| C | 80 | 20 | 5 | 10 |\n| D | 200 | 10 | 15 | 20 |", "sense": "max", "version": "v1"}, "sets": [{"name": "Workshops", "elements": ["A", "B", "C", "D"], "description": "Set of workshops"}, {"name": "Components", "elements": ["1", "2", "3"], "description": "Set of components"}], "params": [{"name": "capacity", "indices": ["Workshops"], "values": {"A": 100.0, "B": 150.0, "C": 80.0, "D": 200.0}, "description": "Production capacity in hours for each workshop"}, {"name": "productivity", "indices": ["Workshops", "Components"], "values": {"A": {"1": 10.0, "2": 15.0, "3": 5.0}, "B": {"1": 15.0, "2": 10.0, "3": 5.0}, "C": {"1": 20.0, "2": 5.0, "3": 10.0}, "D": {"1": 10.0, "2": 15.0, "3": 20.0}}, "description": "Productivity in units per hour for each component in each workshop"}], "vars": [{"name": "hours", "indices": ["Workshops", "Components"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Hours allocated to each component in each workshop"}], "objective": {"name": "maximize_products", "sense": "max", "expr": "quicksum(productivity[w][c] * hours[w][c] for w in Workshops for c in Components)", "description": "Maximize the total number of completed products"}, "constraints": [{"name": "capacity_constraint_A", "expr_lhs": "quicksum(hours['A'][c] for c in Components)", "sense": "<=", "expr_rhs": "capacity['A']", "description": "Capacity constraint for workshop A"}, {"name": "capacity_constraint_B", "expr_lhs": "quicksum(hours['B'][c] for c in Components)", "sense": "<=", "expr_rhs": "capacity['B']", "description": "Capacity constraint for workshop B"}, {"name": "capacity_constraint_C", "expr_lhs": "quicksum(hours['C'][c] for c in Components)", "sense": "<=", "expr_rhs": "capacity['C']", "description": "Capacity constraint for workshop C"}, {"name": "capacity_constraint_D", "expr_lhs": "quicksum(hours['D'][c] for c in Components)", "sense": "<=", "expr_rhs": "capacity['D']", "description": "Capacity constraint for workshop D"}]}, "eval": {"ground_truth_raw": "2924", "ground_truth_value": 2924.0, "obj_value": 9350.0, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_29", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "INF_OR_UNBD", "obj_value": null}, "ir_dict": {"meta": {"problem_id": "industryOR_29", "source": "IndustryOR", "description": "For manufacturing companies, it is important to develop appropriate production plans and human resource management strategies to reduce operating costs, inventory costs, stockout costs, and labor costs. In particular, for products with high demand fluctuations, companies need to accurately forecast demand and develop corresponding production plans. A company produces a folding table, with a raw material cost of 90 yuan per unit and 5 labor hours. The unit price of the product is 300 yuan. At the beginning of January, the company has 1000 workers and holds 15,000 units of inventory. The normal wage for workers is 30 yuan per hour, and the normal working hours per worker per day is 8 hours. Overtime hours are paid at an hourly rate of 40 yuan. The number of working days per month is calculated as 20 days. Assuming the company has sufficient available production machines and its production capacity is not limited by machine hours. The overtime hours per worker per month do not exceed 20 hours. Holding inventory incurs corresponding inventory costs. If there is a stockout due to insufficient capacity, there will be certain stockout costs. In addition, the company can make up for the shortage through outsourcing. The outsourcing cost per unit, monthly inventory cost, and monthly stockout cost are 200 yuan, 15 yuan, and 35 yuan, respectively. The company's employees are all temporary workers, and the company can flexibly decide the number of employees to hire and dismiss each month. The cost of hiring and dismissing a single employee is 5000 yuan and 8000 yuan, respectively. Assuming the company has used existing forecasting models to predict the demand from month 1 to month 6, as shown in Table 4.1.\n\nTable 4.1: Demand Forecast\n\n| Month | 1 | 2 | 3 | 4 | 5 | 6 |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Demand Forecast | 20000 | 40000 | 42000 | 35000 | 19000 | 18500 |\n\nPlease develop a production plan, worker schedule, and plan for hiring and dismissing employees for the company to maximize its total net profit over 6 months, while ensuring that the company holds at least 10,000 units of product by the end of June.", "sense": "max", "version": "v1"}, "sets": [{"name": "Months", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Months from January to June"}], "params": [{"name": "demand", "indices": ["Months"], "values": {"1": 20000, "2": 40000, "3": 42000, "4": 35000, "5": 19000, "6": 18500}, "description": "Demand forecast for each month"}, {"name": "raw_material_cost", "indices": [], "values": 90, "description": "Raw material cost per unit"}, {"name": "labor_hours_per_unit", "indices": [], "values": 5, "description": "Labor hours required per unit"}, {"name": "unit_price", "indices": [], "values": 300, "description": "Selling price per unit"}, {"name": "normal_wage", "indices": [], "values": 30, "description": "Normal wage per hour"}, {"name": "overtime_wage", "indices": [], "values": 40, "description": "Overtime wage per hour"}, {"name": "normal_hours_per_day", "indices": [], "values": 8, "description": "Normal working hours per day"}, {"name": "working_days_per_month", "indices": [], "values": 20, "description": "Number of working days per month"}, {"name": "overtime_hours_limit", "indices": [], "values": 20, "description": "Maximum overtime hours per worker per month"}, {"name": "inventory_cost", "indices": [], "values": 15, "description": "Monthly inventory holding cost per unit"}, {"name": "stockout_cost", "indices": [], "values": 35, "description": "Monthly stockout cost per unit"}, {"name": "outsourcing_cost", "indices": [], "values": 200, "description": "Outsourcing cost per unit"}, {"name": "hiring_cost", "indices": [], "values": 5000, "description": "Cost of hiring a single employee"}, {"name": "dismissal_cost", "indices": [], "values": 8000, "description": "Cost of dismissing a single employee"}, {"name": "initial_workers", "indices": [], "values": 1000, "description": "Initial number of workers"}, {"name": "initial_inventory", "indices": [], "values": 15000, "description": "Initial inventory units"}], "vars": [{"name": "production", "indices": ["Months"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units produced each month"}, {"name": "inventory", "indices": ["Months"], "vartype": "integer", "lb": 0, "ub": null, "description": "Inventory at the end of each month"}, {"name": "stockout", "indices": ["Months"], "vartype": "integer", "lb": 0, "ub": null, "description": "Stockout units each month"}, {"name": "outsourcing", "indices": ["Months"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units outsourced each month"}, {"name": "workers", "indices": ["Months"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of workers each month"}, {"name": "hired", "indices": ["Months"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of workers hired each month"}, {"name": "dismissed", "indices": ["Months"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of workers dismissed each month"}, {"name": "overtime_hours", "indices": ["Months"], "vartype": "continuous", "lb": 0, "ub": null, "description": "Overtime hours worked each month"}], "objective": {"name": "total_net_profit", "sense": "max", "expr": "quicksum((unit_price * (production[m] + outsourcing[m]) - raw_material_cost * production[m] - normal_wage * normal_hours_per_day * working_days_per_month * workers[m] - overtime_wage * overtime_hours[m] - inventory_cost * inventory[m] - stockout_cost * stockout[m] - outsourcing_cost * outsourcing[m] - hiring_cost * hired[m] - dismissal_cost * dismissed[m]) for m in Months)", "description": "Maximize total net profit over 6 months"}, "constraints": [{"name": "inventory_balance_1", "expr_lhs": "initial_inventory + production['1'] + outsourcing['1'] - demand['1'] - stockout['1']", "sense": "==", "expr_rhs": "inventory['1']", "description": "Inventory balance for month 1"}, {"name": "inventory_balance_2", "expr_lhs": "inventory['1'] + production['2'] + outsourcing['2'] - demand['2'] - stockout['2']", "sense": "==", "expr_rhs": "inventory['2']", "description": "Inventory balance for month 2"}, {"name": "inventory_balance_3", "expr_lhs": "inventory['2'] + production['3'] + outsourcing['3'] - demand['3'] - stockout['3']", "sense": "==", "expr_rhs": "inventory['3']", "description": "Inventory balance for month 3"}, {"name": "inventory_balance_4", "expr_lhs": "inventory['3'] + production['4'] + outsourcing['4'] - demand['4'] - stockout['4']", "sense": "==", "expr_rhs": "inventory['4']", "description": "Inventory balance for month 4"}, {"name": "inventory_balance_5", "expr_lhs": "inventory['4'] + production['5'] + outsourcing['5'] - demand['5'] - stockout['5']", "sense": "==", "expr_rhs": "inventory['5']", "description": "Inventory balance for month 5"}, {"name": "inventory_balance_6", "expr_lhs": "inventory['5'] + production['6'] + outsourcing['6'] - demand['6'] - stockout['6']", "sense": "==", "expr_rhs": "inventory['6']", "description": "Inventory balance for month 6"}, {"name": "end_inventory_requirement", "expr_lhs": "inventory['6']", "sense": ">=", "expr_rhs": "10000", "description": "Ensure at least 10,000 units of inventory by end of June"}, {"name": "worker_balance_1", "expr_lhs": "initial_workers + hired['1'] - dismissed['1']", "sense": "==", "expr_rhs": "workers['1']", "description": "Worker balance for month 1"}, {"name": "worker_balance_2", "expr_lhs": "workers['1'] + hired['2'] - dismissed['2']", "sense": "==", "expr_rhs": "workers['2']", "description": "Worker balance for month 2"}, {"name": "worker_balance_3", "expr_lhs": "workers['2'] + hired['3'] - dismissed['3']", "sense": "==", "expr_rhs": "workers['3']", "description": "Worker balance for month 3"}, {"name": "worker_balance_4", "expr_lhs": "workers['3'] + hired['4'] - dismissed['4']", "sense": "==", "expr_rhs": "workers['4']", "description": "Worker balance for month 4"}, {"name": "worker_balance_5", "expr_lhs": "workers['4'] + hired['5'] - dismissed['5']", "sense": "==", "expr_rhs": "workers['5']", "description": "Worker balance for month 5"}, {"name": "worker_balance_6", "expr_lhs": "workers['5'] + hired['6'] - dismissed['6']", "sense": "==", "expr_rhs": "workers['6']", "description": "Worker balance for month 6"}, {"name": "production_capacity_1", "expr_lhs": "production['1']", "sense": "<=", "expr_rhs": "workers['1'] * (normal_hours_per_day * working_days_per_month + overtime_hours['1']) / labor_hours_per_unit", "description": "Production capacity constraint for month 1"}, {"name": "production_capacity_2", "expr_lhs": "production['2']", "sense": "<=", "expr_rhs": "workers['2'] * (normal_hours_per_day * working_days_per_month + overtime_hours['2']) / labor_hours_per_unit", "description": "Production capacity constraint for month 2"}, {"name": "production_capacity_3", "expr_lhs": "production['3']", "sense": "<=", "expr_rhs": "workers['3'] * (normal_hours_per_day * working_days_per_month + overtime_hours['3']) / labor_hours_per_unit", "description": "Production capacity constraint for month 3"}, {"name": "production_capacity_4", "expr_lhs": "production['4']", "sense": "<=", "expr_rhs": "workers['4'] * (normal_hours_per_day * working_days_per_month + overtime_hours['4']) / labor_hours_per_unit", "description": "Production capacity constraint for month 4"}, {"name": "production_capacity_5", "expr_lhs": "production['5']", "sense": "<=", "expr_rhs": "workers['5'] * (normal_hours_per_day * working_days_per_month + overtime_hours['5']) / labor_hours_per_unit", "description": "Production capacity constraint for month 5"}, {"name": "production_capacity_6", "expr_lhs": "production['6']", "sense": "<=", "expr_rhs": "workers['6'] * (normal_hours_per_day * working_days_per_month + overtime_hours['6']) / labor_hours_per_unit", "description": "Production capacity constraint for month 6"}, {"name": "overtime_limit_1", "expr_lhs": "overtime_hours['1']", "sense": "<=", "expr_rhs": "overtime_hours_limit * workers['1']", "description": "Overtime limit for month 1"}, {"name": "overtime_limit_2", "expr_lhs": "overtime_hours['2']", "sense": "<=", "expr_rhs": "overtime_hours_limit * workers['2']", "description": "Overtime limit for month 2"}, {"name": "overtime_limit_3", "expr_lhs": "overtime_hours['3']", "sense": "<=", "expr_rhs": "overtime_hours_limit * workers['3']", "description": "Overtime limit for month 3"}, {"name": "overtime_limit_4", "expr_lhs": "overtime_hours['4']", "sense": "<=", "expr_rhs": "overtime_hours_limit * workers['4']", "description": "Overtime limit for month 4"}, {"name": "overtime_limit_5", "expr_lhs": "overtime_hours['5']", "sense": "<=", "expr_rhs": "overtime_hours_limit * workers['5']", "description": "Overtime limit for month 5"}, {"name": "overtime_limit_6", "expr_lhs": "overtime_hours['6']", "sense": "<=", "expr_rhs": "overtime_hours_limit * workers['6']", "description": "Overtime limit for month 6"}]}, "eval": {"ground_truth_raw": "9337440", "ground_truth_value": 9337440.0, "obj_value": null, "status": "INF_OR_UNBD", "correct": 0}}
{"meta": {"problem_id": "industryOR_30", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "json_extract", "error": "JSONDecodeError: Expecting value: line 1 column 1 (char 0)", "verifier": {"ok": false, "issues": [], "repairs": []}, "solver": {"status_name": "NONE", "obj_value": null}, "ir_dict": {"meta": {"source": "IndustryOR", "problem_id": "industryOR_30", "description": "The Vehicle Routing Problem (VRP) was first proposed by Dantzig in 1959 (Dantzig and Ramser 1959). It is a very classic combinatorial optimization problem. The basic VRP can usually be described as follows: in a certain area, there are a certain number of customers and a distribution center or warehouse. The customers are generally distributed in different locations, and each customer has a certain amount of goods delivery demand. The distribution center or warehouse needs to dispatch a fleet of vehicles and design a suitable delivery plan to fulfill all customer's goods delivery demands. The objective of VRP is to maximize efficiency while meeting all customer demands. The measurement of efficiency is usually presented in the form of an objective function. The objective function varies with the company's requirements, and common objective functions include minimizing the total distance traveled by vehicles, minimizing the total delivery time, and minimizing the number of vehicles used, etc. In addition to meeting customer delivery demands, VRP generally needs to consider various other constraints, resulting in various variants. For example, if the vehicle's load cannot exceed its maximum capacity (capacity constraint), the problem becomes the Capacitated Vehicle Routing Problem (CVRP). If the delivery demand of each customer must be delivered within a specific time window, the problem becomes the Vehicle Routing Problem with Time Windows (VRPTW).\n\nThe Vehicle Routing Problem with Time Windows (VRPTW) is a classic problem developed from VRP. There are many applications of VRPTW in reality, and each customer point generally has a service time window. For example, some logistics centers need to deliver packages during low-traffic hours, some large supermarkets need to restock during non-business hours, and real-time delivery methods such as food delivery require specific delivery time windows. Time windows can be classified as hard time windows and soft time windows. Hard Time Windows (HTW) means that vehicles must arrive at or before the time window, and cannot delay their arrival. If they arrive early, they must wait until the time window starts to provide service, such as restocking supermarkets and delivering goods from logistics centers, etc. Soft Time Windows (STW) means that vehicles are not required to arrive within the original hard time window, but they should try to arrive within the hard time window. If the vehicle arrives early, a penalty value will be deducted, and if it arrives late, a certain penalty value will be imposed, such as food delivery, school bus pick-up and drop-off, industrial distribution, etc.\n\nThe Vehicle Routing Problem with Hard Time Windows (VRPHTW) can be described as follows: there are a certain number of customer points and a distribution center in the region. Vehicles need to depart from the distribution center and return to the distribution center. The route should be continuous, and each customer should be served by one and only one vehicle. The vehicles also have a capacity. Each customer has a specific service time window and can only be served within the time window. Vehicles can arrive at the customer point ahead of time and wait for the time window to open, then provide service to the customer. They can also arrive at the customer point within the time window to provide service. Vehicles can only start serving customers within the time window, and the service time is known. The distribution center needs to arrange a reasonable delivery plan to both complete the delivery tasks and minimize travel costs. VRPHTW, like VRP, mainly emphasizes the travel costs on the routes because delays are not allowed. Now, please model the VRPHTW in operations research.\n\n### Example\nr101.txt = r\\\"\"\"\n    0          35      35           0       0         230           0\n    1          41      49          10     161         171          10\n    2          35      17           7      50          60          "}}, "eval": {"ground_truth_raw": "1644.63", "ground_truth_value": 1644.63, "obj_value": null, "status": "NONE", "correct": 0}}
{"meta": {"problem_id": "industryOR_31", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 0.0}, "ir_dict": {"meta": {"problem_id": "industryOR_31", "source": "IndustryOR", "description": "As one of the main arteries of urban transportation, the city subway carries a huge passenger flow and its operation and management are very complex. Among them, crew scheduling is one of the key links in subway operation management and also the starting point and difficulty of crew management. The subway transportation volume is large, with complex and changing routes, and frequent operation intervals. Crew drivers face huge, continuous, and high-intensity transportation tasks. It is important to arrange the driver's shift and duty mode reasonably and achieve the optimal allocation of personnel to ensure the efficient and stable operation of the subway. Due to the increasing complexity of the subway operation network, traditional manual scheduling methods can no longer meet the high standard operation requirements. Automated and intelligent crew scheduling has become an inevitable trend.\n\nThe general process of crew scheduling for subway operating companies is as follows: export train operation section and time information tables based on the current operation chart, manually divide the crew duty roster based on these information tables, compile the crew scheduling master table based on the duty roster, and finally allocate the crew groups based on the scheduling master table to form the final scheduling table. The entire process relies on manual compilation and mainly has the following three major problems:\n\n1. Low scheduling efficiency: Crew scheduling business rules are complex, and the workload is large. The efficiency of manual compilation is very low, requiring at least one week. The manpower and time costs are high.\n\n2. Difficulty in adjustment: When encountering unexpected situations such as train failures and temporary leave of crew members, it is difficult to quickly adjust the scheduling plan based on manual methods, affecting the efficiency of operation management.\n\n3. Uneven task assignment: Manual scheduling has subjective limitations and strong dependence on human experience. If the scheduling is unreasonable, it may lead to uneven task assignment, unfair scheduling, and low crew satisfaction.\n\nThis subway line includes 40 platforms, among which A, M, and Z platforms are available for driver transfers and handovers. Please consider 200 driving tasks and their attributes such as time, location, and mileage, and consider classic constraints in crew scheduling scenarios, such as maximum continuous driving time constraint, mileage limit constraint, attendance location constraint, etc. Compare different mixed integer modeling methods to minimize the number of drivers as the goal and output the optimal task chain combination (i.e. the allocation and connection relationship of all tasks) for all tasks.\n\n### Example\nMileage Information Table.csv = \\\"\"\"\nDeparture Station,Arrival Station,Mileage\nA,M,17.1\nZ,M,26.4\n\\\"\"\"\n\nTask Information Table.csv = \\\"\"\"\nTrain Number,Train ID,Pickup Time,Pickup Location,Drop-off Time,Drop-off Location\n331,M16,10:03:11,M,10:57:43,Z\n1,L06,10:03:43,Z,10:58:32,M\n163,N23,10:04:10,A,10:39:11,M\n332,N27,10:04:32,M,10:40:10,A\n333,N20,10:09:11,M,11:03:43,Z\n2,L07,10:09:43,Z,11:04:32,M\n164,L11,10:10:10,A,10:45:11,M\n334,L01,10:10:32,M,10:46:10,A\n335,M17,10:15:11,M,11:09:43,Z\n3,M13,10:15:43,Z,11:10:32,M\n165,N24,10:16:10,A,10:51:11,M\n336,N28,10:16:32,M,10:52:10,A\n337,N21,10:21:11,M,11:15:43,Z\n4,L08,10:21:43,Z,11:16:32,M\n166,N25,10:22:10,A,10:57:11,M\n338,L02,10:22:32,M,10:58:10,A\n339,M18,10:27:11,M,11:21:43,Z\n5,M14,10:27:43,Z,11:22:32,M\n167,N26,10:28:10,A,11:03:11,M\n340,L03,10:28:32,M,11:04:10,A\n341,N22,10:33:11,M,11:27:43,Z\n6,L09,10:33:43,Z,11:28:32,M\n168,L12,10:34:10,A,11:09:11,M\n342,N29,10:34:32,M,11:10:10,A\n343,N23,10:39:11,M,11:33:43,Z\n7,M15,10:39:43,Z,11:34:32,M\n169,N27,10:40:10,A,11:15:11,M\n344,L04,10:40:32,M,11:16:10,A\n345,L11,10:45:11,M,11:39:43,Z\n8,N19,10:45:43,Z,11:40:32,M\n170,L01,10:46:10,A,11:21:11,M\n346,L05,10:46:32,M,11:22:10,A\n347,N24,10:51:11,M,11:45:43,Z\n9,L10,10:51:43,Z,11:46:32,M\n171,N", "sense": "min", "version": "v1"}, "sets": [{"name": "Tasks", "elements": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100", "101", "102", "103", "104", "105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", "130", "131", "132", "133", "134", "135", "136", "137", "138", "139", "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", "190", "191", "192", "193", "194", "195", "196", "197", "198", "199", "200"], "description": "Set of all driving tasks."}], "params": [{"name": "mileage", "indices": ["Tasks"], "values": {"1": 17.1, "2": 26.4, "3": 17.1, "4": 26.4, "5": 17.1, "6": 26.4, "7": 17.1, "8": 26.4, "9": 17.1, "10": 26.4, "11": 17.1, "12": 26.4, "13": 17.1, "14": 26.4, "15": 17.1, "16": 26.4, "17": 17.1, "18": 26.4, "19": 17.1, "20": 26.4, "21": 17.1, "22": 26.4, "23": 17.1, "24": 26.4, "25": 17.1, "26": 26.4, "27": 17.1, "28": 26.4, "29": 17.1, "30": 26.4, "31": 17.1, "32": 26.4, "33": 17.1, "34": 26.4, "35": 17.1, "36": 26.4, "37": 17.1, "38": 26.4, "39": 17.1, "40": 26.4, "41": 17.1, "42": 26.4, "43": 17.1, "44": 26.4, "45": 17.1, "46": 26.4, "47": 17.1, "48": 26.4, "49": 17.1, "50": 26.4, "51": 17.1, "52": 26.4, "53": 17.1, "54": 26.4, "55": 17.1, "56": 26.4, "57": 17.1, "58": 26.4, "59": 17.1, "60": 26.4, "61": 17.1, "62": 26.4, "63": 17.1, "64": 26.4, "65": 17.1, "66": 26.4, "67": 17.1, "68": 26.4, "69": 17.1, "70": 26.4, "71": 17.1, "72": 26.4, "73": 17.1, "74": 26.4, "75": 17.1, "76": 26.4, "77": 17.1, "78": 26.4, "79": 17.1, "80": 26.4, "81": 17.1, "82": 26.4, "83": 17.1, "84": 26.4, "85": 17.1, "86": 26.4, "87": 17.1, "88": 26.4, "89": 17.1, "90": 26.4, "91": 17.1, "92": 26.4, "93": 17.1, "94": 26.4, "95": 17.1, "96": 26.4, "97": 17.1, "98": 26.4, "99": 17.1, "100": 26.4, "101": 17.1, "102": 26.4, "103": 17.1, "104": 26.4, "105": 17.1, "106": 26.4, "107": 17.1, "108": 26.4, "109": 17.1, "110": 26.4, "111": 17.1, "112": 26.4, "113": 17.1, "114": 26.4, "115": 17.1, "116": 26.4, "117": 17.1, "118": 26.4, "119": 17.1, "120": 26.4, "121": 17.1, "122": 26.4, "123": 17.1, "124": 26.4, "125": 17.1, "126": 26.4, "127": 17.1, "128": 26.4, "129": 17.1, "130": 26.4, "131": 17.1, "132": 26.4, "133": 17.1, "134": 26.4, "135": 17.1, "136": 26.4, "137": 17.1, "138": 26.4, "139": 17.1, "140": 26.4, "141": 17.1, "142": 26.4, "143": 17.1, "144": 26.4, "145": 17.1, "146": 26.4, "147": 17.1, "148": 26.4, "149": 17.1, "150": 26.4, "151": 17.1, "152": 26.4, "153": 17.1, "154": 26.4, "155": 17.1, "156": 26.4, "157": 17.1, "158": 26.4, "159": 17.1, "160": 26.4, "161": 17.1, "162": 26.4, "163": 17.1, "164": 26.4, "165": 17.1, "166": 26.4, "167": 17.1, "168": 26.4, "169": 17.1, "170": 26.4, "171": 17.1, "172": 26.4, "173": 17.1, "174": 26.4, "175": 17.1, "176": 26.4, "177": 17.1, "178": 26.4, "179": 17.1, "180": 26.4, "181": 17.1, "182": 26.4, "183": 17.1, "184": 26.4, "185": 17.1, "186": 26.4, "187": 17.1, "188": 26.4, "189": 17.1, "190": 26.4, "191": 17.1, "192": 26.4, "193": 17.1, "194": 26.4, "195": 17.1, "196": 26.4, "197": 17.1, "198": 26.4, "199": 17.1, "200": 26.4}, "description": "Mileage for each task."}], "vars": [{"name": "driver", "indices": ["Tasks"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a driver is assigned to a task."}], "objective": {"name": "min_drivers", "sense": "min", "expr": "quicksum(driver[t] for t in Tasks)", "description": "Minimize the number of drivers."}, "constraints": [{"name": "max_continuous_driving_time", "expr_lhs": "quicksum(mileage[t] * driver[t] for t in Tasks)", "sense": "<=", "expr_rhs": "8.0", "description": "Maximum continuous driving time constraint."}]}, "eval": {"ground_truth_raw": "40", "ground_truth_value": 40.0, "obj_value": 0.0, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_32", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 623.0}, "ir_dict": {"meta": {"problem_id": "industryOR_32", "source": "IndustryOR", "description": "Haus Toys can manufacture and sell toy trucks, toy planes, toy boats, and toy trains. The profit from selling one truck is $5, from one plane is $10, from one boat is $8, and from one train is $7. How many types of toys should Haus Toys manufacture to maximize profit?\n\nThere are 890 units of wood available. Manufacturing one truck requires 12 units of wood, one plane requires 20 units of wood, one boat requires 15 units of wood, and one train requires 10 units of wood.\n\nThere are 500 units of steel available. Manufacturing one plane requires 3 units of steel, one boat requires 5 units of steel, one train requires 4 units of steel, and one truck requires 6 units of steel.\n\nIf Haus Toys manufactures trucks, then they will not manufacture trains.\n\nHowever, if they manufacture boats, they will also manufacture planes.\n\nThe number of toy boats manufactured cannot exceed the number of toy trains manufactured.", "sense": "max", "version": "v1"}, "sets": [{"name": "Toys", "elements": ["truck", "plane", "boat", "train"], "description": "Types of toys"}], "params": [{"name": "profit", "indices": ["Toys"], "values": {"truck": 5.0, "plane": 10.0, "boat": 8.0, "train": 7.0}, "description": "Profit per toy"}, {"name": "wood_req", "indices": ["Toys"], "values": {"truck": 12.0, "plane": 20.0, "boat": 15.0, "train": 10.0}, "description": "Wood required per toy"}, {"name": "steel_req", "indices": ["Toys"], "values": {"truck": 6.0, "plane": 3.0, "boat": 5.0, "train": 4.0}, "description": "Steel required per toy"}], "vars": [{"name": "x", "indices": ["Toys"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of each type of toy to manufacture"}, {"name": "y_truck", "indices": [], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if trucks are manufactured, 0 otherwise"}, {"name": "y_train", "indices": [], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if trains are manufactured, 0 otherwise"}, {"name": "y_boat", "indices": [], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if boats are manufactured, 0 otherwise"}, {"name": "y_plane", "indices": [], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if planes are manufactured, 0 otherwise"}], "objective": {"name": "max_profit", "sense": "max", "expr": "quicksum(profit[toy] * x[toy] for toy in Toys)", "description": "Maximize total profit"}, "constraints": [{"name": "wood_constraint", "expr_lhs": "quicksum(wood_req[toy] * x[toy] for toy in Toys)", "sense": "<=", "expr_rhs": "890.0", "description": "Wood availability constraint"}, {"name": "steel_constraint", "expr_lhs": "quicksum(steel_req[toy] * x[toy] for toy in Toys)", "sense": "<=", "expr_rhs": "500.0", "description": "Steel availability constraint"}, {"name": "truck_train_exclusion", "expr_lhs": "y_truck + y_train", "sense": "<=", "expr_rhs": "1.0", "description": "Cannot manufacture both trucks and trains"}, {"name": "boat_plane_dependency", "expr_lhs": "y_boat", "sense": "<=", "expr_rhs": "y_plane", "description": "If boats are manufactured, planes must also be manufactured"}, {"name": "boat_train_limit", "expr_lhs": "x['boat']", "sense": "<=", "expr_rhs": "x['train']", "description": "Number of boats cannot exceed number of trains"}, {"name": "truck_binary_link", "expr_lhs": "x['truck']", "sense": "<=", "expr_rhs": "1000 * y_truck", "description": "Link truck production to binary variable"}, {"name": "train_binary_link", "expr_lhs": "x['train']", "sense": "<=", "expr_rhs": "1000 * y_train", "description": "Link train production to binary variable"}, {"name": "boat_binary_link", "expr_lhs": "x['boat']", "sense": "<=", "expr_rhs": "1000 * y_boat", "description": "Link boat production to binary variable"}, {"name": "plane_binary_link", "expr_lhs": "x['plane']", "sense": "<=", "expr_rhs": "1000 * y_plane", "description": "Link plane production to binary variable"}]}, "eval": {"ground_truth_raw": "623.0", "ground_truth_value": 623.0, "obj_value": 623.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_33", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "solver_build", "error": "TypeError: '>' not supported between instances of 'Var' and 'int'", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "NONE", "obj_value": null}, "ir_dict": {"meta": {"problem_id": "industryOR_33", "source": "IndustryOR", "description": "Vicky and David just bought a farm in the Yarra Valley and are considering using it to grow apples, pears, oranges, and lemons. The profit from growing one acre of apples is $2000, of pears is $1800, of oranges is $2200, and of lemons is $3000. In order to maximize profit, how many acres of land should they use to grow each fruit?\nVicky and David just bought a farm in the Yarra Valley and are considering using it to grow apples, pears, oranges, and lemons. The total land area is 120 acres.\n\nThe land area for growing apples should be at least twice the land area for growing pears.\n\nThe land area for growing apples should be at least three times the land area for growing lemons.\n\nThe land area for growing oranges must be twice the land area for growing lemons.\n\nVicky and David are not willing to grow more than two types of fruit.", "sense": "max", "version": "v1"}, "sets": [{"name": "Fruits", "elements": ["apples", "pears", "oranges", "lemons"], "description": "Types of fruits that can be grown on the farm."}], "params": [{"name": "profit", "indices": ["Fruits"], "values": {"apples": 2000.0, "pears": 1800.0, "oranges": 2200.0, "lemons": 3000.0}, "description": "Profit per acre for each type of fruit."}], "vars": [{"name": "land", "indices": ["Fruits"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Acres of land allocated to each type of fruit."}], "objective": {"name": "max_profit", "sense": "max", "expr": "quicksum(profit[f] * land[f] for f in Fruits)", "description": "Maximize the total profit from the farm."}, "constraints": [{"name": "total_land", "expr_lhs": "quicksum(land[f] for f in Fruits)", "sense": "<=", "expr_rhs": "120.0", "description": "Total land available is 120 acres."}, {"name": "apples_pears", "expr_lhs": "land['apples']", "sense": ">=", "expr_rhs": "2 * land['pears']", "description": "Land for apples should be at least twice the land for pears."}, {"name": "apples_lemons", "expr_lhs": "land['apples']", "sense": ">=", "expr_rhs": "3 * land['lemons']", "description": "Land for apples should be at least three times the land for lemons."}, {"name": "oranges_lemons", "expr_lhs": "land['oranges']", "sense": "==", "expr_rhs": "2 * land['lemons']", "description": "Land for oranges must be twice the land for lemons."}, {"name": "max_two_fruits", "expr_lhs": "quicksum(1 for f in Fruits if land[f] > 0)", "sense": "<=", "expr_rhs": "2.0", "description": "No more than two types of fruits can be grown."}]}, "eval": {"ground_truth_raw": "240000.0", "ground_truth_value": 240000.0, "obj_value": null, "status": "NONE", "correct": 0}}
{"meta": {"problem_id": "industryOR_34", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 940.0}, "ir_dict": {"meta": {"problem_id": "industryOR_34", "source": "IndustryOR", "description": "A restaurant needs to order tables from three different suppliers, A, B, and C. The cost of ordering each table from supplier A is $120, from supplier B is $110, and from supplier C is $100. The restaurant wants to minimize the total cost of the orders.\n\nIn addition, each order from supplier A will include 20 tables, while orders from suppliers B and C will include 15 tables each. The quantity of orders can only be whole numbers. The restaurant needs to order at least 150 tables.\n\nEach order from supplier A will include 20 tables, while orders from suppliers B and C will include 15 tables each. The restaurant needs to order a maximum of 600 tables.\n\nIf the restaurant decides to order tables from supplier A, it must also order at least 30 tables from supplier B.\n\nFurthermore, if the restaurant decides to order tables from supplier B, it must also order tables from supplier C.", "sense": "min", "version": "v1"}, "sets": [{"name": "Suppliers", "elements": ["A", "B", "C"], "description": null}], "params": [{"name": "cost", "indices": ["Suppliers"], "values": {"A": 120.0, "B": 110.0, "C": 100.0}, "description": null}, {"name": "tables_per_order", "indices": ["Suppliers"], "values": {"A": 20.0, "B": 15.0, "C": 15.0}, "description": null}], "vars": [{"name": "orders", "indices": ["Suppliers"], "vartype": "integer", "lb": 0.0, "ub": null, "description": null}, {"name": "y_A", "indices": [], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if ordering from A, 0 otherwise"}, {"name": "y_B", "indices": [], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if ordering from B, 0 otherwise"}, {"name": "y_C", "indices": [], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "1 if ordering from C, 0 otherwise"}], "objective": {"name": "total_cost", "sense": "min", "expr": "quicksum(cost[s] * orders[s] for s in Suppliers)", "description": null}, "constraints": [{"name": "min_tables", "expr_lhs": "quicksum(tables_per_order[s] * orders[s] for s in Suppliers)", "sense": ">=", "expr_rhs": "150.0", "description": "Minimum number of tables required"}, {"name": "max_tables", "expr_lhs": "quicksum(tables_per_order[s] * orders[s] for s in Suppliers)", "sense": "<=", "expr_rhs": "600.0", "description": "Maximum number of tables allowed"}, {"name": "order_from_A_implication", "expr_lhs": "orders['B']", "sense": ">=", "expr_rhs": "1.5 * y_A", "description": "If ordering from A, must order at least 30 tables from B"}, {"name": "order_from_B_implication", "expr_lhs": "y_C", "sense": ">=", "expr_rhs": "y_B", "description": "If ordering from B, must order from C"}, {"name": "y_A_definition", "expr_lhs": "orders['A']", "sense": "<=", "expr_rhs": "1000.0 * y_A", "description": "Define y_A"}, {"name": "y_B_definition", "expr_lhs": "orders['B']", "sense": "<=", "expr_rhs": "1000.0 * y_B", "description": "Define y_B"}, {"name": "y_C_definition", "expr_lhs": "orders['C']", "sense": "<=", "expr_rhs": "1000.0 * y_C", "description": "Define y_C"}]}, "eval": {"ground_truth_raw": "15000", "ground_truth_value": 15000.0, "obj_value": 940.0, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_35", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 82999450.0}, "ir_dict": {"meta": {"problem_id": "industryOR_35", "source": "IndustryOR", "description": "The independent country of Carelland primarily exports four commodities: steel, engines, electronic components, and plastics. The Finance Minister of Carelland (i.e., the Minister of Economy) wants to maximize exports and minimize imports. The unit prices of steel, engines, electronics, and plastics on the world market, expressed in the local currency (Klunz), are: 500, 1500, 300, and 1200, respectively. Producing 1 unit of steel requires 0.02 units of engines, 0.01 units of plastics, 250 Klunz of other imported goods, and 6 person-months of work. Producing 1 unit of engines requires 0.8 units of steel, 0.15 units of electronic components, 0.11 units of plastics, 300 Klunz of imported goods, and 1 person-year. Producing 1 unit of electronics requires 0.01 units of steel, 0.01 units of engines, 0.05 units of plastics, 50 Klunz of imported goods, and 6 person-months. Producing 1 unit of plastics requires 0.03 units of engines, 0.2 units of steel, 0.05 units of electronic components, 300 Klunz of imported goods, and 2 person-years. The production limit for engines is 650,000 units, and the production limit for plastics is 60,000 units. The total available labor force per year is 830,000. Write a mathematical program to maximize the gross domestic product and solve the problem using AMPL.", "sense": "max", "version": "v1"}, "sets": [{"name": "Commodities", "elements": ["steel", "engines", "electronics", "plastics"], "description": "Types of commodities exported by Carelland"}], "params": [{"name": "price", "indices": ["Commodities"], "values": {"steel": 500.0, "engines": 1500.0, "electronics": 300.0, "plastics": 1200.0}, "description": "Unit prices of commodities in Klunz"}, {"name": "import_cost", "indices": ["Commodities"], "values": {"steel": 250.0, "engines": 300.0, "electronics": 50.0, "plastics": 300.0}, "description": "Import cost per unit of commodity in Klunz"}, {"name": "labor", "indices": ["Commodities"], "values": {"steel": 6.0, "engines": 12.0, "electronics": 6.0, "plastics": 24.0}, "description": "Labor required per unit of commodity in person-months"}, {"name": "production_limit", "indices": ["Commodities"], "values": {"engines": 650000.0, "plastics": 60000.0}, "description": "Production limits for certain commodities"}, {"name": "total_labor", "indices": [], "values": 830000.0, "description": "Total available labor force per year in person-months"}], "vars": [{"name": "production", "indices": ["Commodities"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Production quantity of each commodity"}], "objective": {"name": "maximize_gdp", "sense": "max", "expr": "quicksum((price[c] - import_cost[c]) * production[c] for c in Commodities)", "description": "Maximize the gross domestic product by maximizing exports and minimizing imports"}, "constraints": [{"name": "labor_constraint", "expr_lhs": "quicksum(labor[c] * production[c] for c in Commodities)", "sense": "<=", "expr_rhs": "total_labor", "description": "Total labor constraint"}, {"name": "engines_production_limit", "expr_lhs": "production['engines']", "sense": "<=", "expr_rhs": "production_limit['engines']", "description": "Production limit for engines"}, {"name": "plastics_production_limit", "expr_lhs": "production['plastics']", "sense": "<=", "expr_rhs": "production_limit['plastics']", "description": "Production limit for plastics"}]}, "eval": {"ground_truth_raw": "435431000", "ground_truth_value": 435431000.0, "obj_value": 82999450.0, "status": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_36", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": ["unroll_free_index_constraints"], "repairs": ["unroll_free_index_constraints"]}, "solver": {"status_name": "OPTIMAL", "obj_value": 10755.0}, "ir_dict": {"meta": {"problem_id": "industryOR_36", "source": "IndustryOR", "description": "The contract booking numbers for three products, I, II, and III, for each quarter of the next year are shown in Table 1-10.\n\nTable 1-10\n\\begin{tabular}{c|c|c|c|c}\n\\hline \\multirow{2}{*}{ Product } & \\multicolumn{4}{|c}{ Quarter } \\\\\n\\cline { 2 - 5 } & 1 & 2 & 3 & 4 \\\\\n\\hline I & 1500 & 1000 & 2000 & 1200 \\\\\nII & 1500 & 1500 & 1200 & 1500 \\\\\nIII & 1000 & 2000 & 1500 & 2500 \\\\\n\\hline\n\\end{tabular}\n\nAt the beginning of the first quarter, there is no inventory for any of the three products. It is required to have 150 units of inventory for each product at the end of the fourth quarter. It is known that the factory has 15,000 hours of production time per quarter, and it takes 2, 4, and 3 hours respectively to produce one unit of products I, II, and III. Due to equipment replacement, product I cannot be produced in the second quarter. It is stipulated that if a product cannot be delivered on time, a compensation of $20 per unit per quarter will be paid for products I and II, and $10 for product III. Additionally, for products produced but not delivered in the same quarter, there is a storage cost of $5 per unit per quarter. How should the factory arrange its production to minimize the total compensation and storage costs?", "sense": "min", "version": "v1"}, "sets": [{"name": "Products", "elements": ["I", "II", "III"], "description": "Set of products"}, {"name": "Quarters", "elements": ["1", "2", "3", "4"], "description": "Set of quarters"}], "params": [{"name": "demand", "indices": ["Products", "Quarters"], "values": {"I": {"1": 1500, "2": 1000, "3": 2000, "4": 1200}, "II": {"1": 1500, "2": 1500, "3": 1200, "4": 1500}, "III": {"1": 1000, "2": 2000, "3": 1500, "4": 2500}}, "description": "Demand for each product in each quarter"}, {"name": "production_time", "indices": ["Products"], "values": {"I": 2, "II": 4, "III": 3}, "description": "Production time required per unit for each product"}, {"name": "compensation_cost", "indices": ["Products"], "values": {"I": 20, "II": 20, "III": 10}, "description": "Compensation cost per unit per quarter for late delivery"}, {"name": "storage_cost", "indices": [], "values": 5, "description": "Storage cost per unit per quarter"}, {"name": "production_capacity", "indices": [], "values": 15000, "description": "Total production hours available per quarter"}], "vars": [{"name": "produce", "indices": ["Products", "Quarters"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units produced of each product in each quarter"}, {"name": "inventory", "indices": ["Products", "Quarters"], "vartype": "integer", "lb": 0, "ub": null, "description": "Inventory of each product at the end of each quarter"}, {"name": "compensation", "indices": ["Products", "Quarters"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units not delivered on time for each product in each quarter"}], "objective": {"name": "total_cost", "sense": "min", "expr": "quicksum(compensation_cost[p] * compensation[p][q] + storage_cost * inventory[p][q] for p in Products for q in Quarters)", "description": "Minimize total compensation and storage costs"}, "constraints": [{"name": "inventory_balance_1", "expr_lhs": "inventory[p]['1']", "sense": "==", "expr_rhs": "produce[p]['1'] - demand[p]['1'] + compensation[p]['1']", "description": "Inventory balance for quarter 1"}, {"name": "inventory_balance_2", "expr_lhs": "inventory[p]['2']", "sense": "==", "expr_rhs": "inventory[p]['1'] + produce[p]['2'] - demand[p]['2'] + compensation[p]['2']", "description": "Inventory balance for quarter 2"}, {"name": "inventory_balance_3", "expr_lhs": "inventory[p]['3']", "sense": "==", "expr_rhs": "inventory[p]['2'] + produce[p]['3'] - demand[p]['3'] + compensation[p]['3']", "description": "Inventory balance for quarter 3"}, {"name": "inventory_balance_4", "expr_lhs": "inventory[p]['4']", "sense": "==", "expr_rhs": "inventory[p]['3'] + produce[p]['4'] - demand[p]['4'] + compensation[p]['4']", "description": "Inventory balance for quarter 4"}, {"name": "end_inventory_requirement", "expr_lhs": "inventory[p]['4']", "sense": "==", "expr_rhs": "150", "description": "End of year inventory requirement for each product"}, {"name": "production_capacity_1", "expr_lhs": "quicksum(production_time[p] * produce[p]['1'] for p in Products)", "sense": "<=", "expr_rhs": "production_capacity", "description": "Production capacity constraint for quarter 1"}, {"name": "production_capacity_2", "expr_lhs": "quicksum(production_time[p] * produce[p]['2'] for p in Products)", "sense": "<=", "expr_rhs": "production_capacity", "description": "Production capacity constraint for quarter 2"}, {"name": "production_capacity_3", "expr_lhs": "quicksum(production_time[p] * produce[p]['3'] for p in Products)", "sense": "<=", "expr_rhs": "production_capacity", "description": "Production capacity constraint for quarter 3"}, {"name": "production_capacity_4", "expr_lhs": "quicksum(production_time[p] * produce[p]['4'] for p in Products)", "sense": "<=", "expr_rhs": "production_capacity", "description": "Production capacity constraint for quarter 4"}, {"name": "no_production_I_q2", "expr_lhs": "produce['I']['2']", "sense": "==", "expr_rhs": "0", "description": "No production of product I in quarter 2"}]}, "eval": {"ground_truth_raw": "10755", "ground_truth_value": 10755.0, "obj_value": 10755.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_37", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "solver_build", "error": "TypeError: '>=' not supported between instances of 'str' and 'int'", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "NONE", "obj_value": null}, "ir_dict": {"meta": {"problem_id": "industryOR_37", "source": "IndustryOR", "description": "A factory needs to rent a warehouse to store materials for the next 4 months. The required warehouse area for each month is listed in Table 1-14.\nTable 1-14\n\\begin{tabular}{c|c|c|c|c}\n\\hline Month & 1 & 2 & 3 & 4 \\\\\n\\hline Required Warehouse Area $/ \\mathrm{m}^2$ & 1500 & 1000 & 2000 & 1200 \\\\\n\\hline\n\\end{tabular}\n\nThe longer the rental contract period, the greater the discount on warehouse rental fees. The specific data is listed in Table 1-15.\nTable 1-15\n\\begin{tabular}{c|c|c|c|c}\n\\hline Contract Rental Period $/$ months & 1 & 2 & 3 & 4 \\\\\n\\hline \\begin{tabular}{c} \nRental Fee for Warehouse \\\\\nArea within the Contract Period $/ \\mathrm{m}^2$\n\\end{tabular} & 28 & 45 & 60 & 73 \\\\\n\\hline\n\\end{tabular}\n\nThe warehouse rental contract can be processed at the beginning of each month, and each contract specifies the rental area and period. Therefore, the factory can rent a contract on any month, and each time, they can sign one contract or multiple contracts with different rental areas and rental periods. The overall goal is to minimize the rental fees paid. Try to establish a linear programming mathematical model based on the above requirements.", "sense": "min", "version": "v1"}, "sets": [{"name": "Months", "elements": ["1", "2", "3", "4"], "description": "Months for which warehouse space is needed"}, {"name": "Periods", "elements": ["1", "2", "3", "4"], "description": "Contract rental periods in months"}], "params": [{"name": "required_area", "indices": ["Months"], "values": {"1": 1500, "2": 1000, "3": 2000, "4": 1200}, "description": "Required warehouse area for each month"}, {"name": "rental_fee", "indices": ["Periods"], "values": {"1": 28, "2": 45, "3": 60, "4": 73}, "description": "Rental fee per m^2 for each contract period"}], "vars": [{"name": "x", "indices": ["Months", "Periods"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Area rented in month m for period p"}], "objective": {"name": "total_cost", "sense": "min", "expr": "quicksum(rental_fee[p] * x[m][p] for m in Months for p in Periods)", "description": "Minimize total rental cost"}, "constraints": [{"name": "demand_month_1", "expr_lhs": "quicksum(x['1'][p] for p in Periods)", "sense": ">=", "expr_rhs": "required_area['1']", "description": "Meet area demand for month 1"}, {"name": "demand_month_2", "expr_lhs": "quicksum(x['2'][p] + (x['1'][p] if p >= 2 else 0) for p in Periods)", "sense": ">=", "expr_rhs": "required_area['2']", "description": "Meet area demand for month 2"}, {"name": "demand_month_3", "expr_lhs": "quicksum(x['3'][p] + (x['2'][p] if p >= 2 else 0) + (x['1'][p] if p >= 3 else 0) for p in Periods)", "sense": ">=", "expr_rhs": "required_area['3']", "description": "Meet area demand for month 3"}, {"name": "demand_month_4", "expr_lhs": "quicksum(x['4'][p] + (x['3'][p] if p >= 2 else 0) + (x['2'][p] if p >= 3 else 0) + (x['1'][p] if p == 4 else 0) for p in Periods)", "sense": ">=", "expr_rhs": "required_area['4']", "description": "Meet area demand for month 4"}]}, "eval": {"ground_truth_raw": "118400", "ground_truth_value": 118400.0, "obj_value": null, "status": "NONE", "correct": 0}}
{"meta": {"problem_id": "industryOR_38", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 85.0}, "ir_dict": {"meta": {"problem_id": "industryOR_38", "source": "IndustryOR", "description": "Traveling Salesman Problem (TSP) with Specific Values\\n\\nThe famous traveling salesman problem in operations research can be described as follows: a traveling salesman starts from a certain city and goes to visit other \\( n \\) cities to sell goods. It is required to visit each city exactly once and then return to the original starting city. The distance between city \\( i \\) and city \\( j \\) is given as \\( d_{ij} \\). What kind of route sequence should the salesman choose to minimize the total travel distance?\\n\\nWe will establish an integer programming model for this problem using specific values for the number of cities and distances between them. Let's assume there are 5 cities (including the starting city) and the distance matrix \\( D \\) is given as follows:\\n\\n\\[\\nD = \\begin{bmatrix}\\n0 & 10 & 15 & 20 & 25 \\\\\\n10 & 0 & 35 & 25 & 30 \\\\\\n15 & 35 & 0 & 30 & 20 \\\\\\n20 & 25 & 30 & 0 & 15 \\\\\\n25 & 30 & 20 & 15 & 0\\n\\end{bmatrix}\\n\\", "sense": "min", "version": "v1"}, "sets": [{"name": "Cities", "elements": ["0", "1", "2", "3", "4"], "description": "Set of cities including the starting city"}], "params": [{"name": "d", "indices": ["Cities", "Cities"], "values": {"0": {"0": 0, "1": 10, "2": 15, "3": 20, "4": 25}, "1": {"0": 10, "1": 0, "2": 35, "3": 25, "4": 30}, "2": {"0": 15, "1": 35, "2": 0, "3": 30, "4": 20}, "3": {"0": 20, "1": 25, "2": 30, "3": 0, "4": 15}, "4": {"0": 25, "1": 30, "2": 20, "3": 15, "4": 0}}, "description": "Distance matrix between cities"}], "vars": [{"name": "x", "indices": ["Cities", "Cities"], "vartype": "binary", "lb": 0, "ub": 1, "description": "1 if the path between city i and city j is used, 0 otherwise"}, {"name": "u", "indices": ["Cities"], "vartype": "integer", "lb": 0, "ub": 4, "description": "Subtour elimination variable"}], "objective": {"name": "minimize_distance", "sense": "min", "expr": "quicksum(d[i][j] * x[i][j] for i in Cities for j in Cities)", "description": "Minimize the total travel distance"}, "constraints": [{"name": "visit_each_city_once_0", "expr_lhs": "quicksum(x['0'][j] for j in Cities if j != '0')", "sense": "==", "expr_rhs": "1", "description": "Leave city 0 exactly once"}, {"name": "visit_each_city_once_1", "expr_lhs": "quicksum(x['1'][j] for j in Cities if j != '1')", "sense": "==", "expr_rhs": "1", "description": "Leave city 1 exactly once"}, {"name": "visit_each_city_once_2", "expr_lhs": "quicksum(x['2'][j] for j in Cities if j != '2')", "sense": "==", "expr_rhs": "1", "description": "Leave city 2 exactly once"}, {"name": "visit_each_city_once_3", "expr_lhs": "quicksum(x['3'][j] for j in Cities if j != '3')", "sense": "==", "expr_rhs": "1", "description": "Leave city 3 exactly once"}, {"name": "visit_each_city_once_4", "expr_lhs": "quicksum(x['4'][j] for j in Cities if j != '4')", "sense": "==", "expr_rhs": "1", "description": "Leave city 4 exactly once"}, {"name": "enter_each_city_once_0", "expr_lhs": "quicksum(x[i]['0'] for i in Cities if i != '0')", "sense": "==", "expr_rhs": "1", "description": "Enter city 0 exactly once"}, {"name": "enter_each_city_once_1", "expr_lhs": "quicksum(x[i]['1'] for i in Cities if i != '1')", "sense": "==", "expr_rhs": "1", "description": "Enter city 1 exactly once"}, {"name": "enter_each_city_once_2", "expr_lhs": "quicksum(x[i]['2'] for i in Cities if i != '2')", "sense": "==", "expr_rhs": "1", "description": "Enter city 2 exactly once"}, {"name": "enter_each_city_once_3", "expr_lhs": "quicksum(x[i]['3'] for i in Cities if i != '3')", "sense": "==", "expr_rhs": "1", "description": "Enter city 3 exactly once"}, {"name": "enter_each_city_once_4", "expr_lhs": "quicksum(x[i]['4'] for i in Cities if i != '4')", "sense": "==", "expr_rhs": "1", "description": "Enter city 4 exactly once"}, {"name": "subtour_elimination_1", "expr_lhs": "u['1'] - u['0'] + 5 * x['0']['1']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for city 1"}, {"name": "subtour_elimination_2", "expr_lhs": "u['2'] - u['0'] + 5 * x['0']['2']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for city 2"}, {"name": "subtour_elimination_3", "expr_lhs": "u['3'] - u['0'] + 5 * x['0']['3']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for city 3"}, {"name": "subtour_elimination_4", "expr_lhs": "u['4'] - u['0'] + 5 * x['0']['4']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for city 4"}]}, "eval": {"ground_truth_raw": "85", "ground_truth_value": 85.0, "obj_value": 85.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_39", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 150.0}, "ir_dict": {"meta": {"problem_id": "industryOR_39", "source": "IndustryOR", "description": "For a certain daytime and nighttime service bus route, the number of drivers and crew members required during each time period is given in Table 1-2:\nTable 1-2\n\\begin{tabular}{|c|c|c||c|c|c|}\n\\hline Shift & Time & Number Required & Shift & Time & Number Required \\\\\n\\hline 1 & $6: 00 \\sim 10: 00$ & 60 & 4 & $18: 00 \\sim 22: 00$ & 50 \\\\\n\\hline 2 & $10: 00 \\sim 14: 00$ & 70 & 5 & $22: 00 \\sim 2: 00$ & 20 \\\\\n\\hline 3 & $14: 00 \\sim 18: 00$ & 60 & 6 & $2: 00 \\sim 6: 00$ & 30 \\\\\n\\hline\n\\end{tabular}\n\nAssuming that the drivers and crew members start working at the beginning of each time period and work continuously for 8 hours, how many drivers and crew members should be assigned to this bus route at least? Write down the linear programming model for this problem.", "sense": "min", "version": "v1"}, "sets": [{"name": "Shifts", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Shift identifiers"}], "params": [{"name": "required", "indices": ["Shifts"], "values": {"1": 60, "2": 70, "3": 60, "4": 50, "5": 20, "6": 30}, "description": "Number of drivers and crew members required for each shift"}], "vars": [{"name": "x", "indices": ["Shifts"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of drivers and crew members assigned to each shift"}], "objective": {"name": "minimize_drivers", "sense": "min", "expr": "quicksum(x[s] for s in Shifts)", "description": "Minimize the total number of drivers and crew members assigned"}, "constraints": [{"name": "shift_1_requirement", "expr_lhs": "x['1'] + x['4']", "sense": ">=", "expr_rhs": "required['1']", "description": "Meet the requirement for shift 1"}, {"name": "shift_2_requirement", "expr_lhs": "x['1'] + x['2']", "sense": ">=", "expr_rhs": "required['2']", "description": "Meet the requirement for shift 2"}, {"name": "shift_3_requirement", "expr_lhs": "x['2'] + x['3']", "sense": ">=", "expr_rhs": "required['3']", "description": "Meet the requirement for shift 3"}, {"name": "shift_4_requirement", "expr_lhs": "x['3'] + x['4']", "sense": ">=", "expr_rhs": "required['4']", "description": "Meet the requirement for shift 4"}, {"name": "shift_5_requirement", "expr_lhs": "x['4'] + x['5']", "sense": ">=", "expr_rhs": "required['5']", "description": "Meet the requirement for shift 5"}, {"name": "shift_6_requirement", "expr_lhs": "x['5'] + x['6']", "sense": ">=", "expr_rhs": "required['6']", "description": "Meet the requirement for shift 6"}]}, "eval": {"ground_truth_raw": "150", "ground_truth_value": 150.0, "obj_value": 150.0, "status": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_40", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "UNBOUNDED", "obj_value": null}, "ir_dict": {"meta": {"problem_id": "industryOR_40", "source": "IndustryOR", "description": "A factory produces three products, I, II, and III. Each product goes through two processing procedures, A and B. The factory has two types of equipment, A1 and A2, to complete procedure A, and three types of equipment, B1, B2, and B3, to complete procedure B. Product I can be processed on either type of A equipment or any type of B equipment. Product II can be processed on any type of A equipment, but when completing procedure B, it can only be processed on B1 equipment. Product III can only be processed on A2 and B2 equipment. Given the processing time, raw material cost, product selling price, available equipment operating time, and equipment cost at full load for each type of equipment, as shown in Table 1-4, determine the optimal production plan to maximize profit.\n\nTable 1-4\n\\begin{tabular}{|c|c|c|c|c|c|}\n\\hline \\multirow{2}{*}{ Equipment } & \\multicolumn{3}{|c|}{ Product } & \\multirow{2}{*}{ Available Equipment Operating Time } & \\multirow{2}{*}{ Equipment Cost at Full Load (in yuan) } \\\\\n\\cline { 2 - 4 } & I & II & III & & \\\\\n\\hline$A_1$ & 5 & 10 & & 6000 & 300 \\\\\n\\hline$A_2$ & 7 & 9 & 12 & 10000 & 321 \\\\\n\\hline$B_1$ & 6 & 8 & & 4000 & 250 \\\\\n\\hline$B_2$ & 4 & & 11 & 7000 & 783 \\\\\n\\hline$B_3$ & 7 & & & 4000 & 200 \\\\\n\\hline Raw Material Cost (in yuan per unit) & 0.25 & 0.35 & 0.50 & & \\\\\n\\hline Unit Price (in yuan per unit) & 1.25 & 2.00 & 2.80 & & \\\\\n\\hline\n\\end{tabular}", "sense": "max", "version": "v1"}, "sets": [{"name": "Products", "elements": ["I", "II", "III"], "description": "Set of products"}, {"name": "EquipmentA", "elements": ["A1", "A2"], "description": "Set of equipment for procedure A"}, {"name": "EquipmentB", "elements": ["B1", "B2", "B3"], "description": "Set of equipment for procedure B"}], "params": [{"name": "processing_time_A", "indices": ["EquipmentA", "Products"], "values": {"A1": {"I": 5, "II": 10, "III": 0}, "A2": {"I": 7, "II": 9, "III": 12}}, "description": "Processing time for procedure A"}, {"name": "processing_time_B", "indices": ["EquipmentB", "Products"], "values": {"B1": {"I": 6, "II": 8, "III": 0}, "B2": {"I": 4, "II": 0, "III": 11}, "B3": {"I": 7, "II": 0, "III": 0}}, "description": "Processing time for procedure B"}, {"name": "available_time", "indices": ["EquipmentA", "EquipmentB"], "values": {"A1": 6000, "A2": 10000, "B1": 4000, "B2": 7000, "B3": 4000}, "description": "Available equipment operating time"}, {"name": "equipment_cost", "indices": ["EquipmentA", "EquipmentB"], "values": {"A1": 300, "A2": 321, "B1": 250, "B2": 783, "B3": 200}, "description": "Equipment cost at full load"}, {"name": "raw_material_cost", "indices": ["Products"], "values": {"I": 0.25, "II": 0.35, "III": 0.5}, "description": "Raw material cost per unit"}, {"name": "unit_price", "indices": ["Products"], "values": {"I": 1.25, "II": 2.0, "III": 2.8}, "description": "Unit selling price"}], "vars": [{"name": "x_A", "indices": ["EquipmentA", "Products"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units of product processed on equipment A"}, {"name": "x_B", "indices": ["EquipmentB", "Products"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units of product processed on equipment B"}], "objective": {"name": "profit", "sense": "max", "expr": "quicksum((unit_price[p] - raw_material_cost[p]) * (quicksum(x_A[a][p] for a in EquipmentA) + quicksum(x_B[b][p] for b in EquipmentB)) for p in Products) - quicksum(equipment_cost[a] * quicksum(x_A[a][p] * processing_time_A[a][p] for p in Products) for a in EquipmentA) - quicksum(equipment_cost[b] * quicksum(x_B[b][p] * processing_time_B[b][p] for p in Products) for b in EquipmentB)", "description": "Maximize profit"}, "constraints": [{"name": "time_A1", "expr_lhs": "quicksum(x_A['A1'][p] * processing_time_A['A1'][p] for p in Products)", "sense": "<=", "expr_rhs": "available_time['A1']", "description": "Time constraint for equipment A1"}, {"name": "time_A2", "expr_lhs": "quicksum(x_A['A2'][p] * processing_time_A['A2'][p] for p in Products)", "sense": "<=", "expr_rhs": "available_time['A2']", "description": "Time constraint for equipment A2"}, {"name": "time_B1", "expr_lhs": "quicksum(x_B['B1'][p] * processing_time_B['B1'][p] for p in Products)", "sense": "<=", "expr_rhs": "available_time['B1']", "description": "Time constraint for equipment B1"}, {"name": "time_B2", "expr_lhs": "quicksum(x_B['B2'][p] * processing_time_B['B2'][p] for p in Products)", "sense": "<=", "expr_rhs": "available_time['B2']", "description": "Time constraint for equipment B2"}, {"name": "time_B3", "expr_lhs": "quicksum(x_B['B3'][p] * processing_time_B['B3'][p] for p in Products)", "sense": "<=", "expr_rhs": "available_time['B3']", "description": "Time constraint for equipment B3"}, {"name": "product_I_A", "expr_lhs": "x_A['A1']['I'] + x_A['A2']['I']", "sense": "==", "expr_rhs": "quicksum(x_B[b]['I'] for b in EquipmentB)", "description": "Balance for product I between A and B"}, {"name": "product_II_A", "expr_lhs": "x_A['A1']['II'] + x_A['A2']['II']", "sense": "==", "expr_rhs": "x_B['B1']['II']", "description": "Balance for product II between A and B"}, {"name": "product_III_A", "expr_lhs": "x_A['A2']['III']", "sense": "==", "expr_rhs": "x_B['B2']['III']", "description": "Balance for product III between A and B"}]}, "eval": {"ground_truth_raw": "1146.57", "ground_truth_value": 1146.57, "obj_value": null, "status": "UNBOUNDED", "correct": 0}}
{"meta": {"problem_id": "industryOR_41", "model_name": "gpt-4o", "timelimit_sec": 60.0, "layer1_on": true, "layer2_on": true, "layer3_on": true, "repairs_on": true}, "failure_stage": "", "error": "", "verifier": {"ok": true, "issues": [], "repairs": []}, "solver": {"status_name": "OPTIMAL", "obj_value": 22.0}, "ir_dict": {"meta": {"problem_id": "industryOR_41", "source": "IndustryOR", "description": "A certain restaurant operates 24 hours a day and requires a minimum number of waitstaff as shown in Table 1.1.\n\nTable 1.1\n\n| Time | Minimum Number of Waitstaff |\n| :---: | :---: |\n| 2am-6am | 4 |\n| 6am-10am | 8 |\n| 10am-2pm | 10 |\n| 2pm-6pm | 4 |\n| 6pm-10pm | 8 |\n| 10pm-2am | 4 |\n\nEach waitstaff works continuously for 8 hours a day. The goal is to find the minimum number of waitstaff that satisfies the above conditions and represent this problem as a linear programming model.", "sense": "min", "version": "v1"}, "sets": [{"name": "T", "elements": ["2am-6am", "6am-10am", "10am-2pm", "2pm-6pm", "6pm-10pm", "10pm-2am"], "description": "Time periods in the restaurant's schedule"}], "params": [{"name": "min_waitstaff", "indices": ["T"], "values": {"2am-6am": 4, "6am-10am": 8, "10am-2pm": 10, "2pm-6pm": 4, "6pm-10pm": 8, "10pm-2am": 4}, "description": "Minimum number of waitstaff required for each time period"}], "vars": [{"name": "w", "indices": ["T"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of waitstaff starting their shift at each time period"}], "objective": {"name": "total_waitstaff", "sense": "min", "expr": "quicksum(w[t] for t in T)", "description": "Minimize the total number of waitstaff"}, "constraints": [{"name": "coverage_2am_6am", "expr_lhs": "w['10pm-2am'] + w['2am-6am']", "sense": ">=", "expr_rhs": "min_waitstaff['2am-6am']", "description": "Ensure enough waitstaff from 2am to 6am"}, {"name": "coverage_6am_10am", "expr_lhs": "w['2am-6am'] + w['6am-10am']", "sense": ">=", "expr_rhs": "min_waitstaff['6am-10am']", "description": "Ensure enough waitstaff from 6am to 10am"}, {"name": "coverage_10am_2pm", "expr_lhs": "w['6am-10am'] + w['10am-2pm']", "sense": ">=", "expr_rhs": "min_waitstaff['10am-2pm']", "description": "Ensure enough waitstaff from 10am to 2pm"}, {"name": "coverage_2pm_6pm", "expr_lhs": "w['10am-2pm'] + w['2pm-6pm']", "sense": ">=", "expr_rhs": "min_waitstaff['2pm-6pm']", "description": "Ensure enough waitstaff from 2pm to 6pm"}, {"name": "coverage_6pm_10pm", "expr_lhs": "w['2pm-6pm'] + w['6pm-10pm']", "sense": ">=", "expr_rhs": "min_waitstaff['6pm-10pm']", "description": "Ensure enough waitstaff from 6pm to 10pm"}, {"name": "coverage_10pm_2am", "expr_lhs": "w['6pm-10pm'] + w['10pm-2am']", "sense": ">=", "expr_rhs": "min_waitstaff['10pm-2am']", "description": "Ensure enough waitstaff from 10pm to 2am"}]}, "eval": {"ground_truth_raw": "22.0", "ground_truth_value": 22.0, "obj_value": 22.0, "status": "OPTIMAL", "correct": 1}}
