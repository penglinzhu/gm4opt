{"meta": {"problem_id": "industryOR_0", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 6.00004568696022e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 11.964245300041512, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00015259999781847, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 1.8998980522155762e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 6.500002928078175e-05, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 7.770000956952572e-05, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.200009137392044e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.003999499953351915, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.005126700038090348, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.300009898841381e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 6.00004568696022e-06, "llm_call": 11.964245300041512, "json_extract": 0.00015259999781847, "meta_fill": 1.8998980522155762e-06, "ir_parse": 6.500002928078175e-05, "graph_build": 7.770000956952572e-05, "verifier": 1.200009137392044e-06, "solver_build": 0.003999499953351915, "solver_optimize": 0.005126700038090348, "estimation": 1.300009898841381e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 1, "n_vars": 1, "n_constraints": 7}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 3050.0, "metrics": {"runtime_sec": 0.003000020980834961, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_0", "source": "IndustryOR", "description": "Determine which children the Zhang family should take on their trip to minimize the total cost.", "sense": "min", "version": 1}, "sets": [{"name": "CHILDREN", "elements": ["Harry", "Hermione", "Ron", "Fred", "George", "Ginny"], "description": "The children in the Zhang family."}], "params": [{"name": "cost", "indices": ["CHILDREN"], "values": {"Harry": 1200, "Hermione": 1650, "Ron": 750, "Fred": 800, "George": 800, "Ginny": 1500}, "description": "The cost of taking each child."}], "vars": [{"name": "take", "indices": ["CHILDREN"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating whether each child is taken on the trip."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(cost[c] * take[c] for c in CHILDREN)", "description": "Minimize the total cost of taking the children."}, "constraints": [{"name": "max_4_children", "expr_lhs": "sum(take[c] for c in CHILDREN)", "sense": "<=", "expr_rhs": "4", "description": "The couple can take a maximum of 4 children."}, {"name": "take_ginny", "expr_lhs": "take['Ginny']", "sense": "==", "expr_rhs": "1", "description": "Ginny is the youngest, so the Zhang family will definitely take her."}, {"name": "no_harry_fred", "expr_lhs": "take['Harry'] + take['Fred']", "sense": "<=", "expr_rhs": "1", "description": "If the couple takes Harry, they will not take Fred."}, {"name": "no_harry_george", "expr_lhs": "take['Harry'] + take['George']", "sense": "<=", "expr_rhs": "1", "description": "If the couple takes Harry, they will not take George."}, {"name": "george_fred", "expr_lhs": "take['George'] - take['Fred']", "sense": "<=", "expr_rhs": "0", "description": "If they take George, they must also take Fred."}, {"name": "george_hermione", "expr_lhs": "take['George'] - take['Hermione']", "sense": "<=", "expr_rhs": "0", "description": "If they take George, they must also take Hermione."}, {"name": "min_3_children", "expr_lhs": "sum(take[c] for c in CHILDREN)", "sense": ">=", "expr_rhs": "3", "description": "The Zhang family has decided to take at least three children."}], "graph": null}, "eval": {"ground_truth_raw": "3050.0", "ground_truth_value": 3050.0, "obj_value": 3050.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_1", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.400033503770828e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 6.941409599967301, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00013050006236881018, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.700043402612209e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00015769992023706436, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00024069997016340494, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 2.900022082030773e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0008900000248104334, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.001957800006493926, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.200009137392044e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.400033503770828e-06, "llm_call": 6.941409599967301, "json_extract": 0.00013050006236881018, "meta_fill": 5.700043402612209e-06, "ir_parse": 0.00015769992023706436, "graph_build": 0.00024069997016340494, "verifier": 2.900022082030773e-06, "solver_build": 0.0008900000248104334, "solver_optimize": 0.001957800006493926, "estimation": 1.200009137392044e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 3, "n_vars": 1, "n_constraints": 2}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 135000.0, "metrics": {"runtime_sec": 0.002000093460083008, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_1", "source": "IndustryOR", "description": "Maximize the annual income from purchasing properties within a budget constraint and a mutual exclusivity condition.", "sense": "max", "version": 1}, "sets": [{"name": "PROPERTIES", "elements": ["1", "2", "3", "4"], "description": "Set of properties available for purchase."}], "params": [{"name": "annual_income", "indices": ["PROPERTIES"], "values": {"1": 12500, "2": 35000, "3": 23000, "4": 100000}, "description": "Annual income from each property."}, {"name": "cost", "indices": ["PROPERTIES"], "values": {"1": 1.5, "2": 2.1, "3": 2.3, "4": 4.2}, "description": "Cost in millions to purchase each property."}, {"name": "budget", "indices": [], "values": 7, "description": "Total budget available in millions."}], "vars": [{"name": "buy", "indices": ["PROPERTIES"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary decision variable indicating whether to buy each property."}], "objective": {"name": "max_total_income", "sense": "max", "expr": "sum(annual_income[p] * buy[p] for p in ['1', '2', '3', '4'])", "description": "Maximize the total annual income from purchased properties."}, "constraints": [{"name": "budget_constraint", "expr_lhs": "sum(cost[p] * buy[p] for p in ['1', '2', '3', '4'])", "sense": "<=", "expr_rhs": "budget", "description": "Total cost of purchased properties must not exceed the budget."}, {"name": "mutual_exclusivity_3_4", "expr_lhs": "buy['3'] + buy['4']", "sense": "<=", "expr_rhs": "1", "description": "Cannot purchase both Property 3 and Property 4."}], "graph": null}, "eval": {"ground_truth_raw": "135000.0", "ground_truth_value": 135000.0, "obj_value": 135000.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_2", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 3.2999087125062943e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 7.663076600059867, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00016960001084953547, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.3999323174357414e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00020729994866997004, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00030880002304911613, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 3.4999102354049683e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0022628000006079674, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.010502099990844727, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 4.200031980872154e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 3.2999087125062943e-06, "llm_call": 7.663076600059867, "json_extract": 0.00016960001084953547, "meta_fill": 6.3999323174357414e-06, "ir_parse": 0.00020729994866997004, "graph_build": 0.00030880002304911613, "verifier": 3.4999102354049683e-06, "solver_build": 0.0022628000006079674, "solver_optimize": 0.010502099990844727, "estimation": 4.200031980872154e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 3, "n_vars": 1, "n_constraints": 5}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 30400.0, "metrics": {"runtime_sec": 0.0, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_2", "source": "IndustryOR", "description": "Optimize the number of cows, sheep, and chickens to maximize profit given constraints on manure cleaning capacity, farm size, and minimum animal requirements.", "sense": "max", "version": 1}, "sets": [{"name": "ANIMALS", "elements": ["cows", "sheep", "chickens"], "description": "Types of animals the farmer can raise."}], "params": [{"name": "selling_price", "indices": ["ANIMALS"], "values": {"cows": 500, "sheep": 200, "chickens": 8}, "description": "Selling price for each type of animal."}, {"name": "feed_cost", "indices": ["ANIMALS"], "values": {"cows": 100, "sheep": 80, "chickens": 5}, "description": "Feed cost for each type of animal."}, {"name": "manure_production", "indices": ["ANIMALS"], "values": {"cows": 10, "sheep": 5, "chickens": 3}, "description": "Manure production per day for each type of animal."}], "vars": [{"name": "num_animals", "indices": ["ANIMALS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of each type of animal to raise."}], "objective": {"name": "max_profit", "sense": "max", "expr": "sum((selling_price[a] - feed_cost[a]) * num_animals[a] for a in ['cows', 'sheep', 'chickens'])", "description": "Maximize the profit from selling animals after deducting feed costs."}, "constraints": [{"name": "manure_capacity", "expr_lhs": "sum(manure_production[a] * num_animals[a] for a in ['cows', 'sheep', 'chickens'])", "sense": "<=", "expr_rhs": "800", "description": "The total manure production must not exceed the cleaning capacity of 800 units per day."}, {"name": "max_chickens", "expr_lhs": "num_animals['chickens']", "sense": "<=", "expr_rhs": "50", "description": "The number of chickens must not exceed 50 due to farm size limitations."}, {"name": "min_cows", "expr_lhs": "num_animals['cows']", "sense": ">=", "expr_rhs": "10", "description": "The number of cows must be at least 10 to meet customer demand."}, {"name": "min_sheep", "expr_lhs": "num_animals['sheep']", "sense": ">=", "expr_rhs": "20", "description": "The number of sheep must be at least 20."}, {"name": "total_animals", "expr_lhs": "sum(num_animals[a] for a in ['cows', 'sheep', 'chickens'])", "sense": "<=", "expr_rhs": "100", "description": "The total number of animals must not exceed 100."}], "graph": null}, "eval": {"ground_truth_raw": "30400.0", "ground_truth_value": 30400.0, "obj_value": 30400.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_3", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.00003045797348e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 8.547071500099264, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00018960004672408104, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.800044164061546e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00022489996626973152, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00038769992534071207, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 3.900029696524143e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0025942999636754394, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.0036747000413015485, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.500011421740055e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.00003045797348e-06, "llm_call": 8.547071500099264, "json_extract": 0.00018960004672408104, "meta_fill": 5.800044164061546e-06, "ir_parse": 0.00022489996626973152, "graph_build": 0.00038769992534071207, "verifier": 3.900029696524143e-06, "solver_build": 0.0025942999636754394, "solver_optimize": 0.0036747000413015485, "estimation": 1.500011421740055e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 3, "n_vars": 1, "n_constraints": 6}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 23000.0, "metrics": {"runtime_sec": 0.006999969482421875, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_3", "source": "IndustryOR", "description": "A company wants to hire new employees to minimize salary costs while meeting various constraints.", "sense": "min", "version": 1}, "sets": [{"name": "CANDIDATES", "elements": ["A", "B", "C", "D", "E"], "description": "The candidates available for hiring."}], "params": [{"name": "salary", "indices": ["CANDIDATES"], "values": {"A": 8100, "B": 20000, "C": 21000, "D": 3000, "E": 8000}, "description": "Salary requirements of each candidate."}, {"name": "qualification", "indices": ["CANDIDATES"], "values": {"A": "Bachelor", "B": "Master", "C": "PhD", "D": "None", "E": "None"}, "description": "Qualifications of each candidate."}, {"name": "experience", "indices": ["CANDIDATES"], "values": {"A": 3, "B": 10, "C": 4, "D": 3, "E": 7}, "description": "Work experience of each candidate in years."}], "vars": [{"name": "hire", "indices": ["CANDIDATES"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary decision variable indicating whether to hire a candidate."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(salary[c] * hire[c] for c in CANDIDATES)", "description": "Minimize the total salary paid to the hired candidates."}, "constraints": [{"name": "max_3_employees", "expr_lhs": "sum(hire[c] for c in CANDIDATES)", "sense": "<=", "expr_rhs": "3", "description": "Hire at most 3 new employees."}, {"name": "budget_limit", "expr_lhs": "sum(salary[c] * hire[c] for c in CANDIDATES)", "sense": "<=", "expr_rhs": "35000", "description": "Total payment to selected candidates must not exceed the budget."}, {"name": "at_least_one_master_or_phd", "expr_lhs": "hire['B'] + hire['C']", "sense": ">=", "expr_rhs": "1", "description": "Select at least one candidate with a master's or PhD degree."}, {"name": "min_12_years_experience", "expr_lhs": "sum(experience[c] * hire[c] for c in CANDIDATES)", "sense": ">=", "expr_rhs": "12", "description": "Total work experience of selected candidates must be at least 12 years."}, {"name": "at_most_one_of_A_or_E", "expr_lhs": "hire['A'] + hire['E']", "sense": "<=", "expr_rhs": "1", "description": "Choose at most one of candidates A or E."}, {"name": "min_2_employees", "expr_lhs": "sum(hire[c] for c in CANDIDATES)", "sense": ">=", "expr_rhs": "2", "description": "Hire at least 2 new employees."}], "graph": null}, "eval": {"ground_truth_raw": "23000.0", "ground_truth_value": 23000.0, "obj_value": 23000.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_4", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 1.4099990949034691e-05, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 6.783070100005716, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0001428000396117568, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.299931555986404e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0001908999402076006, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0002552999649196863, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.100031219422817e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.002117699943482876, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.015488300006836653, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.500011421740055e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 1.4099990949034691e-05, "llm_call": 6.783070100005716, "json_extract": 0.0001428000396117568, "meta_fill": 6.299931555986404e-06, "ir_parse": 0.0001908999402076006, "graph_build": 0.0002552999649196863, "verifier": 4.100031219422817e-06, "solver_build": 0.002117699943482876, "solver_optimize": 0.015488300006836653, "estimation": 1.500011421740055e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 2, "n_vars": 1, "n_constraints": 4}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 180000.0, "metrics": {"runtime_sec": 0.019999980926513672, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_4", "source": "IndustryOR", "description": "Maximize profit from planting crops on a farm with constraints on land usage.", "sense": "max", "version": 1}, "sets": [{"name": "CROPS", "elements": ["corn", "wheat", "soybeans", "sorghum"], "description": "Types of crops that can be planted on the farm."}], "params": [{"name": "profit", "indices": ["CROPS"], "values": {"corn": 1500, "wheat": 1200, "soybeans": 1800, "sorghum": 1600}, "description": "Profit per acre for each crop."}, {"name": "total_area", "indices": [], "values": 100, "description": "Total area of the farm in acres."}], "vars": [{"name": "area", "indices": ["CROPS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Area of land in acres used for each crop."}], "objective": {"name": "max_total_profit", "sense": "max", "expr": "sum(profit[crop] * area[crop] for crop in ['corn', 'wheat', 'soybeans', 'sorghum'])", "description": "Maximize the total profit from planting crops."}, "constraints": [{"name": "total_area_constraint", "expr_lhs": "sum(area[crop] for crop in ['corn', 'wheat', 'soybeans', 'sorghum'])", "sense": "<=", "expr_rhs": "total_area", "description": "The total area used for planting cannot exceed the total farm area."}, {"name": "corn_wheat_constraint", "expr_lhs": "area['corn']", "sense": ">=", "expr_rhs": "2 * area['wheat']", "description": "The area for corn should be at least twice the area for wheat."}, {"name": "soybeans_sorghum_constraint", "expr_lhs": "area['soybeans']", "sense": ">=", "expr_rhs": "0.5 * area['sorghum']", "description": "The area for soybeans should be at least half the area for sorghum."}, {"name": "wheat_sorghum_constraint", "expr_lhs": "area['wheat']", "sense": "==", "expr_rhs": "3 * area['sorghum']", "description": "The area for wheat must be three times the area for sorghum."}], "graph": null}, "eval": {"ground_truth_raw": "180000", "ground_truth_value": 180000.0, "obj_value": 180000.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_5", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 9.899958968162537e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 7.118945599999279, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 4.579999949783087e-05, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 1.800013706088066e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 6.0999998822808266e-05, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 7.98000255599618e-05, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.800013706088066e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0009100999450311065, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.002935199998319149, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.400010660290718e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 9.899958968162537e-06, "llm_call": 7.118945599999279, "json_extract": 4.579999949783087e-05, "meta_fill": 1.800013706088066e-06, "ir_parse": 6.0999998822808266e-05, "graph_build": 7.98000255599618e-05, "verifier": 1.800013706088066e-06, "solver_build": 0.0009100999450311065, "solver_optimize": 0.002935199998319149, "estimation": 1.400010660290718e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 1, "n_vars": 1, "n_constraints": 7}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 1600.0, "metrics": {"runtime_sec": 0.0010001659393310547, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_5", "source": "IndustryOR", "description": "Determine which children the Lee family should take on their trip to minimize the total cost while satisfying various constraints.", "sense": "min", "version": 1}, "sets": [{"name": "CHILDREN", "elements": ["Alice", "Bob", "Charlie", "Diana", "Ella"], "description": "The children in the Lee family."}], "params": [{"name": "cost", "indices": ["CHILDREN"], "values": {"Alice": 1000, "Bob": 900, "Charlie": 600, "Diana": 500, "Ella": 700}, "description": "The cost of taking each child."}], "vars": [{"name": "take", "indices": ["CHILDREN"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating whether each child is taken on the trip."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(cost[c] * take[c] for c in ['Alice', 'Bob', 'Charlie', 'Diana', 'Ella'])", "description": "Minimize the total cost of taking the children."}, "constraints": [{"name": "max_3_children", "expr_lhs": "sum(take[c] for c in ['Alice', 'Bob', 'Charlie', 'Diana', 'Ella'])", "sense": "<=", "expr_rhs": "3", "description": "The couple can take a maximum of 3 children."}, {"name": "take_bob", "expr_lhs": "take['Bob']", "sense": "==", "expr_rhs": "1", "description": "Bob must be taken on the trip."}, {"name": "alice_not_with_diana", "expr_lhs": "take['Alice'] + take['Diana']", "sense": "<=", "expr_rhs": "1", "description": "If Alice is taken, Diana cannot be taken and vice versa."}, {"name": "bob_not_with_charlie", "expr_lhs": "take['Bob'] + take['Charlie']", "sense": "<=", "expr_rhs": "1", "description": "If Bob is taken, Charlie cannot be taken and vice versa."}, {"name": "charlie_with_diana", "expr_lhs": "take['Charlie']", "sense": "<=", "expr_rhs": "take['Diana']", "description": "If Charlie is taken, Diana must also be taken."}, {"name": "diana_with_ella", "expr_lhs": "take['Diana']", "sense": "<=", "expr_rhs": "take['Ella']", "description": "If Diana is taken, Ella must also be taken."}, {"name": "at_least_2_children", "expr_lhs": "sum(take[c] for c in ['Alice', 'Bob', 'Charlie', 'Diana', 'Ella'])", "sense": ">=", "expr_rhs": "2", "description": "The couple must take at least two children."}], "graph": null}, "eval": {"ground_truth_raw": "1600.0", "ground_truth_value": 1600.0, "obj_value": 1600.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_6", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 3.999914042651653e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 13.625354700023308, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00014450005255639553, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.299931555986404e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00017090002074837685, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00024949992075562477, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 3.8000289350748062e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.001170799951069057, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.0027336999773979187, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.200009137392044e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 3.999914042651653e-06, "llm_call": 13.625354700023308, "json_extract": 0.00014450005255639553, "meta_fill": 6.299931555986404e-06, "ir_parse": 0.00017090002074837685, "graph_build": 0.00024949992075562477, "verifier": 3.8000289350748062e-06, "solver_build": 0.001170799951069057, "solver_optimize": 0.0027336999773979187, "estimation": 1.200009137392044e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 3, "n_vars": 1, "n_constraints": 2}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 90000.0, "metrics": {"runtime_sec": 0.0, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_6", "source": "IndustryOR", "description": "The Zhang family decides which restaurants to purchase to maximize their annual income within a budget constraint.", "sense": "max", "version": 1}, "sets": [{"name": "RESTAURANTS", "elements": ["A", "B", "C", "D"], "description": "The set of restaurants available for purchase."}], "params": [{"name": "income", "indices": ["RESTAURANTS"], "values": {"A": 15000, "B": 40000, "C": 30000, "D": 50000}, "description": "Annual income of each restaurant."}, {"name": "cost", "indices": ["RESTAURANTS"], "values": {"A": 1.6, "B": 2.5, "C": 1.8, "D": 3.0}, "description": "Cost in millions to purchase each restaurant."}, {"name": "budget", "indices": [], "values": 6.0, "description": "Total investment budget in millions."}], "vars": [{"name": "purchase", "indices": ["RESTAURANTS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary decision variable indicating whether to purchase a restaurant."}], "objective": {"name": "max_total_income", "sense": "max", "expr": "sum(income[r] * purchase[r] for r in ['A', 'B', 'C', 'D'])", "description": "Maximize the total annual income from purchased restaurants."}, "constraints": [{"name": "budget_constraint", "expr_lhs": "sum(cost[r] * purchase[r] for r in ['A', 'B', 'C', 'D'])", "sense": "<=", "expr_rhs": "budget", "description": "Total cost of purchased restaurants must not exceed the budget."}, {"name": "mutual_exclusivity_AD", "expr_lhs": "purchase['A'] + purchase['D']", "sense": "<=", "expr_rhs": "1", "description": "If Restaurant D is purchased, Restaurant A cannot be purchased."}], "graph": null}, "eval": {"ground_truth_raw": "90000.0", "ground_truth_value": 90000.0, "obj_value": 90000.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_7", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 3.00002284348011e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 8.264762999955565, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0002050000475719571, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.799927748739719e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0002324000233784318, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0003469000803306699, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 3.8000289350748062e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.002565499977208674, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.017920799902640283, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.600012183189392e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 3.00002284348011e-06, "llm_call": 8.264762999955565, "json_extract": 0.0002050000475719571, "meta_fill": 5.799927748739719e-06, "ir_parse": 0.0002324000233784318, "graph_build": 0.0003469000803306699, "verifier": 3.8000289350748062e-06, "solver_build": 0.002565499977208674, "solver_optimize": 0.017920799902640283, "estimation": 1.600012183189392e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 2, "n_vars": 2, "n_constraints": 7}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 600.0, "metrics": {"runtime_sec": 0.015000104904174805, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_7", "source": "IndustryOR", "description": "Minimize total pollution from transporting goods using motorcycles, small trucks, and large trucks.", "sense": "min", "version": 1}, "sets": [{"name": "MODES", "elements": ["motorcycle", "small_truck", "large_truck"], "description": "Available modes of transportation."}], "params": [{"name": "pollution", "indices": ["MODES"], "values": {"motorcycle": 40, "small_truck": 70, "large_truck": 100}, "description": "Pollution units produced per trip for each mode."}, {"name": "capacity", "indices": ["MODES"], "values": {"motorcycle": 10, "small_truck": 20, "large_truck": 50}, "description": "Product units transported per trip for each mode."}], "vars": [{"name": "trips", "indices": ["MODES"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of trips for each mode."}, {"name": "use_mode", "indices": ["MODES"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a mode is used."}], "objective": {"name": "min_total_pollution", "sense": "min", "expr": "sum(pollution[m] * trips[m] for m in ['motorcycle', 'small_truck', 'large_truck'])", "description": "Minimize the total pollution from all trips."}, "constraints": [{"name": "mode_selection_limit", "expr_lhs": "sum(use_mode[m] for m in ['motorcycle', 'small_truck', 'large_truck'])", "sense": "<=", "expr_rhs": "2", "description": "The company can only choose two modes of transportation."}, {"name": "motorcycle_trip_limit", "expr_lhs": "trips['motorcycle']", "sense": "<=", "expr_rhs": "8", "description": "The number of motorcycle trips cannot exceed 8."}, {"name": "product_transport_requirement", "expr_lhs": "sum(capacity[m] * trips[m] for m in ['motorcycle', 'small_truck', 'large_truck'])", "sense": ">=", "expr_rhs": "300", "description": "The company needs to transport at least 300 units of products."}, {"name": "total_trip_limit", "expr_lhs": "sum(trips[m] for m in ['motorcycle', 'small_truck', 'large_truck'])", "sense": "<=", "expr_rhs": "20", "description": "The total number of trips must be less than or equal to 20."}, {"name": "mode_usage_link_motorcycle", "expr_lhs": "trips['motorcycle']", "sense": "<=", "expr_rhs": "8 * use_mode['motorcycle']", "description": "Linking trips and mode usage for motorcycles."}, {"name": "mode_usage_link_small_truck", "expr_lhs": "trips['small_truck']", "sense": "<=", "expr_rhs": "20 * use_mode['small_truck']", "description": "Linking trips and mode usage for small trucks."}, {"name": "mode_usage_link_large_truck", "expr_lhs": "trips['large_truck']", "sense": "<=", "expr_rhs": "20 * use_mode['large_truck']", "description": "Linking trips and mode usage for large trucks."}], "graph": null}, "eval": {"ground_truth_raw": "600", "ground_truth_value": 600.0, "obj_value": 600.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_8", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.00003045797348e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 7.436223899945617, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00015850004274398088, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.899928510189056e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00018360000103712082, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00028309994377195835, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.100031219422817e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.001988500007428229, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.006659999955445528, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.200009137392044e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.00003045797348e-06, "llm_call": 7.436223899945617, "json_extract": 0.00015850004274398088, "meta_fill": 5.899928510189056e-06, "ir_parse": 0.00018360000103712082, "graph_build": 0.00028309994377195835, "verifier": 4.100031219422817e-06, "solver_build": 0.001988500007428229, "solver_optimize": 0.006659999955445528, "estimation": 1.200009137392044e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 3, "n_vars": 1, "n_constraints": 4}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 9800.0, "metrics": {"runtime_sec": 0.006999969482421875, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_8", "source": "IndustryOR", "description": "Determine the optimal number of tables, chairs, and bookshelves to produce in order to maximize profit, considering manufacturing costs, selling prices, warehouse space, and market demand.", "sense": "max", "version": 1}, "sets": [{"name": "PRODUCTS", "elements": ["tables", "chairs", "bookshelves"], "description": "Types of furniture products produced by the factory."}], "params": [{"name": "selling_price", "indices": ["PRODUCTS"], "values": {"tables": 200, "chairs": 50, "bookshelves": 150}, "description": "Selling price for each product."}, {"name": "manufacturing_cost", "indices": ["PRODUCTS"], "values": {"tables": 120, "chairs": 20, "bookshelves": 90}, "description": "Manufacturing cost for each product."}, {"name": "space_required", "indices": ["PRODUCTS"], "values": {"tables": 5, "chairs": 2, "bookshelves": 3}, "description": "Warehouse space required for each product."}], "vars": [{"name": "x", "indices": ["PRODUCTS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of each product to produce."}], "objective": {"name": "max_total_profit", "sense": "max", "expr": "sum((selling_price[p] - manufacturing_cost[p]) * x[p] for p in PRODUCTS)", "description": "Maximize total profit from selling the products."}, "constraints": [{"name": "warehouse_space_limit", "expr_lhs": "sum(space_required[p] * x[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "500", "description": "Total warehouse space used cannot exceed 500 square meters."}, {"name": "min_tables", "expr_lhs": "x['tables']", "sense": ">=", "expr_rhs": "10", "description": "At least 10 tables must be produced."}, {"name": "min_bookshelves", "expr_lhs": "x['bookshelves']", "sense": ">=", "expr_rhs": "20", "description": "At least 20 bookshelves must be produced."}, {"name": "max_total_items", "expr_lhs": "sum(x[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "200", "description": "Total number of items produced cannot exceed 200."}], "graph": null}, "eval": {"ground_truth_raw": "9800.0", "ground_truth_value": 9800.0, "obj_value": 9800.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_9", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 3.600027412176132e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 8.71176810003817, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 5.0600036047399044e-05, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 1.9000144675374031e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 7.079995702952147e-05, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 9.430001955479383e-05, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.400010660290718e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0011904999846592546, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.011436800006777048, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.500011421740055e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 3.600027412176132e-06, "llm_call": 8.71176810003817, "json_extract": 5.0600036047399044e-05, "meta_fill": 1.9000144675374031e-06, "ir_parse": 7.079995702952147e-05, "graph_build": 9.430001955479383e-05, "verifier": 1.400010660290718e-06, "solver_build": 0.0011904999846592546, "solver_optimize": 0.011436800006777048, "estimation": 1.500011421740055e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 4, "n_vars": 1, "n_constraints": 5}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 38000.0, "metrics": {"runtime_sec": 0.01399993896484375, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_9", "source": "IndustryOR", "description": "Select candidates to minimize salary while meeting budget, skill, and experience constraints.", "sense": "min", "version": 1}, "sets": [{"name": "CANDIDATES", "elements": ["F", "G", "H", "I", "J"], "description": "Set of candidates available for hiring."}], "params": [{"name": "salary", "indices": ["CANDIDATES"], "values": {"F": 12000, "G": 15000, "H": 18000, "I": 5000, "J": 10000}, "description": "Salary requirements for each candidate."}, {"name": "skill_level", "indices": ["CANDIDATES"], "values": {"F": 2, "G": 3, "H": 4, "I": 1, "J": 2}, "description": "Skill level of each candidate."}, {"name": "experience", "indices": ["CANDIDATES"], "values": {"F": 1, "G": 2, "H": 2, "I": 5, "J": 4}, "description": "Project management experience in years for each candidate."}, {"name": "budget", "indices": [], "values": 40000, "description": "Total budget available for hiring."}], "vars": [{"name": "hire", "indices": ["CANDIDATES"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a candidate is hired."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(salary[c] * hire[c] for c in ['F', 'G', 'H', 'I', 'J'])", "description": "Minimize the total salary cost of hired candidates."}, "constraints": [{"name": "budget_constraint", "expr_lhs": "sum(salary[c] * hire[c] for c in ['F', 'G', 'H', 'I', 'J'])", "sense": "<=", "expr_rhs": "budget", "description": "Total salary must not exceed the budget."}, {"name": "max_employees_constraint", "expr_lhs": "sum(hire[c] for c in ['F', 'G', 'H', 'I', 'J'])", "sense": "<=", "expr_rhs": "4", "description": "A maximum of 4 candidates can be hired."}, {"name": "skill_level_constraint", "expr_lhs": "sum(skill_level[c] * hire[c] for c in ['F', 'G', 'H', 'I', 'J'])", "sense": ">=", "expr_rhs": "8", "description": "Total skill level of hired candidates must be at least 8."}, {"name": "experience_constraint", "expr_lhs": "sum(experience[c] * hire[c] for c in ['F', 'G', 'H', 'I', 'J'])", "sense": ">=", "expr_rhs": "8", "description": "Total project management experience must be at least 8 years."}, {"name": "mutual_exclusion_G_J", "expr_lhs": "hire['G'] + hire['J']", "sense": "<=", "expr_rhs": "1", "description": "At most one of candidates G and J can be hired."}], "graph": null}, "eval": {"ground_truth_raw": "38000", "ground_truth_value": 38000.0, "obj_value": 38000.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_10", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.400033503770828e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 9.75094039994292, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0001925000688061118, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.3999323174357414e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00022209994494915009, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00037370005156844854, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.400033503770828e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0021888999035581946, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.009133699932135642, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.400018274784088e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.400033503770828e-06, "llm_call": 9.75094039994292, "json_extract": 0.0001925000688061118, "meta_fill": 6.3999323174357414e-06, "ir_parse": 0.00022209994494915009, "graph_build": 0.00037370005156844854, "verifier": 4.400033503770828e-06, "solver_build": 0.0021888999035581946, "solver_optimize": 0.009133699932135642, "estimation": 2.400018274784088e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 4, "n_vars": 1, "n_constraints": 5}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 25000.0, "metrics": {"runtime_sec": 0.014000177383422852, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_10", "source": "IndustryOR", "description": "Determine the company's production plan to maximize profit for manufacturing three types of tabletop golf toys.", "sense": "max", "version": 1}, "sets": [{"name": "TOY_TYPES", "elements": ["advanced", "intermediate", "basic"], "description": "Types of tabletop golf toys."}], "params": [{"name": "labor_hours", "indices": ["TOY_TYPES"], "values": {"advanced": 17, "intermediate": 10, "basic": 2}, "description": "Labor hours required per unit for each toy type."}, {"name": "inspection_hours", "indices": ["TOY_TYPES"], "values": {"advanced": 8, "intermediate": 4, "basic": 2}, "description": "Inspection hours required per unit for each toy type."}, {"name": "profit", "indices": ["TOY_TYPES"], "values": {"advanced": 300, "intermediate": 200, "basic": 100}, "description": "Profit per unit for each toy type."}, {"name": "max_demand", "indices": ["TOY_TYPES"], "values": {"advanced": 50, "intermediate": 80, "basic": 150}, "description": "Maximum demand for each toy type."}], "vars": [{"name": "production", "indices": ["TOY_TYPES"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of units to produce for each toy type."}], "objective": {"name": "max_total_profit", "sense": "max", "expr": "sum(profit[t] * production[t] for t in ['advanced', 'intermediate', 'basic'])", "description": "Maximize total profit from producing the toys."}, "constraints": [{"name": "labor_hours_constraint", "expr_lhs": "sum(labor_hours[t] * production[t] for t in ['advanced', 'intermediate', 'basic'])", "sense": "<=", "expr_rhs": "1000", "description": "Total labor hours used cannot exceed available labor hours."}, {"name": "inspection_hours_constraint", "expr_lhs": "sum(inspection_hours[t] * production[t] for t in ['advanced', 'intermediate', 'basic'])", "sense": "<=", "expr_rhs": "500", "description": "Total inspection hours used cannot exceed available inspection hours."}, {"name": "demand_constraint_advanced", "expr_lhs": "production['advanced']", "sense": "<=", "expr_rhs": "max_demand['advanced']", "description": "Production of advanced type cannot exceed its demand."}, {"name": "demand_constraint_intermediate", "expr_lhs": "production['intermediate']", "sense": "<=", "expr_rhs": "max_demand['intermediate']", "description": "Production of intermediate type cannot exceed its demand."}, {"name": "demand_constraint_basic", "expr_lhs": "production['basic']", "sense": "<=", "expr_rhs": "max_demand['basic']", "description": "Production of basic type cannot exceed its demand."}], "graph": null}, "eval": {"ground_truth_raw": "25000", "ground_truth_value": 25000.0, "obj_value": 25000.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_11", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 6.3999323174357414e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 8.159545100061223, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00021630001720041037, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.200047209858894e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0001957999775186181, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00030759989749640226, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 3.8000289350748062e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.002423599944449961, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.004633500007912517, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.100008375942707e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 6.3999323174357414e-06, "llm_call": 8.159545100061223, "json_extract": 0.00021630001720041037, "meta_fill": 6.200047209858894e-06, "ir_parse": 0.0001957999775186181, "graph_build": 0.00030759989749640226, "verifier": 3.8000289350748062e-06, "solver_build": 0.002423599944449961, "solver_optimize": 0.004633500007912517, "estimation": 1.100008375942707e-06}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 1, "n_vars": 1, "n_constraints": 6}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 53.0, "metrics": {"runtime_sec": 0.0, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_11", "source": "IndustryOR", "description": "Determine the minimum number of salespersons needed to meet the staffing requirements of a 24-hour convenience store.", "sense": "min", "version": 1}, "sets": [{"name": "TIME_PERIODS", "elements": ["2:00-6:00", "6:00-10:00", "10:00-14:00", "14:00-18:00", "18:00-22:00", "22:00-2:00"], "description": "Time periods during which staffing requirements are specified."}, {"name": "START_TIMES", "elements": ["2:00", "6:00", "10:00", "14:00", "18:00", "22:00"], "description": "Start times for shifts, each lasting 8 hours."}], "params": [{"name": "requirements", "indices": ["TIME_PERIODS"], "values": {"2:00-6:00": 10, "6:00-10:00": 15, "10:00-14:00": 25, "14:00-18:00": 20, "18:00-22:00": 18, "22:00-2:00": 12}, "description": "Number of salespersons required during each time period."}], "vars": [{"name": "x", "indices": ["START_TIMES"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of salespersons starting their shift at each start time."}], "objective": {"name": "min_total_salespersons", "sense": "min", "expr": "sum(x[start] for start in ['2:00', '6:00', '10:00', '14:00', '18:00', '22:00'])", "description": "Minimize the total number of salespersons."}, "constraints": [{"name": "requirement_2:00-6:00", "expr_lhs": "x['2:00'] + x['22:00']", "sense": ">=", "expr_rhs": "requirements['2:00-6:00']", "description": "Ensure enough salespersons are working during 2:00-6:00."}, {"name": "requirement_6:00-10:00", "expr_lhs": "x['6:00'] + x['2:00']", "sense": ">=", "expr_rhs": "requirements['6:00-10:00']", "description": "Ensure enough salespersons are working during 6:00-10:00."}, {"name": "requirement_10:00-14:00", "expr_lhs": "x['10:00'] + x['6:00']", "sense": ">=", "expr_rhs": "requirements['10:00-14:00']", "description": "Ensure enough salespersons are working during 10:00-14:00."}, {"name": "requirement_14:00-18:00", "expr_lhs": "x['14:00'] + x['10:00']", "sense": ">=", "expr_rhs": "requirements['14:00-18:00']", "description": "Ensure enough salespersons are working during 14:00-18:00."}, {"name": "requirement_18:00-22:00", "expr_lhs": "x['18:00'] + x['14:00']", "sense": ">=", "expr_rhs": "requirements['18:00-22:00']", "description": "Ensure enough salespersons are working during 18:00-22:00."}, {"name": "requirement_22:00-2:00", "expr_lhs": "x['22:00'] + x['18:00']", "sense": ">=", "expr_rhs": "requirements['22:00-2:00']", "description": "Ensure enough salespersons are working during 22:00-2:00."}], "graph": null}, "eval": {"ground_truth_raw": "53", "ground_truth_value": 53.0, "obj_value": 53.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_12", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 3.999914042651653e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 12.895259600016288, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.000296599930152297, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.199930794537067e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00034190004225820303, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0006262999959290028, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.400033503770828e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0014122000429779291, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.011279800091870129, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.500011421740055e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 3.999914042651653e-06, "llm_call": 12.895259600016288, "json_extract": 0.000296599930152297, "meta_fill": 6.199930794537067e-06, "ir_parse": 0.00034190004225820303, "graph_build": 0.0006262999959290028, "verifier": 4.400033503770828e-06, "solver_build": 0.0014122000429779291, "solver_optimize": 0.011279800091870129, "estimation": 1.500011421740055e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 6, "n_vars": 3, "n_constraints": 13}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 4700.0, "metrics": {"runtime_sec": 0.015000104904174805, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_12", "source": "IndustryOR", "description": "Maximize the annual profit of a wood storage and transportation company considering buying, selling, and storage costs.", "sense": "max", "version": 1}, "sets": [{"name": "QUARTERS", "elements": ["Winter", "Spring", "Summer", "Autumn"], "description": "The four quarters of the year."}], "params": [{"name": "buying_price", "indices": ["QUARTERS"], "values": {"Winter": 410, "Spring": 430, "Summer": 460, "Autumn": 450}, "description": "Buying price in 10,000 yuan per 10,000 m^3 for each quarter."}, {"name": "selling_price", "indices": ["QUARTERS"], "values": {"Winter": 425, "Spring": 440, "Summer": 465, "Autumn": 455}, "description": "Selling price in 10,000 yuan per 10,000 m^3 for each quarter."}, {"name": "max_sales_volume", "indices": ["QUARTERS"], "values": {"Winter": 100, "Spring": 140, "Summer": 200, "Autumn": 160}, "description": "Projected maximum sales volume in 10,000 m^3 for each quarter."}, {"name": "storage_cost_a", "indices": [], "values": 70, "description": "Fixed part of the storage cost per m^3."}, {"name": "storage_cost_b", "indices": [], "values": 100, "description": "Variable part of the storage cost per m^3 per quarter."}, {"name": "max_storage_capacity", "indices": [], "values": 200000, "description": "Maximum storage capacity in m^3."}], "vars": [{"name": "purchase", "indices": ["QUARTERS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Amount of wood purchased in 10,000 m^3 for each quarter."}, {"name": "sell", "indices": ["QUARTERS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Amount of wood sold in 10,000 m^3 for each quarter."}, {"name": "inventory", "indices": ["QUARTERS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Amount of wood in inventory in 10,000 m^3 at the end of each quarter."}], "objective": {"name": "max_annual_profit", "sense": "max", "expr": "sum((selling_price[q] * sell[q] - buying_price[q] * purchase[q] - (storage_cost_a + storage_cost_b * (i+1)) * inventory[q]) for i, q in enumerate(['Winter', 'Spring', 'Summer', 'Autumn']))", "description": "Maximize the annual profit considering buying, selling, and storage costs."}, "constraints": [{"name": "inventory_balance_Winter", "expr_lhs": "inventory['Winter']", "sense": "==", "expr_rhs": "purchase['Winter'] - sell['Winter']", "description": "Inventory balance for Winter."}, {"name": "inventory_balance_Spring", "expr_lhs": "inventory['Spring']", "sense": "==", "expr_rhs": "inventory['Winter'] + purchase['Spring'] - sell['Spring']", "description": "Inventory balance for Spring."}, {"name": "inventory_balance_Summer", "expr_lhs": "inventory['Summer']", "sense": "==", "expr_rhs": "inventory['Spring'] + purchase['Summer'] - sell['Summer']", "description": "Inventory balance for Summer."}, {"name": "inventory_balance_Autumn", "expr_lhs": "inventory['Autumn']", "sense": "==", "expr_rhs": "inventory['Summer'] + purchase['Autumn'] - sell['Autumn']", "description": "Inventory balance for Autumn."}, {"name": "max_sales_Winter", "expr_lhs": "sell['Winter']", "sense": "<=", "expr_rhs": "max_sales_volume['Winter']", "description": "Sales limit for Winter."}, {"name": "max_sales_Spring", "expr_lhs": "sell['Spring']", "sense": "<=", "expr_rhs": "max_sales_volume['Spring']", "description": "Sales limit for Spring."}, {"name": "max_sales_Summer", "expr_lhs": "sell['Summer']", "sense": "<=", "expr_rhs": "max_sales_volume['Summer']", "description": "Sales limit for Summer."}, {"name": "max_sales_Autumn", "expr_lhs": "sell['Autumn']", "sense": "<=", "expr_rhs": "max_sales_volume['Autumn']", "description": "Sales limit for Autumn."}, {"name": "max_storage_Winter", "expr_lhs": "inventory['Winter']", "sense": "<=", "expr_rhs": "max_storage_capacity / 10000", "description": "Storage capacity limit for Winter."}, {"name": "max_storage_Spring", "expr_lhs": "inventory['Spring']", "sense": "<=", "expr_rhs": "max_storage_capacity / 10000", "description": "Storage capacity limit for Spring."}, {"name": "max_storage_Summer", "expr_lhs": "inventory['Summer']", "sense": "<=", "expr_rhs": "max_storage_capacity / 10000", "description": "Storage capacity limit for Summer."}, {"name": "max_storage_Autumn", "expr_lhs": "inventory['Autumn']", "sense": "<=", "expr_rhs": "max_storage_capacity / 10000", "description": "Storage capacity limit for Autumn."}, {"name": "end_of_year_inventory", "expr_lhs": "inventory['Autumn']", "sense": "==", "expr_rhs": "0", "description": "All inventory must be sold by the end of Autumn."}], "graph": null}, "eval": {"ground_truth_raw": "4700", "ground_truth_value": 4700.0, "obj_value": 4700.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_13", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.700035788118839e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 10.76988379994873, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 6.530003156512976e-05, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 1.9000144675374031e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 7.82000133767724e-05, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00011979998089373112, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.500011421740055e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0010734000243246555, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.0024482000153511763, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 9.998911991715431e-07, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.700035788118839e-06, "llm_call": 10.76988379994873, "json_extract": 6.530003156512976e-05, "meta_fill": 1.9000144675374031e-06, "ir_parse": 7.82000133767724e-05, "graph_build": 0.00011979998089373112, "verifier": 1.500011421740055e-06, "solver_build": 0.0010734000243246555, "solver_optimize": 0.0024482000153511763, "estimation": 9.998911991715431e-07}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 1, "n_vars": 1, "n_constraints": 12}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 3.0, "metrics": {"runtime_sec": 0.0, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_13", "source": "IndustryOR", "description": "Determine the minimum number of chain stores to be built in a new residential area such that the distance from any residential area to one of the chain stores does not exceed 800 meters.", "sense": "min", "version": 1}, "sets": [{"name": "AREAS", "elements": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"], "description": "Areas in the new residential region."}], "params": [{"name": "coverage", "indices": ["AREAS"], "values": {"A": ["A", "C", "E", "G", "H", "I"], "B": ["B", "H", "I"], "C": ["A", "C", "G", "H", "I"], "D": ["D", "J"], "E": ["A", "E", "G"], "F": ["F", "J", "K"], "G": ["A", "C", "E", "G"], "H": ["A", "B", "C", "H", "I"], "I": ["A", "B", "C", "H", "I"], "J": ["D", "F", "J", "K", "L"], "K": ["F", "J", "K", "L"], "L": ["J", "K", "L"]}, "description": "Areas within 800 meters radius of each area."}], "vars": [{"name": "y", "indices": ["AREAS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a store is built in a given area."}], "objective": {"name": "min_total_stores", "sense": "min", "expr": "sum(y[a] for a in AREAS)", "description": "Minimize the total number of chain stores to be built."}, "constraints": [{"name": "coverage_constraint_A", "expr_lhs": "y['A'] + y['C'] + y['E'] + y['G'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area A is covered by at least one store."}, {"name": "coverage_constraint_B", "expr_lhs": "y['B'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area B is covered by at least one store."}, {"name": "coverage_constraint_C", "expr_lhs": "y['A'] + y['C'] + y['G'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area C is covered by at least one store."}, {"name": "coverage_constraint_D", "expr_lhs": "y['D'] + y['J']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area D is covered by at least one store."}, {"name": "coverage_constraint_E", "expr_lhs": "y['A'] + y['E'] + y['G']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area E is covered by at least one store."}, {"name": "coverage_constraint_F", "expr_lhs": "y['F'] + y['J'] + y['K']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area F is covered by at least one store."}, {"name": "coverage_constraint_G", "expr_lhs": "y['A'] + y['C'] + y['E'] + y['G']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area G is covered by at least one store."}, {"name": "coverage_constraint_H", "expr_lhs": "y['A'] + y['B'] + y['C'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area H is covered by at least one store."}, {"name": "coverage_constraint_I", "expr_lhs": "y['A'] + y['B'] + y['C'] + y['H'] + y['I']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area I is covered by at least one store."}, {"name": "coverage_constraint_J", "expr_lhs": "y['D'] + y['F'] + y['J'] + y['K'] + y['L']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area J is covered by at least one store."}, {"name": "coverage_constraint_K", "expr_lhs": "y['F'] + y['J'] + y['K'] + y['L']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area K is covered by at least one store."}, {"name": "coverage_constraint_L", "expr_lhs": "y['J'] + y['K'] + y['L']", "sense": ">=", "expr_rhs": "1", "description": "Ensure area L is covered by at least one store."}], "graph": null}, "eval": {"ground_truth_raw": "3", "ground_truth_value": 3.0, "obj_value": 3.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_14", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 3.900029696524143e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 7.99453199992422, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00016659998800605536, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.799927748739719e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00019829999655485153, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0003383000148460269, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.400033503770828e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0027435999363660812, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.017376899952068925, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.800013706088066e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 3.900029696524143e-06, "llm_call": 7.99453199992422, "json_extract": 0.00016659998800605536, "meta_fill": 5.799927748739719e-06, "ir_parse": 0.00019829999655485153, "graph_build": 0.0003383000148460269, "verifier": 4.400033503770828e-06, "solver_build": 0.0027435999363660812, "solver_optimize": 0.017376899952068925, "estimation": 1.800013706088066e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 3, "n_vars": 2, "n_constraints": 5}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 37000.0, "metrics": {"runtime_sec": 0.017000198364257812, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_14", "source": "IndustryOR", "description": "Minimize the total cost of producing 2000 units of a product using one of four devices with known setup and production costs and capacities.", "sense": "min", "version": 1}, "sets": [{"name": "DEVICES", "elements": ["A", "B", "C", "D"], "description": "The devices available for processing the product."}], "params": [{"name": "setup_cost", "indices": ["DEVICES"], "values": {"A": 1000, "B": 920, "C": 800, "D": 700}, "description": "Setup completion cost for each device when activated."}, {"name": "production_cost", "indices": ["DEVICES"], "values": {"A": 20, "B": 24, "C": 16, "D": 28}, "description": "Production cost per unit for each device."}, {"name": "max_capacity", "indices": ["DEVICES"], "values": {"A": 900, "B": 1000, "C": 1200, "D": 1600}, "description": "Maximum processing capacity for each device."}], "vars": [{"name": "y", "indices": ["DEVICES"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a device is activated."}, {"name": "x", "indices": ["DEVICES"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of units processed by each device."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(setup_cost[d] * y[d] + production_cost[d] * x[d] for d in DEVICES)", "description": "Minimize the total cost of setup and production across all devices."}, "constraints": [{"name": "demand_fulfillment", "expr_lhs": "sum(x[d] for d in DEVICES)", "sense": "==", "expr_rhs": "2000", "description": "Ensure that the total production meets the demand of 2000 units."}, {"name": "capacity_constraint_A", "expr_lhs": "x['A']", "sense": "<=", "expr_rhs": "max_capacity['A'] * y['A']", "description": "Production on device A cannot exceed its capacity if activated."}, {"name": "capacity_constraint_B", "expr_lhs": "x['B']", "sense": "<=", "expr_rhs": "max_capacity['B'] * y['B']", "description": "Production on device B cannot exceed its capacity if activated."}, {"name": "capacity_constraint_C", "expr_lhs": "x['C']", "sense": "<=", "expr_rhs": "max_capacity['C'] * y['C']", "description": "Production on device C cannot exceed its capacity if activated."}, {"name": "capacity_constraint_D", "expr_lhs": "x['D']", "sense": "<=", "expr_rhs": "max_capacity['D'] * y['D']", "description": "Production on device D cannot exceed its capacity if activated."}], "graph": null}, "eval": {"ground_truth_raw": "37000", "ground_truth_value": 37000.0, "obj_value": 37000.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_15", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.500034265220165e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 10.891390000004321, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0002500000409781933, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.4999330788850784e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00023210002109408379, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00025050004478543997, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.600012183189392e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0009442999726161361, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.0033987000351771712, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.200009137392044e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.500034265220165e-06, "llm_call": 10.891390000004321, "json_extract": 0.0002500000409781933, "meta_fill": 6.4999330788850784e-06, "ir_parse": 0.00023210002109408379, "graph_build": 0.00025050004478543997, "verifier": 1.600012183189392e-06, "solver_build": 0.0009442999726161361, "solver_optimize": 0.0033987000351771712, "estimation": 1.200009137392044e-06}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 3, "n_vars": 1, "n_constraints": 7}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 4.0, "metrics": {"runtime_sec": 0.004999876022338867, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_15", "source": "IndustryOR", "description": "Determine the minimum number of courses a master's student should take to meet the category and prerequisite requirements.", "sense": "min", "version": 1}, "sets": [{"name": "COURSES", "elements": ["calculus", "operations_research", "data_structures", "management_statistics", "computer_simulation", "computer_programming", "forecasting"], "description": "List of available courses."}, {"name": "CATEGORIES", "elements": ["math", "operations_research", "computer"], "description": "List of course categories."}], "params": [{"name": "category_requirements", "indices": ["CATEGORIES"], "values": {"math": 2, "operations_research": 2, "computer": 2}, "description": "Number of courses required in each category."}, {"name": "course_categories", "indices": ["COURSES", "CATEGORIES"], "values": {"calculus": {"math": 1, "operations_research": 0, "computer": 0}, "operations_research": {"math": 1, "operations_research": 1, "computer": 0}, "data_structures": {"math": 1, "operations_research": 0, "computer": 1}, "management_statistics": {"math": 1, "operations_research": 1, "computer": 0}, "computer_simulation": {"math": 0, "operations_research": 1, "computer": 1}, "computer_programming": {"math": 0, "operations_research": 0, "computer": 1}, "forecasting": {"math": 1, "operations_research": 1, "computer": 0}}, "description": "Mapping of courses to categories."}, {"name": "prerequisites", "indices": ["COURSES", "COURSES"], "values": {"computer_simulation": {"computer_programming": 1}, "data_structures": {"computer_programming": 1}, "management_statistics": {"calculus": 1}, "forecasting": {"management_statistics": 1}}, "description": "Prerequisite relationships between courses."}], "vars": [{"name": "x", "indices": ["COURSES"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a course is taken."}], "objective": {"name": "min_total_courses", "sense": "min", "expr": "sum(x[c] for c in COURSES)", "description": "Minimize the total number of courses taken."}, "constraints": [{"name": "math_requirement", "expr_lhs": "sum(x[c] * course_categories[c]['math'] for c in COURSES)", "sense": ">=", "expr_rhs": "category_requirements['math']", "description": "Ensure at least 2 math courses are taken."}, {"name": "operations_research_requirement", "expr_lhs": "sum(x[c] * course_categories[c]['operations_research'] for c in COURSES)", "sense": ">=", "expr_rhs": "category_requirements['operations_research']", "description": "Ensure at least 2 operations research courses are taken."}, {"name": "computer_requirement", "expr_lhs": "sum(x[c] * course_categories[c]['computer'] for c in COURSES)", "sense": ">=", "expr_rhs": "category_requirements['computer']", "description": "Ensure at least 2 computer courses are taken."}, {"name": "prerequisite_computer_simulation", "expr_lhs": "x['computer_simulation']", "sense": "<=", "expr_rhs": "x['computer_programming']", "description": "Computer simulation requires computer programming."}, {"name": "prerequisite_data_structures", "expr_lhs": "x['data_structures']", "sense": "<=", "expr_rhs": "x['computer_programming']", "description": "Data structures requires computer programming."}, {"name": "prerequisite_management_statistics", "expr_lhs": "x['management_statistics']", "sense": "<=", "expr_rhs": "x['calculus']", "description": "Management statistics requires calculus."}, {"name": "prerequisite_forecasting", "expr_lhs": "x['forecasting']", "sense": "<=", "expr_rhs": "x['management_statistics']", "description": "Forecasting requires management statistics."}], "graph": null}, "eval": {"ground_truth_raw": "4", "ground_truth_value": 4.0, "obj_value": 4.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_16", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 3.100023604929447e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 14.287102300091647, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00027630000840872526, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.999929271638393e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00030750001315027475, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0005920999683439732, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.299916326999664e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0030525000765919685, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.01592729997355491, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.00001522898674e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 3.100023604929447e-06, "llm_call": 14.287102300091647, "json_extract": 0.00027630000840872526, "meta_fill": 5.999929271638393e-06, "ir_parse": 0.00030750001315027475, "graph_build": 0.0005920999683439732, "verifier": 4.299916326999664e-06, "solver_build": 0.0030525000765919685, "solver_optimize": 0.01592729997355491, "estimation": 2.00001522898674e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 4, "n_vars": 2, "n_constraints": 12}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 19300.0, "metrics": {"runtime_sec": 0.018000125885009766, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_16", "source": "IndustryOR", "description": "Optimize the production of plastic containers to minimize total cost while meeting demand.", "sense": "min", "version": 1}, "sets": [{"name": "CONTAINERS", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Types of plastic containers"}], "params": [{"name": "capacity", "indices": ["CONTAINERS"], "values": {"1": 1500, "2": 2500, "3": 4000, "4": 6000, "5": 9000, "6": 12000}, "description": "Capacity of each container type in cm^3"}, {"name": "demand", "indices": ["CONTAINERS"], "values": {"1": 500, "2": 550, "3": 700, "4": 900, "5": 400, "6": 300}, "description": "Demand for each container type in units"}, {"name": "variable_cost", "indices": ["CONTAINERS"], "values": {"1": 5, "2": 8, "3": 10, "4": 12, "5": 16, "6": 18}, "description": "Variable cost per unit for each container type in "}, {"name": "fixed_cost", "indices": [], "values": 1200, "description": "Fixed cost for using equipment for each container type in "}], "vars": [{"name": "produce", "indices": ["CONTAINERS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of units to produce for each container type"}, {"name": "use_equipment", "indices": ["CONTAINERS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if equipment is used for each container type"}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(variable_cost[c] * produce[c] + fixed_cost * use_equipment[c] for c in ['1', '2', '3', '4', '5', '6'])", "description": "Minimize the total cost of production including variable and fixed costs"}, "constraints": [{"name": "demand_satisfaction_1", "expr_lhs": "produce['1']", "sense": ">=", "expr_rhs": "demand['1']", "description": "Meet demand for container type 1"}, {"name": "demand_satisfaction_2", "expr_lhs": "produce['2'] + produce['3'] + produce['4'] + produce['5'] + produce['6']", "sense": ">=", "expr_rhs": "demand['2']", "description": "Meet demand for container type 2, allowing substitution"}, {"name": "demand_satisfaction_3", "expr_lhs": "produce['3'] + produce['4'] + produce['5'] + produce['6']", "sense": ">=", "expr_rhs": "demand['3']", "description": "Meet demand for container type 3, allowing substitution"}, {"name": "demand_satisfaction_4", "expr_lhs": "produce['4'] + produce['5'] + produce['6']", "sense": ">=", "expr_rhs": "demand['4']", "description": "Meet demand for container type 4, allowing substitution"}, {"name": "demand_satisfaction_5", "expr_lhs": "produce['5'] + produce['6']", "sense": ">=", "expr_rhs": "demand['5']", "description": "Meet demand for container type 5, allowing substitution"}, {"name": "demand_satisfaction_6", "expr_lhs": "produce['6']", "sense": ">=", "expr_rhs": "demand['6']", "description": "Meet demand for container type 6"}, {"name": "equipment_usage_1", "expr_lhs": "produce['1']", "sense": "<=", "expr_rhs": "use_equipment['1'] * 1000000", "description": "Link equipment usage to production for container type 1"}, {"name": "equipment_usage_2", "expr_lhs": "produce['2']", "sense": "<=", "expr_rhs": "use_equipment['2'] * 1000000", "description": "Link equipment usage to production for container type 2"}, {"name": "equipment_usage_3", "expr_lhs": "produce['3']", "sense": "<=", "expr_rhs": "use_equipment['3'] * 1000000", "description": "Link equipment usage to production for container type 3"}, {"name": "equipment_usage_4", "expr_lhs": "produce['4']", "sense": "<=", "expr_rhs": "use_equipment['4'] * 1000000", "description": "Link equipment usage to production for container type 4"}, {"name": "equipment_usage_5", "expr_lhs": "produce['5']", "sense": "<=", "expr_rhs": "use_equipment['5'] * 1000000", "description": "Link equipment usage to production for container type 5"}, {"name": "equipment_usage_6", "expr_lhs": "produce['6']", "sense": "<=", "expr_rhs": "use_equipment['6'] * 1000000", "description": "Link equipment usage to production for container type 6"}], "graph": null}, "eval": {"ground_truth_raw": "43700", "ground_truth_value": 43700.0, "obj_value": 19300.0, "gurobi_status_name": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_17", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.800036549568176e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 10.17219940002542, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 4.579999949783087e-05, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 1.700012944638729e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 5.7699973694980145e-05, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 8.619995787739754e-05, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.500011421740055e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0007871000561863184, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.004137600073590875, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.1000043489038944e-05, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.800036549568176e-06, "llm_call": 10.17219940002542, "json_extract": 4.579999949783087e-05, "meta_fill": 1.700012944638729e-06, "ir_parse": 5.7699973694980145e-05, "graph_build": 8.619995787739754e-05, "verifier": 1.500011421740055e-06, "solver_build": 0.0007871000561863184, "solver_optimize": 0.004137600073590875, "estimation": 2.1000043489038944e-05}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 3, "n_vars": 1, "n_constraints": 3}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 6800.0, "metrics": {"runtime_sec": 0.0, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_17", "source": "IndustryOR", "description": "Determine the number of trucks to send to warehouses A and B to meet material requirements at minimum cost.", "sense": "min", "version": 1}, "sets": [{"name": "WAREHOUSES", "elements": ["A", "B"], "description": "Warehouses from which materials are transported."}, {"name": "MATERIALS", "elements": ["A", "B", "C"], "description": "Types of materials required for production."}], "params": [{"name": "transport_capacity", "indices": ["WAREHOUSES", "MATERIALS"], "values": {"A": {"A": 4, "B": 2, "C": 6}, "B": {"A": 7, "B": 2, "C": 2}}, "description": "Transport capacity of each truck from each warehouse for each material."}, {"name": "freight_cost", "indices": ["WAREHOUSES"], "values": {"A": 200, "B": 160}, "description": "Freight cost per truck from each warehouse."}, {"name": "required_amount", "indices": ["MATERIALS"], "values": {"A": 240, "B": 80, "C": 120}, "description": "Required amount of each material for production."}], "vars": [{"name": "trucks", "indices": ["WAREHOUSES"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of trucks to send from each warehouse."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(freight_cost[w] * trucks[w] for w in ['A', 'B'])", "description": "Minimize the total freight cost of sending trucks from warehouses A and B."}, "constraints": [{"name": "material_A_requirement", "expr_lhs": "sum(transport_capacity[w]['A'] * trucks[w] for w in ['A', 'B'])", "sense": ">=", "expr_rhs": "required_amount['A']", "description": "Ensure at least the required amount of material A is transported."}, {"name": "material_B_requirement", "expr_lhs": "sum(transport_capacity[w]['B'] * trucks[w] for w in ['A', 'B'])", "sense": ">=", "expr_rhs": "required_amount['B']", "description": "Ensure at least the required amount of material B is transported."}, {"name": "material_C_requirement", "expr_lhs": "sum(transport_capacity[w]['C'] * trucks[w] for w in ['A', 'B'])", "sense": ">=", "expr_rhs": "required_amount['C']", "description": "Ensure at least the required amount of material C is transported."}], "graph": null}, "eval": {"ground_truth_raw": "6800", "ground_truth_value": 6800.0, "obj_value": 6800.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_18", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.200031980872154e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 7.715121999965049, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00015249999705702066, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.900044925510883e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0001881999196484685, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00029230001382529736, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 5.299923941493034e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0020982000278308988, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.007398100104182959, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.600019797682762e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.200031980872154e-06, "llm_call": 7.715121999965049, "json_extract": 0.00015249999705702066, "meta_fill": 5.900044925510883e-06, "ir_parse": 0.0001881999196484685, "graph_build": 0.00029230001382529736, "verifier": 5.299923941493034e-06, "solver_build": 0.0020982000278308988, "solver_optimize": 0.007398100104182959, "estimation": 2.600019797682762e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 1, "n_vars": 1, "n_constraints": 6}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 150.0, "metrics": {"runtime_sec": 0.007999897003173828, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_18", "source": "IndustryOR", "description": "Determine the minimum number of drivers and crew members required for a bus route with specific time period requirements.", "sense": "min", "version": 1}, "sets": [{"name": "SHIFTS", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Time periods for the bus route."}], "params": [{"name": "required", "indices": ["SHIFTS"], "values": {"1": 60, "2": 70, "3": 60, "4": 50, "5": 20, "6": 30}, "description": "Number of drivers and crew members required for each shift."}], "vars": [{"name": "x", "indices": ["SHIFTS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of drivers and crew members starting at each shift."}], "objective": {"name": "min_total_staff", "sense": "min", "expr": "sum(x[s] for s in ['1', '2', '3', '4', '5', '6'])", "description": "Minimize the total number of drivers and crew members."}, "constraints": [{"name": "shift_1_requirement", "expr_lhs": "x['1'] + x['6']", "sense": ">=", "expr_rhs": "required['1']", "description": "Meet the requirement for shift 1."}, {"name": "shift_2_requirement", "expr_lhs": "x['1'] + x['2']", "sense": ">=", "expr_rhs": "required['2']", "description": "Meet the requirement for shift 2."}, {"name": "shift_3_requirement", "expr_lhs": "x['2'] + x['3']", "sense": ">=", "expr_rhs": "required['3']", "description": "Meet the requirement for shift 3."}, {"name": "shift_4_requirement", "expr_lhs": "x['3'] + x['4']", "sense": ">=", "expr_rhs": "required['4']", "description": "Meet the requirement for shift 4."}, {"name": "shift_5_requirement", "expr_lhs": "x['4'] + x['5']", "sense": ">=", "expr_rhs": "required['5']", "description": "Meet the requirement for shift 5."}, {"name": "shift_6_requirement", "expr_lhs": "x['5'] + x['6']", "sense": ">=", "expr_rhs": "required['6']", "description": "Meet the requirement for shift 6."}], "graph": null}, "eval": {"ground_truth_raw": "150", "ground_truth_value": 150.0, "obj_value": 150.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_19", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.400033503770828e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 10.040655799908563, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0001786999637261033, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.799927748739719e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0002142000012099743, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00032819993793964386, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 5.900044925510883e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.002088000066578388, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.013283299980685115, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.200016751885414e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.400033503770828e-06, "llm_call": 10.040655799908563, "json_extract": 0.0001786999637261033, "meta_fill": 5.799927748739719e-06, "ir_parse": 0.0002142000012099743, "graph_build": 0.00032819993793964386, "verifier": 5.900044925510883e-06, "solver_build": 0.002088000066578388, "solver_optimize": 0.013283299980685115, "estimation": 2.200016751885414e-06}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 3, "n_vars": 1, "n_constraints": 5}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 1030.0, "metrics": {"runtime_sec": 0.018000125885009766, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_19", "source": "IndustryOR", "description": "Optimize coal distribution from two mines to three residential areas to minimize transportation ton-kilometers.", "sense": "min", "version": 1}, "sets": [{"name": "MINES", "elements": ["A", "B"], "description": "Coal mines"}, {"name": "AREAS", "elements": ["1", "2", "3"], "description": "Residential areas"}], "params": [{"name": "supply", "indices": ["MINES"], "values": {"A": 80, "B": 100}, "description": "Monthly coal supply from each mine in tons"}, {"name": "demand", "indices": ["AREAS"], "values": {"1": 55, "2": 75, "3": 50}, "description": "Monthly coal demand for each residential area in tons"}, {"name": "distance", "indices": ["MINES", "AREAS"], "values": {"A": {"1": 10, "2": 5, "3": 6}, "B": {"1": 4, "2": 8, "3": 15}}, "description": "Distance in kilometers from each mine to each residential area"}], "vars": [{"name": "x", "indices": ["MINES", "AREAS"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Tons of coal transported from each mine to each residential area"}], "objective": {"name": "min_total_ton_kilometers", "sense": "min", "expr": "sum(x[m][a] * distance[m][a] for m in ['A', 'B'] for a in ['1', '2', '3'])", "description": "Minimize the total transportation ton-kilometers"}, "constraints": [{"name": "supply_constraint_A", "expr_lhs": "sum(x['A'][a] for a in ['1', '2', '3'])", "sense": "<=", "expr_rhs": "supply['A']", "description": "Supply constraint for mine A"}, {"name": "supply_constraint_B", "expr_lhs": "sum(x['B'][a] for a in ['1', '2', '3'])", "sense": "<=", "expr_rhs": "supply['B']", "description": "Supply constraint for mine B"}, {"name": "demand_constraint_1", "expr_lhs": "sum(x[m]['1'] for m in ['A', 'B'])", "sense": ">=", "expr_rhs": "demand['1']", "description": "Demand constraint for residential area 1"}, {"name": "demand_constraint_2", "expr_lhs": "sum(x[m]['2'] for m in ['A', 'B'])", "sense": ">=", "expr_rhs": "demand['2']", "description": "Demand constraint for residential area 2"}, {"name": "demand_constraint_3", "expr_lhs": "sum(x[m]['3'] for m in ['A', 'B'])", "sense": ">=", "expr_rhs": "demand['3']", "description": "Demand constraint for residential area 3"}], "graph": null}, "eval": {"ground_truth_raw": "1030", "ground_truth_value": 1030.0, "obj_value": 1030.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_20", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.499917849898338e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 11.099602000089362, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00019920000340789557, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.200047209858894e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0002601000014692545, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0004254999803379178, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.200031980872154e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0019910000264644623, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.014139099977910519, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.5998957678675652e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.499917849898338e-06, "llm_call": 11.099602000089362, "json_extract": 0.00019920000340789557, "meta_fill": 6.200047209858894e-06, "ir_parse": 0.0002601000014692545, "graph_build": 0.0004254999803379178, "verifier": 4.200031980872154e-06, "solver_build": 0.0019910000264644623, "solver_optimize": 0.014139099977910519, "estimation": 1.5998957678675652e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 8, "n_vars": 2, "n_constraints": 4}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 57.0, "metrics": {"runtime_sec": 0.01900005340576172, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_20", "source": "IndustryOR", "description": "Maximize profit from selling products A, B, and byproduct C considering production and disposal constraints.", "sense": "max", "version": 1}, "sets": [{"name": "PRODUCTS", "elements": ["A", "B"], "description": "Set of products."}], "params": [{"name": "front_process_time", "indices": ["PRODUCTS"], "values": {"A": 2, "B": 3}, "description": "Time required for the front process for each product."}, {"name": "back_process_time", "indices": ["PRODUCTS"], "values": {"A": 3, "B": 4}, "description": "Time required for the back process for each product."}, {"name": "front_process_capacity", "indices": [], "values": 16, "description": "Total available hours for the front process."}, {"name": "back_process_capacity", "indices": [], "values": 24, "description": "Total available hours for the back process."}, {"name": "profit", "indices": ["PRODUCTS"], "values": {"A": 4, "B": 10}, "description": "Profit from selling one unit of each product."}, {"name": "byproduct_profit", "indices": [], "values": 3, "description": "Profit from selling one unit of byproduct C."}, {"name": "disposal_cost", "indices": [], "values": 2, "description": "Cost of disposing one unit of byproduct C."}, {"name": "max_byproduct_sales", "indices": [], "values": 5, "description": "Maximum units of byproduct C that can be sold."}], "vars": [{"name": "x", "indices": ["PRODUCTS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of units produced for each product."}, {"name": "y", "indices": [], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of units of byproduct C sold."}], "objective": {"name": "max_total_profit", "sense": "max", "expr": "profit['A'] * x['A'] + profit['B'] * x['B'] + byproduct_profit * y - disposal_cost * (2 * x['B'] - y)", "description": "Maximize total profit from selling products A, B, and byproduct C, considering disposal costs."}, "constraints": [{"name": "front_process_capacity_constraint", "expr_lhs": "front_process_time['A'] * x['A'] + front_process_time['B'] * x['B']", "sense": "<=", "expr_rhs": "front_process_capacity", "description": "Total time used in the front process must not exceed available capacity."}, {"name": "back_process_capacity_constraint", "expr_lhs": "back_process_time['A'] * x['A'] + back_process_time['B'] * x['B']", "sense": "<=", "expr_rhs": "back_process_capacity", "description": "Total time used in the back process must not exceed available capacity."}, {"name": "byproduct_sales_limit", "expr_lhs": "y", "sense": "<=", "expr_rhs": "max_byproduct_sales", "description": "Units of byproduct C sold must not exceed the maximum sales limit."}, {"name": "byproduct_production_constraint", "expr_lhs": "y", "sense": "<=", "expr_rhs": "2 * x['B']", "description": "Units of byproduct C sold must not exceed the amount produced."}], "graph": null}, "eval": {"ground_truth_raw": "57", "ground_truth_value": 57.0, "obj_value": 57.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_21", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "solver_build", "stages": {"build_prompts": {"ok": true, "t_sec": 3.3999094739556313e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 13.126354200066999, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00026400003116577864, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.799927748739719e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00035039999056607485, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00015660002827644348, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.400010660290718e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": false, "t_sec": 0.010065199923701584, "error_type": "SyntaxError", "error_msg": "invalid syntax (<string>, line 1)", "traceback": "Traceback (most recent call last):\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_pipeline.py\", line 254, in run_gm4opt_pipeline\n    model = ir_to_gurobi(ir)\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_ir.py\", line 331, in ir_to_gurobi\n    obj_expr = eval(obj_def.expr, global_env, {})\n  File \"<string>\", line 1\n    sum(lambda[i] * (x[i] + y[i]) for i in CARS)\n              ^\nSyntaxError: invalid syntax\n"}}, "timings": {"build_prompts": 3.3999094739556313e-06, "llm_call": 13.126354200066999, "json_extract": 0.00026400003116577864, "meta_fill": 5.799927748739719e-06, "ir_parse": 0.00035039999056607485, "graph_build": 0.00015660002827644348, "verifier": 1.400010660290718e-06, "solver_build": 0.010065199923701584}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 1, "n_vars": 2, "n_constraints": 16}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": false, "build_error": "SyntaxError: invalid syntax (<string>, line 1)", "status": null, "status_name": "NONE", "obj_value": null, "metrics": {}}, "estimation": {"ok": false, "notes": "not run"}, "ir_dict": {"meta": {"problem_id": "industryOR_21", "source": "IndustryOR", "description": "Minimize the total length of the street occupied by cars parked on both sides, with a constraint on the maximum length on one side.", "sense": "min", "version": 1}, "sets": [{"name": "CARS", "elements": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"], "description": "Set of cars to be parked."}], "params": [{"name": "lambda", "indices": ["CARS"], "values": {"1": 4.0, "2": 4.5, "3": 5.0, "4": 4.1, "5": 2.4, "6": 5.2, "7": 3.7, "8": 3.5, "9": 3.2, "10": 4.5, "11": 2.3, "12": 3.3, "13": 3.8, "14": 4.6, "15": 3.0}, "description": "Length of each car in meters."}], "vars": [{"name": "x", "indices": ["CARS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if car i is parked on one side of the street."}, {"name": "y", "indices": ["CARS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if car i is parked on the other side of the street."}], "objective": {"name": "min_total_length", "sense": "min", "expr": "sum(lambda[i] * (x[i] + y[i]) for i in CARS)", "description": "Minimize the total length of the street occupied by cars."}, "constraints": [{"name": "one_side_length_limit", "expr_lhs": "sum(lambda[i] * x[i] for i in CARS)", "sense": "<=", "expr_rhs": "15.0", "description": "The total length of cars parked on one side cannot exceed 15 meters."}, {"name": "car_parked_once_1", "expr_lhs": "x['1'] + y['1']", "sense": "==", "expr_rhs": "1", "description": "Car 1 must be parked on exactly one side."}, {"name": "car_parked_once_2", "expr_lhs": "x['2'] + y['2']", "sense": "==", "expr_rhs": "1", "description": "Car 2 must be parked on exactly one side."}, {"name": "car_parked_once_3", "expr_lhs": "x['3'] + y['3']", "sense": "==", "expr_rhs": "1", "description": "Car 3 must be parked on exactly one side."}, {"name": "car_parked_once_4", "expr_lhs": "x['4'] + y['4']", "sense": "==", "expr_rhs": "1", "description": "Car 4 must be parked on exactly one side."}, {"name": "car_parked_once_5", "expr_lhs": "x['5'] + y['5']", "sense": "==", "expr_rhs": "1", "description": "Car 5 must be parked on exactly one side."}, {"name": "car_parked_once_6", "expr_lhs": "x['6'] + y['6']", "sense": "==", "expr_rhs": "1", "description": "Car 6 must be parked on exactly one side."}, {"name": "car_parked_once_7", "expr_lhs": "x['7'] + y['7']", "sense": "==", "expr_rhs": "1", "description": "Car 7 must be parked on exactly one side."}, {"name": "car_parked_once_8", "expr_lhs": "x['8'] + y['8']", "sense": "==", "expr_rhs": "1", "description": "Car 8 must be parked on exactly one side."}, {"name": "car_parked_once_9", "expr_lhs": "x['9'] + y['9']", "sense": "==", "expr_rhs": "1", "description": "Car 9 must be parked on exactly one side."}, {"name": "car_parked_once_10", "expr_lhs": "x['10'] + y['10']", "sense": "==", "expr_rhs": "1", "description": "Car 10 must be parked on exactly one side."}, {"name": "car_parked_once_11", "expr_lhs": "x['11'] + y['11']", "sense": "==", "expr_rhs": "1", "description": "Car 11 must be parked on exactly one side."}, {"name": "car_parked_once_12", "expr_lhs": "x['12'] + y['12']", "sense": "==", "expr_rhs": "1", "description": "Car 12 must be parked on exactly one side."}, {"name": "car_parked_once_13", "expr_lhs": "x['13'] + y['13']", "sense": "==", "expr_rhs": "1", "description": "Car 13 must be parked on exactly one side."}, {"name": "car_parked_once_14", "expr_lhs": "x['14'] + y['14']", "sense": "==", "expr_rhs": "1", "description": "Car 14 must be parked on exactly one side."}, {"name": "car_parked_once_15", "expr_lhs": "x['15'] + y['15']", "sense": "==", "expr_rhs": "1", "description": "Car 15 must be parked on exactly one side."}], "graph": null}, "eval": {"ground_truth_raw": "42.1", "ground_truth_value": 42.1, "obj_value": null, "gurobi_status_name": "NONE", "correct": 0}}
{"meta": {"problem_id": "industryOR_22", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 5.199923180043697e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 6.298730700043961, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00016510009299963713, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.00004568696022e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00018719991203397512, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0002851000754162669, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.400033503770828e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0028383999597281218, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.005604699952527881, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.200009137392044e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 5.199923180043697e-06, "llm_call": 6.298730700043961, "json_extract": 0.00016510009299963713, "meta_fill": 6.00004568696022e-06, "ir_parse": 0.00018719991203397512, "graph_build": 0.0002851000754162669, "verifier": 4.400033503770828e-06, "solver_build": 0.0028383999597281218, "solver_optimize": 0.005604699952527881, "estimation": 1.200009137392044e-06}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 1, "n_vars": 1, "n_constraints": 5}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 13.0, "metrics": {"runtime_sec": 0.006999969482421875, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_22", "source": "IndustryOR", "description": "Determine 4 out of 5 workers to complete one of the four tasks, minimizing total working hours.", "sense": "min", "version": 1}, "sets": [{"name": "WORKERS", "elements": ["I", "II", "III", "IV", "V"], "description": "Set of workers available for assignment."}, {"name": "TASKS", "elements": ["A", "B", "C", "D"], "description": "Set of tasks to be completed."}], "params": [{"name": "time", "indices": ["WORKERS", "TASKS"], "values": {"I": {"A": 9, "B": 4, "C": 3, "D": 7}, "II": {"A": 4, "B": 6, "C": 5, "D": 6}, "III": {"A": 5, "B": 4, "C": 7, "D": 5}, "IV": {"A": 7, "B": 5, "C": 2, "D": 3}, "V": {"A": 10, "B": 6, "C": 7, "D": 4}}, "description": "Time required for each worker to complete each task."}], "vars": [{"name": "x", "indices": ["WORKERS", "TASKS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a worker is assigned to a task."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(time[w][t] * x[w][t] for w in WORKERS for t in TASKS)", "description": "Minimize the total working hours for task assignments."}, "constraints": [{"name": "task_assignment_A", "expr_lhs": "sum(x[w]['A'] for w in WORKERS)", "sense": "==", "expr_rhs": "1", "description": "Exactly one worker must be assigned to task A."}, {"name": "task_assignment_B", "expr_lhs": "sum(x[w]['B'] for w in WORKERS)", "sense": "==", "expr_rhs": "1", "description": "Exactly one worker must be assigned to task B."}, {"name": "task_assignment_C", "expr_lhs": "sum(x[w]['C'] for w in WORKERS)", "sense": "==", "expr_rhs": "1", "description": "Exactly one worker must be assigned to task C."}, {"name": "task_assignment_D", "expr_lhs": "sum(x[w]['D'] for w in WORKERS)", "sense": "==", "expr_rhs": "1", "description": "Exactly one worker must be assigned to task D."}, {"name": "worker_selection", "expr_lhs": "sum(sum(x[w][t] for t in TASKS) for w in WORKERS)", "sense": "==", "expr_rhs": "4", "description": "Exactly four workers must be selected for the tasks."}], "graph": null}, "eval": {"ground_truth_raw": "14", "ground_truth_value": 14.0, "obj_value": 13.0, "gurobi_status_name": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_23", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 5.09992241859436e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 7.728478400036693, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00014870008453726768, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.399924702942371e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0001677999971434474, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00027570000384002924, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.00003045797348e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0020146999740973115, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.004020299995318055, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.200016751885414e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 5.09992241859436e-06, "llm_call": 7.728478400036693, "json_extract": 0.00014870008453726768, "meta_fill": 5.399924702942371e-06, "ir_parse": 0.0001677999971434474, "graph_build": 0.00027570000384002924, "verifier": 4.00003045797348e-06, "solver_build": 0.0020146999740973115, "solver_optimize": 0.004020299995318055, "estimation": 2.200016751885414e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 2, "n_vars": 2, "n_constraints": 4}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 1000.0, "metrics": {"runtime_sec": 0.0, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_23", "source": "IndustryOR", "description": "Optimize transportation options to minimize pollution while meeting product delivery requirements.", "sense": "min", "version": 1}, "sets": [{"name": "TRANSPORT_OPTIONS", "elements": ["trucks", "vans", "motorcycles", "electric_vehicles"], "description": "Different transportation options available."}], "params": [{"name": "pollution_per_trip", "indices": ["TRANSPORT_OPTIONS"], "values": {"trucks": 100, "vans": 50, "motorcycles": 10, "electric_vehicles": 0}, "description": "Pollution generated per trip by each transportation option."}, {"name": "capacity_per_trip", "indices": ["TRANSPORT_OPTIONS"], "values": {"trucks": 100, "vans": 80, "motorcycles": 40, "electric_vehicles": 60}, "description": "Capacity of products each transportation option can carry per trip."}], "vars": [{"name": "trips", "indices": ["TRANSPORT_OPTIONS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of trips made by each transportation option."}, {"name": "use_van_or_ev", "indices": [], "vartype": "binary", "lb": 0, "ub": 1, "description": "Binary variable to ensure only one of vans or electric vehicles is used."}], "objective": {"name": "min_total_pollution", "sense": "min", "expr": "sum(pollution_per_trip[o] * trips[o] for o in TRANSPORT_OPTIONS)", "description": "Minimize the total pollution generated by all trips."}, "constraints": [{"name": "total_pollution_limit", "expr_lhs": "sum(pollution_per_trip[o] * trips[o] for o in TRANSPORT_OPTIONS)", "sense": "<=", "expr_rhs": "2000", "description": "Total pollution generated by all trips must not exceed 2000 units."}, {"name": "trucks_minimum_usage", "expr_lhs": "trips['trucks']", "sense": ">=", "expr_rhs": "10", "description": "Trucks must be used at least 10 times."}, {"name": "total_products_transport", "expr_lhs": "sum(capacity_per_trip[o] * trips[o] for o in TRANSPORT_OPTIONS)", "sense": ">=", "expr_rhs": "1800", "description": "The total quantity of products transported must be at least 1800 units."}, {"name": "van_or_ev_exclusive", "expr_lhs": "trips['vans'] + trips['electric_vehicles']", "sense": "<=", "expr_rhs": "use_van_or_ev * 1000000", "description": "Only one of vans or electric vehicles can be used."}], "graph": null}, "eval": {"ground_truth_raw": "1000.0", "ground_truth_value": 1000.0, "obj_value": 1000.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_24", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "solver_build", "stages": {"build_prompts": {"ok": true, "t_sec": 4.800036549568176e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 24.804853399982676, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00043809995986521244, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.00004568696022e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0005499999970197678, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0016874000430107117, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.200031980872154e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": false, "t_sec": 0.0015042000450193882, "error_type": "KeyError", "error_msg": "'0'", "traceback": "Traceback (most recent call last):\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_pipeline.py\", line 254, in run_gm4opt_pipeline\n    model = ir_to_gurobi(ir)\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_ir.py\", line 342, in ir_to_gurobi\n    lhs = eval(cons_def.expr_lhs, global_env, {})\n  File \"<string>\", line 1, in <module>\nKeyError: '0'\n"}}, "timings": {"build_prompts": 4.800036549568176e-06, "llm_call": 24.804853399982676, "json_extract": 0.00043809995986521244, "meta_fill": 6.00004568696022e-06, "ir_parse": 0.0005499999970197678, "graph_build": 0.0016874000430107117, "verifier": 4.200031980872154e-06, "solver_build": 0.0015042000450193882}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 9, "n_vars": 5, "n_constraints": 26}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": false, "build_error": "KeyError: '0'", "status": null, "status_name": "NONE", "obj_value": null, "metrics": {}}, "estimation": {"ok": false, "notes": "not run"}, "ir_dict": {"meta": {"problem_id": "industryOR_24", "source": "IndustryOR", "description": "Optimize the production planning for a company to meet demand while minimizing costs associated with extra work, storage, hiring, and layoffs.", "sense": "min", "version": 1}, "sets": [{"name": "MONTHS", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Months in the planning horizon"}], "params": [{"name": "demand", "indices": ["MONTHS"], "values": {"1": 700, "2": 600, "3": 500, "4": 800, "5": 900, "6": 800}, "description": "Demand for each month"}, {"name": "initial_workers", "indices": [], "values": 40, "description": "Initial number of workers"}, {"name": "production_per_worker", "indices": [], "values": 20, "description": "Units produced per worker per month"}, {"name": "max_extra_units_per_worker", "indices": [], "values": 6, "description": "Maximum extra units a worker can produce per month"}, {"name": "cost_extra_unit", "indices": [], "values": 5, "description": "Cost per extra unit produced"}, {"name": "storage_cost_per_unit", "indices": [], "values": 10, "description": "Storage cost per unit per month"}, {"name": "hiring_cost", "indices": [], "values": 500, "description": "Cost to hire one worker"}, {"name": "layoff_cost", "indices": [], "values": 700, "description": "Cost to lay off one worker"}, {"name": "max_worker_change", "indices": [], "values": 5, "description": "Maximum change in the number of workers per month"}], "vars": [{"name": "extra_units", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Extra units produced in each month"}, {"name": "stored_units", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Units stored at the end of each month"}, {"name": "hired_workers", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of workers hired in each month"}, {"name": "laid_off_workers", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of workers laid off in each month"}, {"name": "total_workers", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Total number of workers in each month"}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(cost_extra_unit * extra_units[m] + storage_cost_per_unit * stored_units[m] + hiring_cost * hired_workers[m] + layoff_cost * laid_off_workers[m] for m in ['1', '2', '3', '4', '5', '6'])", "description": "Minimize the total cost of extra production, storage, hiring, and layoffs"}, "constraints": [{"name": "production_balance_1", "expr_lhs": "initial_workers * production_per_worker + extra_units['1'] + stored_units['0']", "sense": "==", "expr_rhs": "demand['1'] + stored_units['1']", "description": "Production balance for month 1"}, {"name": "production_balance_2", "expr_lhs": "total_workers['1'] * production_per_worker + extra_units['2'] + stored_units['1']", "sense": "==", "expr_rhs": "demand['2'] + stored_units['2']", "description": "Production balance for month 2"}, {"name": "production_balance_3", "expr_lhs": "total_workers['2'] * production_per_worker + extra_units['3'] + stored_units['2']", "sense": "==", "expr_rhs": "demand['3'] + stored_units['3']", "description": "Production balance for month 3"}, {"name": "production_balance_4", "expr_lhs": "total_workers['3'] * production_per_worker + extra_units['4'] + stored_units['3']", "sense": "==", "expr_rhs": "demand['4'] + stored_units['4']", "description": "Production balance for month 4"}, {"name": "production_balance_5", "expr_lhs": "total_workers['4'] * production_per_worker + extra_units['5'] + stored_units['4']", "sense": "==", "expr_rhs": "demand['5'] + stored_units['5']", "description": "Production balance for month 5"}, {"name": "production_balance_6", "expr_lhs": "total_workers['5'] * production_per_worker + extra_units['6'] + stored_units['5']", "sense": "==", "expr_rhs": "demand['6'] + stored_units['6']", "description": "Production balance for month 6"}, {"name": "initial_storage", "expr_lhs": "stored_units['0']", "sense": "==", "expr_rhs": "0", "description": "Initial storage is empty"}, {"name": "final_storage", "expr_lhs": "stored_units['6']", "sense": "==", "expr_rhs": "0", "description": "Final storage must be empty"}, {"name": "worker_balance_1", "expr_lhs": "initial_workers + hired_workers['1'] - laid_off_workers['1']", "sense": "==", "expr_rhs": "total_workers['1']", "description": "Worker balance for month 1"}, {"name": "worker_balance_2", "expr_lhs": "total_workers['1'] + hired_workers['2'] - laid_off_workers['2']", "sense": "==", "expr_rhs": "total_workers['2']", "description": "Worker balance for month 2"}, {"name": "worker_balance_3", "expr_lhs": "total_workers['2'] + hired_workers['3'] - laid_off_workers['3']", "sense": "==", "expr_rhs": "total_workers['3']", "description": "Worker balance for month 3"}, {"name": "worker_balance_4", "expr_lhs": "total_workers['3'] + hired_workers['4'] - laid_off_workers['4']", "sense": "==", "expr_rhs": "total_workers['4']", "description": "Worker balance for month 4"}, {"name": "worker_balance_5", "expr_lhs": "total_workers['4'] + hired_workers['5'] - laid_off_workers['5']", "sense": "==", "expr_rhs": "total_workers['5']", "description": "Worker balance for month 5"}, {"name": "worker_balance_6", "expr_lhs": "total_workers['5'] + hired_workers['6'] - laid_off_workers['6']", "sense": "==", "expr_rhs": "total_workers['6']", "description": "Worker balance for month 6"}, {"name": "max_extra_production_1", "expr_lhs": "extra_units['1']", "sense": "<=", "expr_rhs": "total_workers['1'] * max_extra_units_per_worker", "description": "Max extra production for month 1"}, {"name": "max_extra_production_2", "expr_lhs": "extra_units['2']", "sense": "<=", "expr_rhs": "total_workers['2'] * max_extra_units_per_worker", "description": "Max extra production for month 2"}, {"name": "max_extra_production_3", "expr_lhs": "extra_units['3']", "sense": "<=", "expr_rhs": "total_workers['3'] * max_extra_units_per_worker", "description": "Max extra production for month 3"}, {"name": "max_extra_production_4", "expr_lhs": "extra_units['4']", "sense": "<=", "expr_rhs": "total_workers['4'] * max_extra_units_per_worker", "description": "Max extra production for month 4"}, {"name": "max_extra_production_5", "expr_lhs": "extra_units['5']", "sense": "<=", "expr_rhs": "total_workers['5'] * max_extra_units_per_worker", "description": "Max extra production for month 5"}, {"name": "max_extra_production_6", "expr_lhs": "extra_units['6']", "sense": "<=", "expr_rhs": "total_workers['6'] * max_extra_units_per_worker", "description": "Max extra production for month 6"}, {"name": "max_worker_change_1", "expr_lhs": "hired_workers['1'] + laid_off_workers['1']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 1"}, {"name": "max_worker_change_2", "expr_lhs": "hired_workers['2'] + laid_off_workers['2']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 2"}, {"name": "max_worker_change_3", "expr_lhs": "hired_workers['3'] + laid_off_workers['3']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 3"}, {"name": "max_worker_change_4", "expr_lhs": "hired_workers['4'] + laid_off_workers['4']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 4"}, {"name": "max_worker_change_5", "expr_lhs": "hired_workers['5'] + laid_off_workers['5']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 5"}, {"name": "max_worker_change_6", "expr_lhs": "hired_workers['6'] + laid_off_workers['6']", "sense": "<=", "expr_rhs": "max_worker_change", "description": "Max worker change for month 6"}], "graph": null}, "eval": {"ground_truth_raw": "10000", "ground_truth_value": 10000.0, "obj_value": null, "gurobi_status_name": "NONE", "correct": 0}}
{"meta": {"problem_id": "industryOR_25", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 1.0600080713629723e-05, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 16.679142000037245, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0003831000067293644, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.900044925510883e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0003887999337166548, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0008804999524727464, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.00003045797348e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.004814499989151955, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.01583829999435693, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.600012183189392e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 1.0600080713629723e-05, "llm_call": 16.679142000037245, "json_extract": 0.0003831000067293644, "meta_fill": 5.900044925510883e-06, "ir_parse": 0.0003887999337166548, "graph_build": 0.0008804999524727464, "verifier": 4.00003045797348e-06, "solver_build": 0.004814499989151955, "solver_optimize": 0.01583829999435693, "estimation": 1.600012183189392e-06}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 5, "n_vars": 3, "n_constraints": 20}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 10755.0, "metrics": {"runtime_sec": 0.013000011444091797, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_25", "source": "IndustryOR", "description": "Minimize total compensation and storage fee for production planning over four quarters.", "sense": "min", "version": 1}, "sets": [{"name": "PRODUCTS", "elements": ["I", "II", "III"], "description": "Types of products"}, {"name": "QUARTERS", "elements": ["1", "2", "3", "4"], "description": "Quarters of the year"}], "params": [{"name": "contract_orders", "indices": ["PRODUCTS", "QUARTERS"], "values": {"I": {"1": 1500, "2": 1000, "3": 2000, "4": 1200}, "II": {"1": 1500, "2": 1500, "3": 1200, "4": 1500}, "III": {"1": 1000, "2": 2000, "3": 1500, "4": 2500}}, "description": "Contract orders for each product in each quarter"}, {"name": "production_time_per_unit", "indices": ["PRODUCTS"], "values": {"I": 2, "II": 4, "III": 3}, "description": "Production time required per unit of each product"}, {"name": "production_time_available", "indices": [], "values": 15000, "description": "Total production time available per quarter"}, {"name": "compensation_cost", "indices": ["PRODUCTS"], "values": {"I": 20, "II": 20, "III": 10}, "description": "Compensation cost per unit per quarter for late delivery"}, {"name": "storage_cost", "indices": [], "values": 5, "description": "Storage cost per unit per quarter"}], "vars": [{"name": "produce", "indices": ["PRODUCTS", "QUARTERS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units of product produced in each quarter"}, {"name": "inventory", "indices": ["PRODUCTS", "QUARTERS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units of product in inventory at the end of each quarter"}, {"name": "compensation", "indices": ["PRODUCTS", "QUARTERS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Units of product not delivered on time in each quarter"}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(compensation[p][q] * compensation_cost[p] + inventory[p][q] * storage_cost for p in PRODUCTS for q in QUARTERS)", "description": "Minimize total compensation and storage costs"}, "constraints": [{"name": "production_time_limit_1", "expr_lhs": "sum(produce[p]['1'] * production_time_per_unit[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "production_time_available", "description": "Production time limit for quarter 1"}, {"name": "production_time_limit_2", "expr_lhs": "sum(produce[p]['2'] * production_time_per_unit[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "production_time_available", "description": "Production time limit for quarter 2"}, {"name": "production_time_limit_3", "expr_lhs": "sum(produce[p]['3'] * production_time_per_unit[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "production_time_available", "description": "Production time limit for quarter 3"}, {"name": "production_time_limit_4", "expr_lhs": "sum(produce[p]['4'] * production_time_per_unit[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "production_time_available", "description": "Production time limit for quarter 4"}, {"name": "inventory_balance_I_1", "expr_lhs": "produce['I']['1'] - contract_orders['I']['1'] - compensation['I']['1']", "sense": "==", "expr_rhs": "inventory['I']['1']", "description": "Inventory balance for product I in quarter 1"}, {"name": "inventory_balance_I_2", "expr_lhs": "produce['I']['2'] + inventory['I']['1'] - contract_orders['I']['2'] - compensation['I']['2']", "sense": "==", "expr_rhs": "inventory['I']['2']", "description": "Inventory balance for product I in quarter 2"}, {"name": "inventory_balance_I_3", "expr_lhs": "produce['I']['3'] + inventory['I']['2'] - contract_orders['I']['3'] - compensation['I']['3']", "sense": "==", "expr_rhs": "inventory['I']['3']", "description": "Inventory balance for product I in quarter 3"}, {"name": "inventory_balance_I_4", "expr_lhs": "produce['I']['4'] + inventory['I']['3'] - contract_orders['I']['4'] - compensation['I']['4']", "sense": "==", "expr_rhs": "inventory['I']['4']", "description": "Inventory balance for product I in quarter 4"}, {"name": "inventory_balance_II_1", "expr_lhs": "produce['II']['1'] - contract_orders['II']['1'] - compensation['II']['1']", "sense": "==", "expr_rhs": "inventory['II']['1']", "description": "Inventory balance for product II in quarter 1"}, {"name": "inventory_balance_II_2", "expr_lhs": "produce['II']['2'] + inventory['II']['1'] - contract_orders['II']['2'] - compensation['II']['2']", "sense": "==", "expr_rhs": "inventory['II']['2']", "description": "Inventory balance for product II in quarter 2"}, {"name": "inventory_balance_II_3", "expr_lhs": "produce['II']['3'] + inventory['II']['2'] - contract_orders['II']['3'] - compensation['II']['3']", "sense": "==", "expr_rhs": "inventory['II']['3']", "description": "Inventory balance for product II in quarter 3"}, {"name": "inventory_balance_II_4", "expr_lhs": "produce['II']['4'] + inventory['II']['3'] - contract_orders['II']['4'] - compensation['II']['4']", "sense": "==", "expr_rhs": "inventory['II']['4']", "description": "Inventory balance for product II in quarter 4"}, {"name": "inventory_balance_III_1", "expr_lhs": "produce['III']['1'] - contract_orders['III']['1'] - compensation['III']['1']", "sense": "==", "expr_rhs": "inventory['III']['1']", "description": "Inventory balance for product III in quarter 1"}, {"name": "inventory_balance_III_2", "expr_lhs": "produce['III']['2'] + inventory['III']['1'] - contract_orders['III']['2'] - compensation['III']['2']", "sense": "==", "expr_rhs": "inventory['III']['2']", "description": "Inventory balance for product III in quarter 2"}, {"name": "inventory_balance_III_3", "expr_lhs": "produce['III']['3'] + inventory['III']['2'] - contract_orders['III']['3'] - compensation['III']['3']", "sense": "==", "expr_rhs": "inventory['III']['3']", "description": "Inventory balance for product III in quarter 3"}, {"name": "inventory_balance_III_4", "expr_lhs": "produce['III']['4'] + inventory['III']['3'] - contract_orders['III']['4'] - compensation['III']['4']", "sense": "==", "expr_rhs": "inventory['III']['4']", "description": "Inventory balance for product III in quarter 4"}, {"name": "end_inventory_requirement_I", "expr_lhs": "inventory['I']['4']", "sense": "==", "expr_rhs": "150", "description": "End of year inventory requirement for product I"}, {"name": "end_inventory_requirement_II", "expr_lhs": "inventory['II']['4']", "sense": "==", "expr_rhs": "150", "description": "End of year inventory requirement for product II"}, {"name": "end_inventory_requirement_III", "expr_lhs": "inventory['III']['4']", "sense": "==", "expr_rhs": "150", "description": "End of year inventory requirement for product III"}, {"name": "production_restriction_I_2", "expr_lhs": "produce['I']['2']", "sense": "==", "expr_rhs": "0", "description": "Product I cannot be produced in quarter 2"}], "graph": null}, "eval": {"ground_truth_raw": "8505", "ground_truth_value": 8505.0, "obj_value": 10755.0, "gurobi_status_name": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_26", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 1.9000028260052204e-05, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 7.003468699986115, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00018200010526925325, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.700051017105579e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00020029989536851645, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00031649996526539326, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 3.900029696524143e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.003539599943906069, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.006964900065213442, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.300009898841381e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 1.9000028260052204e-05, "llm_call": 7.003468699986115, "json_extract": 0.00018200010526925325, "meta_fill": 6.700051017105579e-06, "ir_parse": 0.00020029989536851645, "graph_build": 0.00031649996526539326, "verifier": 3.900029696524143e-06, "solver_build": 0.003539599943906069, "solver_optimize": 0.006964900065213442, "estimation": 1.300009898841381e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 4, "n_vars": 1, "n_constraints": 3}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 0.032435897435897434, "metrics": {"runtime_sec": 0.006999969482421875, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_26", "source": "IndustryOR", "description": "Optimize the selection of feed types to meet nutritional requirements at minimum cost.", "sense": "min", "version": 1}, "sets": [{"name": "FEEDS", "elements": ["1", "2", "3", "4", "5"], "description": "Types of feed available."}], "params": [{"name": "protein_content", "indices": ["FEEDS"], "values": {"1": 3, "2": 2, "3": 1, "4": 6, "5": 18}, "description": "Protein content per gram of each feed."}, {"name": "mineral_content", "indices": ["FEEDS"], "values": {"1": 1, "2": 0.5, "3": 0.2, "4": 2, "5": 0.5}, "description": "Mineral content per gram of each feed."}, {"name": "vitamin_content", "indices": ["FEEDS"], "values": {"1": 0.5, "2": 1, "3": 0.2, "4": 2, "5": 0.8}, "description": "Vitamin content per milligram of each feed."}, {"name": "price", "indices": ["FEEDS"], "values": {"1": 0.2, "2": 0.7, "3": 0.4, "4": 0.3, "5": 0.8}, "description": "Price per kilogram of each feed."}], "vars": [{"name": "amount", "indices": ["FEEDS"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Amount of each feed type to use in grams."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(amount[f] * price[f] / 1000 for f in FEEDS)", "description": "Minimize the total cost of feed selection."}, "constraints": [{"name": "protein_requirement", "expr_lhs": "sum(amount[f] * protein_content[f] for f in FEEDS)", "sense": ">=", "expr_rhs": "700", "description": "Ensure at least 700g of protein is provided."}, {"name": "mineral_requirement", "expr_lhs": "sum(amount[f] * mineral_content[f] for f in FEEDS)", "sense": ">=", "expr_rhs": "30", "description": "Ensure at least 30g of minerals is provided."}, {"name": "vitamin_requirement", "expr_lhs": "sum(amount[f] * vitamin_content[f] for f in FEEDS)", "sense": ">=", "expr_rhs": "100", "description": "Ensure at least 100mg of vitamins is provided."}], "graph": null}, "eval": {"ground_truth_raw": "32.436", "ground_truth_value": 32.436, "obj_value": 0.032435897435897434, "gurobi_status_name": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_27", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "solver_build", "stages": {"build_prompts": {"ok": true, "t_sec": 4.200031980872154e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 14.717117500025779, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 8.219992741942406e-05, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 1.600012183189392e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 8.519995026290417e-05, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00015119998715817928, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.700012944638729e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": false, "t_sec": 9.570003021508455e-05, "error_type": "TypeError", "error_msg": "2D param equipment_available_time expects nested dict for values[A1], got <class 'int'>.", "traceback": "Traceback (most recent call last):\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_pipeline.py\", line 254, in run_gm4opt_pipeline\n    model = ir_to_gurobi(ir)\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_ir.py\", line 225, in ir_to_gurobi\n    raise TypeError(\nTypeError: 2D param equipment_available_time expects nested dict for values[A1], got <class 'int'>.\n"}}, "timings": {"build_prompts": 4.200031980872154e-06, "llm_call": 14.717117500025779, "json_extract": 8.219992741942406e-05, "meta_fill": 1.600012183189392e-06, "ir_parse": 8.519995026290417e-05, "graph_build": 0.00015119998715817928, "verifier": 1.700012944638729e-06, "solver_build": 9.570003021508455e-05}, "features": {"graph_built": 1, "n_sets": 3, "n_params": 6, "n_vars": 2, "n_constraints": 8}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": false, "build_error": "TypeError: 2D param equipment_available_time expects nested dict for values[A1], got <class 'int'>.", "status": null, "status_name": "NONE", "obj_value": null, "metrics": {}}, "estimation": {"ok": false, "notes": "not run"}, "ir_dict": {"meta": {"problem_id": "industryOR_27", "source": "IndustryOR", "description": "Determine the optimal production plan to maximize the profit for the factory producing three types of products using different equipment.", "sense": "max", "version": 1}, "sets": [{"name": "PRODUCTS", "elements": ["I", "II", "III"], "description": "Types of products produced by the factory."}, {"name": "EQUIPMENT_A", "elements": ["A1", "A2"], "description": "Types of equipment for processing step A."}, {"name": "EQUIPMENT_B", "elements": ["B1", "B2", "B3"], "description": "Types of equipment for processing step B."}], "params": [{"name": "processing_time_A", "indices": ["EQUIPMENT_A", "PRODUCTS"], "values": {"A1": {"I": 5, "II": 10, "III": null}, "A2": {"I": 7, "II": 9, "III": 12}}, "description": "Processing time for each product on equipment A."}, {"name": "processing_time_B", "indices": ["EQUIPMENT_B", "PRODUCTS"], "values": {"B1": {"I": 6, "II": 8, "III": null}, "B2": {"I": 4, "II": null, "III": 11}, "B3": {"I": 7, "II": null, "III": null}}, "description": "Processing time for each product on equipment B."}, {"name": "equipment_available_time", "indices": ["EQUIPMENT_A", "EQUIPMENT_B"], "values": {"A1": 10000, "A2": 4000, "B1": 7000, "B2": 4000, "B3": 6000}, "description": "Available time for each equipment type."}, {"name": "equipment_cost", "indices": ["EQUIPMENT_A", "EQUIPMENT_B"], "values": {"A1": 321, "A2": 250, "B1": 783, "B2": 200, "B3": 300}, "description": "Cost at full load for each equipment type."}, {"name": "raw_material_cost", "indices": ["PRODUCTS"], "values": {"I": 0.25, "II": 0.35, "III": 0.5}, "description": "Raw material cost per unit for each product."}, {"name": "unit_price", "indices": ["PRODUCTS"], "values": {"I": 1.25, "II": 2.0, "III": 2.8}, "description": "Selling price per unit for each product."}], "vars": [{"name": "x_A", "indices": ["EQUIPMENT_A", "PRODUCTS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of units of each product processed on equipment A."}, {"name": "x_B", "indices": ["EQUIPMENT_B", "PRODUCTS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of units of each product processed on equipment B."}], "objective": {"name": "max_profit", "sense": "max", "expr": "sum((unit_price[p] - raw_material_cost[p]) * (sum(x_A[a][p] for a in EQUIPMENT_A) + sum(x_B[b][p] for b in EQUIPMENT_B)) - sum(equipment_cost[a] for a in EQUIPMENT_A) - sum(equipment_cost[b] for b in EQUIPMENT_B) for p in PRODUCTS)", "description": "Maximize the profit from selling products minus raw material and equipment costs."}, "constraints": [{"name": "equipment_A_time_constraint_A1", "expr_lhs": "sum(processing_time_A['A1'][p] * x_A['A1'][p] for p in PRODUCTS if processing_time_A['A1'][p] is not None)", "sense": "<=", "expr_rhs": "equipment_available_time['A1']", "description": "Time constraint for equipment A1."}, {"name": "equipment_A_time_constraint_A2", "expr_lhs": "sum(processing_time_A['A2'][p] * x_A['A2'][p] for p in PRODUCTS if processing_time_A['A2'][p] is not None)", "sense": "<=", "expr_rhs": "equipment_available_time['A2']", "description": "Time constraint for equipment A2."}, {"name": "equipment_B_time_constraint_B1", "expr_lhs": "sum(processing_time_B['B1'][p] * x_B['B1'][p] for p in PRODUCTS if processing_time_B['B1'][p] is not None)", "sense": "<=", "expr_rhs": "equipment_available_time['B1']", "description": "Time constraint for equipment B1."}, {"name": "equipment_B_time_constraint_B2", "expr_lhs": "sum(processing_time_B['B2'][p] * x_B['B2'][p] for p in PRODUCTS if processing_time_B['B2'][p] is not None)", "sense": "<=", "expr_rhs": "equipment_available_time['B2']", "description": "Time constraint for equipment B2."}, {"name": "equipment_B_time_constraint_B3", "expr_lhs": "sum(processing_time_B['B3'][p] * x_B['B3'][p] for p in PRODUCTS if processing_time_B['B3'][p] is not None)", "sense": "<=", "expr_rhs": "equipment_available_time['B3']", "description": "Time constraint for equipment B3."}, {"name": "product_II_B_constraint", "expr_lhs": "x_B['B2']['II'] + x_B['B3']['II']", "sense": "==", "expr_rhs": "0", "description": "Product II can only be processed on B1 equipment."}, {"name": "product_III_A_constraint", "expr_lhs": "x_A['A1']['III']", "sense": "==", "expr_rhs": "0", "description": "Product III can only be processed on A2 equipment."}, {"name": "product_III_B_constraint", "expr_lhs": "x_B['B1']['III'] + x_B['B3']['III']", "sense": "==", "expr_rhs": "0", "description": "Product III can only be processed on B2 equipment."}], "graph": null}, "eval": {"ground_truth_raw": "1146.6", "ground_truth_value": 1146.6, "obj_value": null, "gurobi_status_name": "NONE", "correct": 0}}
{"meta": {"problem_id": "industryOR_28", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 3.700028173625469e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 7.629383400082588, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00011090002954006195, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 3.100023604929447e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 9.58999153226614e-05, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00013990001752972603, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 2.00001522898674e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0012736000353470445, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.0029602000722661614, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.00001522898674e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 3.700028173625469e-06, "llm_call": 7.629383400082588, "json_extract": 0.00011090002954006195, "meta_fill": 3.100023604929447e-06, "ir_parse": 9.58999153226614e-05, "graph_build": 0.00013990001752972603, "verifier": 2.00001522898674e-06, "solver_build": 0.0012736000353470445, "solver_optimize": 0.0029602000722661614, "estimation": 2.00001522898674e-06}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 2, "n_vars": 1, "n_constraints": 4}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 9350.0, "metrics": {"runtime_sec": 0.0, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_28", "source": "IndustryOR", "description": "Determine how many hours should be allocated to each component in each workshop to maximize the number of completed products.", "sense": "max", "version": 1}, "sets": [{"name": "WORKSHOPS", "elements": ["A", "B", "C", "D"], "description": "The workshops where components are produced."}, {"name": "COMPONENTS", "elements": ["1", "2", "3"], "description": "The components that make up the product."}], "params": [{"name": "production_capacity", "indices": ["WORKSHOPS"], "values": {"A": 100, "B": 150, "C": 80, "D": 200}, "description": "The total number of production hours available for each workshop."}, {"name": "productivity", "indices": ["WORKSHOPS", "COMPONENTS"], "values": {"A": {"1": 10, "2": 15, "3": 5}, "B": {"1": 15, "2": 10, "3": 5}, "C": {"1": 20, "2": 5, "3": 10}, "D": {"1": 10, "2": 15, "3": 20}}, "description": "The productivity in units per hour for each component in each workshop."}], "vars": [{"name": "hours_allocated", "indices": ["WORKSHOPS", "COMPONENTS"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "The number of hours allocated to each component in each workshop."}], "objective": {"name": "max_completed_products", "sense": "max", "expr": "sum(hours_allocated[w][c] * productivity[w][c] for w in WORKSHOPS for c in COMPONENTS)", "description": "Maximize the number of completed products."}, "constraints": [{"name": "capacity_constraint_A", "expr_lhs": "sum(hours_allocated['A'][c] for c in COMPONENTS)", "sense": "<=", "expr_rhs": "production_capacity['A']", "description": "The total hours allocated in workshop A must not exceed its capacity."}, {"name": "capacity_constraint_B", "expr_lhs": "sum(hours_allocated['B'][c] for c in COMPONENTS)", "sense": "<=", "expr_rhs": "production_capacity['B']", "description": "The total hours allocated in workshop B must not exceed its capacity."}, {"name": "capacity_constraint_C", "expr_lhs": "sum(hours_allocated['C'][c] for c in COMPONENTS)", "sense": "<=", "expr_rhs": "production_capacity['C']", "description": "The total hours allocated in workshop C must not exceed its capacity."}, {"name": "capacity_constraint_D", "expr_lhs": "sum(hours_allocated['D'][c] for c in COMPONENTS)", "sense": "<=", "expr_rhs": "production_capacity['D']", "description": "The total hours allocated in workshop D must not exceed its capacity."}], "graph": null}, "eval": {"ground_truth_raw": "2924", "ground_truth_value": 2924.0, "obj_value": 9350.0, "gurobi_status_name": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_29", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.00003045797348e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 18.201931499992497, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00018540001474320889, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 2.900022082030773e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0005267000524327159, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.001828000065870583, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 5.700043402612209e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.013213299913331866, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 60.02969380002469, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 4.100031219422817e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.00003045797348e-06, "llm_call": 18.201931499992497, "json_extract": 0.00018540001474320889, "meta_fill": 2.900022082030773e-06, "ir_parse": 0.0005267000524327159, "graph_build": 0.001828000065870583, "verifier": 5.700043402612209e-06, "solver_build": 0.013213299913331866, "solver_optimize": 60.02969380002469, "estimation": 4.100031219422817e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 1, "n_vars": 8, "n_constraints": 19}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 9, "status_name": "TIME_LIMIT", "obj_value": null, "metrics": {"runtime_sec": 60.02800011634827, "node_count": 6886872, "mip_gap": Infinity}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_29", "source": "IndustryOR", "description": "Develop a production plan, worker schedule, and plan for hiring and dismissing employees to maximize total net profit over 6 months while ensuring at least 10,000 units of product by the end of June.", "sense": "max", "version": 1}, "sets": [{"name": "MONTHS", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Months from January to June"}], "params": [{"name": "demand_forecast", "indices": ["MONTHS"], "values": {"1": 20000, "2": 40000, "3": 42000, "4": 35000, "5": 19000, "6": 18500}, "description": "Forecasted demand for each month"}], "vars": [{"name": "produce", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of units produced each month"}, {"name": "hire", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of workers hired each month"}, {"name": "dismiss", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of workers dismissed each month"}, {"name": "overtime_hours", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": 20.0, "description": "Overtime hours per worker each month"}, {"name": "inventory", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Inventory level at the end of each month"}, {"name": "stockout", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Stockout level at the end of each month"}, {"name": "outsourcing", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of units outsourced each month"}, {"name": "workers", "indices": ["MONTHS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of workers at the end of each month"}], "objective": {"name": "max_total_net_profit", "sense": "max", "expr": "sum((300 * produce[m] - 90 * produce[m] - 30 * 8 * workers[m] * 20 - 40 * overtime_hours[m] * workers[m] - 15 * inventory[m] - 35 * stockout[m] - 200 * outsourcing[m] - 5000 * hire[m] - 8000 * dismiss[m]) for m in MONTHS)", "description": "Maximize total net profit over 6 months"}, "constraints": [{"name": "initial_inventory", "expr_lhs": "inventory['1']", "sense": "==", "expr_rhs": "15000 + produce['1'] - demand_forecast['1'] - stockout['1'] + outsourcing['1']", "description": "Initial inventory balance for month 1"}, {"name": "inventory_balance_2", "expr_lhs": "inventory['2']", "sense": "==", "expr_rhs": "inventory['1'] + produce['2'] - demand_forecast['2'] - stockout['2'] + outsourcing['2']", "description": "Inventory balance for month 2"}, {"name": "inventory_balance_3", "expr_lhs": "inventory['3']", "sense": "==", "expr_rhs": "inventory['2'] + produce['3'] - demand_forecast['3'] - stockout['3'] + outsourcing['3']", "description": "Inventory balance for month 3"}, {"name": "inventory_balance_4", "expr_lhs": "inventory['4']", "sense": "==", "expr_rhs": "inventory['3'] + produce['4'] - demand_forecast['4'] - stockout['4'] + outsourcing['4']", "description": "Inventory balance for month 4"}, {"name": "inventory_balance_5", "expr_lhs": "inventory['5']", "sense": "==", "expr_rhs": "inventory['4'] + produce['5'] - demand_forecast['5'] - stockout['5'] + outsourcing['5']", "description": "Inventory balance for month 5"}, {"name": "inventory_balance_6", "expr_lhs": "inventory['6']", "sense": "==", "expr_rhs": "inventory['5'] + produce['6'] - demand_forecast['6'] - stockout['6'] + outsourcing['6']", "description": "Inventory balance for month 6"}, {"name": "end_inventory_requirement", "expr_lhs": "inventory['6']", "sense": ">=", "expr_rhs": "10000", "description": "Ensure at least 10,000 units of product by the end of June"}, {"name": "worker_balance_1", "expr_lhs": "workers['1']", "sense": "==", "expr_rhs": "1000 + hire['1'] - dismiss['1']", "description": "Worker balance for month 1"}, {"name": "worker_balance_2", "expr_lhs": "workers['2']", "sense": "==", "expr_rhs": "workers['1'] + hire['2'] - dismiss['2']", "description": "Worker balance for month 2"}, {"name": "worker_balance_3", "expr_lhs": "workers['3']", "sense": "==", "expr_rhs": "workers['2'] + hire['3'] - dismiss['3']", "description": "Worker balance for month 3"}, {"name": "worker_balance_4", "expr_lhs": "workers['4']", "sense": "==", "expr_rhs": "workers['3'] + hire['4'] - dismiss['4']", "description": "Worker balance for month 4"}, {"name": "worker_balance_5", "expr_lhs": "workers['5']", "sense": "==", "expr_rhs": "workers['4'] + hire['5'] - dismiss['5']", "description": "Worker balance for month 5"}, {"name": "worker_balance_6", "expr_lhs": "workers['6']", "sense": "==", "expr_rhs": "workers['5'] + hire['6'] - dismiss['6']", "description": "Worker balance for month 6"}, {"name": "production_capacity_1", "expr_lhs": "produce['1']", "sense": "<=", "expr_rhs": "5 * (8 * workers['1'] + overtime_hours['1'] * workers['1'])", "description": "Production capacity constraint for month 1"}, {"name": "production_capacity_2", "expr_lhs": "produce['2']", "sense": "<=", "expr_rhs": "5 * (8 * workers['2'] + overtime_hours['2'] * workers['2'])", "description": "Production capacity constraint for month 2"}, {"name": "production_capacity_3", "expr_lhs": "produce['3']", "sense": "<=", "expr_rhs": "5 * (8 * workers['3'] + overtime_hours['3'] * workers['3'])", "description": "Production capacity constraint for month 3"}, {"name": "production_capacity_4", "expr_lhs": "produce['4']", "sense": "<=", "expr_rhs": "5 * (8 * workers['4'] + overtime_hours['4'] * workers['4'])", "description": "Production capacity constraint for month 4"}, {"name": "production_capacity_5", "expr_lhs": "produce['5']", "sense": "<=", "expr_rhs": "5 * (8 * workers['5'] + overtime_hours['5'] * workers['5'])", "description": "Production capacity constraint for month 5"}, {"name": "production_capacity_6", "expr_lhs": "produce['6']", "sense": "<=", "expr_rhs": "5 * (8 * workers['6'] + overtime_hours['6'] * workers['6'])", "description": "Production capacity constraint for month 6"}], "graph": null}, "eval": {"ground_truth_raw": "9337440", "ground_truth_value": 9337440.0, "obj_value": null, "gurobi_status_name": "TIME_LIMIT", "correct": 0}}
{"meta": {"problem_id": "industryOR_30", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "solver_build", "stages": {"build_prompts": {"ok": true, "t_sec": 9.300070814788342e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 53.442812100052834, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0007178999949246645, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.600050255656242e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0003739000530913472, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0007127999560907483, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 3.999914042651653e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": false, "t_sec": 0.0001735000405460596, "error_type": "NotImplementedError", "error_msg": "GM4OPT v1 only supports up to 2D vars.", "traceback": "Traceback (most recent call last):\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_pipeline.py\", line 254, in run_gm4opt_pipeline\n    model = ir_to_gurobi(ir)\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_ir.py\", line 303, in ir_to_gurobi\n    raise NotImplementedError(\"GM4OPT v1 only supports up to 2D vars.\")\nNotImplementedError: GM4OPT v1 only supports up to 2D vars.\n"}}, "timings": {"build_prompts": 9.300070814788342e-06, "llm_call": 53.442812100052834, "json_extract": 0.0007178999949246645, "meta_fill": 6.600050255656242e-06, "ir_parse": 0.0003739000530913472, "graph_build": 0.0007127999560907483, "verifier": 3.999914042651653e-06, "solver_build": 0.0001735000405460596}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 5, "n_vars": 2, "n_constraints": 15}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": false, "build_error": "NotImplementedError: GM4OPT v1 only supports up to 2D vars.", "status": null, "status_name": "NONE", "obj_value": null, "metrics": {}}, "estimation": {"ok": false, "notes": "not run"}, "ir_dict": {"meta": {"problem_id": "industryOR_30", "source": "IndustryOR", "description": "Vehicle Routing Problem with Hard Time Windows (VRPHTW) where vehicles must serve customers within specific time windows, starting and ending at a distribution center, with the objective to minimize travel costs.", "sense": "min", "version": 1}, "sets": [{"name": "CUSTOMERS", "elements": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100"], "description": "Set of customer points including the distribution center (0)."}, {"name": "VEHICLES", "elements": ["1", "2", "3", "4", "5"], "description": "Set of available vehicles."}], "params": [{"name": "demand", "indices": ["CUSTOMERS"], "values": {"0": 0, "1": 10, "2": 7, "3": 13, "4": 19, "5": 26, "6": 3, "7": 5, "8": 9, "9": 16, "10": 16, "11": 12, "12": 19, "13": 23, "14": 20, "15": 8, "16": 19, "17": 2, "18": 12, "19": 17, "20": 9, "21": 11, "22": 18, "23": 29, "24": 3, "25": 6, "26": 17, "27": 16, "28": 16, "29": 9, "30": 21, "31": 27, "32": 23, "33": 11, "34": 14, "35": 8, "36": 5, "37": 8, "38": 16, "39": 31, "40": 9, "41": 5, "42": 5, "43": 7, "44": 18, "45": 16, "46": 1, "47": 27, "48": 36, "49": 30, "50": 13, "51": 10, "52": 9, "53": 14, "54": 18, "55": 2, "56": 6, "57": 7, "58": 18, "59": 28, "60": 3, "61": 13, "62": 19, "63": 10, "64": 9, "65": 20, "66": 25, "67": 25, "68": 36, "69": 6, "70": 5, "71": 15, "72": 25, "73": 9, "74": 8, "75": 18, "76": 13, "77": 14, "78": 3, "79": 23, "80": 6, "81": 26, "82": 16, "83": 11, "84": 7, "85": 41, "86": 35, "87": 26, "88": 9, "89": 15, "90": 3, "91": 1, "92": 2, "93": 22, "94": 27, "95": 20, "96": 11, "97": 12, "98": 10, "99": 9, "100": 17}, "description": "Demand of goods for each customer."}, {"name": "service_time", "indices": ["CUSTOMERS"], "values": {"0": 0, "1": 10, "2": 10, "3": 10, "4": 10, "5": 10, "6": 10, "7": 10, "8": 10, "9": 10, "10": 10, "11": 10, "12": 10, "13": 10, "14": 10, "15": 10, "16": 10, "17": 10, "18": 10, "19": 10, "20": 10, "21": 10, "22": 10, "23": 10, "24": 10, "25": 10, "26": 10, "27": 10, "28": 10, "29": 10, "30": 10, "31": 10, "32": 10, "33": 10, "34": 10, "35": 10, "36": 10, "37": 10, "38": 10, "39": 10, "40": 10, "41": 10, "42": 10, "43": 10, "44": 10, "45": 10, "46": 10, "47": 10, "48": 10, "49": 10, "50": 10, "51": 10, "52": 10, "53": 10, "54": 10, "55": 10, "56": 10, "57": 10, "58": 10, "59": 10, "60": 10, "61": 10, "62": 10, "63": 10, "64": 10, "65": 10, "66": 10, "67": 10, "68": 10, "69": 10, "70": 10, "71": 10, "72": 10, "73": 10, "74": 10, "75": 10, "76": 10, "77": 10, "78": 10, "79": 10, "80": 10, "81": 10, "82": 10, "83": 10, "84": 10, "85": 10, "86": 10, "87": 10, "88": 10, "89": 10, "90": 10, "91": 10, "92": 10, "93": 10, "94": 10, "95": 10, "96": 10, "97": 10, "98": 10, "99": 10, "100": 10}, "description": "Service time required at each customer."}, {"name": "time_window_start", "indices": ["CUSTOMERS"], "values": {"0": 0, "1": 161, "2": 50, "3": 116, "4": 149, "5": 34, "6": 99, "7": 81, "8": 95, "9": 97, "10": 124, "11": 67, "12": 63, "13": 159, "14": 32, "15": 61, "16": 75, "17": 157, "18": 87, "19": 76, "20": 126, "21": 62, "22": 97, "23": 68, "24": 153, "25": 172, "26": 132, "27": 37, "28": 39, "29": 63, "30": 71, "31": 50, "32": 141, "33": 37, "34": 117, "35": 143, "36": 41, "37": 134, "38": 83, "39": 44, "40": 85, "41": 97, "42": 31, "43": 132, "44": 69, "45": 32, "46": 117, "47": 51, "48": 165, "49": 108, "50": 124, "51": 88, "52": 52, "53": 95, "54": 140, "55": 136, "56": 130, "57": 101, "58": 200, "59": 18, "60": 162, "61": 76, "62": 58, "63": 34, "64": 73, "65": 51, "66": 127, "67": 83, "68": 142, "69": 50, "70": 182, "71": 77, "72": 35, "73": 78, "74": 149, "75": 69, "76": 73, "77": 179, "78": 96, "79": 92, "80": 182, "81": 94, "82": 55, "83": 44, "84": 101, "85": 91, "86": 94, "87": 93, "88": 74, "89": 176, "90": 95, "91": 160, "92": 18, "93": 188, "94": 100, "95": 39, "96": 135, "97": 133, "98": 58, "99": 83, "100": 185}, "description": "Start of the service time window for each customer."}, {"name": "time_window_end", "indices": ["CUSTOMERS"], "values": {"0": 230, "1": 171, "2": 60, "3": 126, "4": 159, "5": 44, "6": 109, "7": 91, "8": 105, "9": 107, "10": 134, "11": 77, "12": 73, "13": 169, "14": 42, "15": 71, "16": 85, "17": 167, "18": 97, "19": 86, "20": 136, "21": 72, "22": 107, "23": 78, "24": 163, "25": 182, "26": 142, "27": 47, "28": 49, "29": 73, "30": 81, "31": 60, "32": 151, "33": 47, "34": 127, "35": 153, "36": 51, "37": 144, "38": 93, "39": 54, "40": 95, "41": 107, "42": 41, "43": 142, "44": 79, "45": 42, "46": 127, "47": 61, "48": 175, "49": 118, "50": 134, "51": 98, "52": 62, "53": 105, "54": 150, "55": 146, "56": 140, "57": 111, "58": 210, "59": 28, "60": 172, "61": 86, "62": 68, "63": 44, "64": 83, "65": 61, "66": 137, "67": 93, "68": 152, "69": 60, "70": 192, "71": 87, "72": 45, "73": 88, "74": 159, "75": 79, "76": 83, "77": 189, "78": 106, "79": 102, "80": 192, "81": 104, "82": 65, "83": 54, "84": 111, "85": 101, "86": 104, "87": 103, "88": 84, "89": 186, "90": 105, "91": 170, "92": 28, "93": 198, "94": 110, "95": 49, "96": 145, "97": 143, "98": 68, "99": 93, "100": 195}, "description": "End of the service time window for each customer."}, {"name": "vehicle_capacity", "indices": [], "values": 100, "description": "Maximum capacity of each vehicle."}], "vars": [{"name": "x", "indices": ["VEHICLES", "CUSTOMERS", "CUSTOMERS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if vehicle v travels from customer i to customer j."}, {"name": "arrival_time", "indices": ["VEHICLES", "CUSTOMERS"], "vartype": "continuous", "lb": 0.0, "ub": null, "description": "Arrival time of vehicle v at customer i."}], "objective": {"name": "min_total_travel_cost", "sense": "min", "expr": "sum(x[v][i][j] * distance[i][j] for v in VEHICLES for i in CUSTOMERS for j in CUSTOMERS)", "description": "Minimize the total travel cost of all vehicles."}, "constraints": [{"name": "demand_fulfillment_1", "expr_lhs": "sum(x[v]['1'][j] for v in VEHICLES for j in CUSTOMERS)", "sense": "==", "expr_rhs": "1", "description": "Customer 1 must be visited exactly once."}, {"name": "demand_fulfillment_2", "expr_lhs": "sum(x[v]['2'][j] for v in VEHICLES for j in CUSTOMERS)", "sense": "==", "expr_rhs": "1", "description": "Customer 2 must be visited exactly once."}, {"name": "demand_fulfillment_3", "expr_lhs": "sum(x[v]['3'][j] for v in VEHICLES for j in CUSTOMERS)", "sense": "==", "expr_rhs": "1", "description": "Customer 3 must be visited exactly once."}, {"name": "demand_fulfillment_4", "expr_lhs": "sum(x[v]['4'][j] for v in VEHICLES for j in CUSTOMERS)", "sense": "==", "expr_rhs": "1", "description": "Customer 4 must be visited exactly once."}, {"name": "demand_fulfillment_5", "expr_lhs": "sum(x[v]['5'][j] for v in VEHICLES for j in CUSTOMERS)", "sense": "==", "expr_rhs": "1", "description": "Customer 5 must be visited exactly once."}, {"name": "capacity_constraint_1", "expr_lhs": "sum(demand[j] * x[v][i][j] for i in CUSTOMERS for j in CUSTOMERS)", "sense": "<=", "expr_rhs": "vehicle_capacity", "description": "Vehicle 1 capacity constraint."}, {"name": "capacity_constraint_2", "expr_lhs": "sum(demand[j] * x[v][i][j] for i in CUSTOMERS for j in CUSTOMERS)", "sense": "<=", "expr_rhs": "vehicle_capacity", "description": "Vehicle 2 capacity constraint."}, {"name": "capacity_constraint_3", "expr_lhs": "sum(demand[j] * x[v][i][j] for i in CUSTOMERS for j in CUSTOMERS)", "sense": "<=", "expr_rhs": "vehicle_capacity", "description": "Vehicle 3 capacity constraint."}, {"name": "capacity_constraint_4", "expr_lhs": "sum(demand[j] * x[v][i][j] for i in CUSTOMERS for j in CUSTOMERS)", "sense": "<=", "expr_rhs": "vehicle_capacity", "description": "Vehicle 4 capacity constraint."}, {"name": "capacity_constraint_5", "expr_lhs": "sum(demand[j] * x[v][i][j] for i in CUSTOMERS for j in CUSTOMERS)", "sense": "<=", "expr_rhs": "vehicle_capacity", "description": "Vehicle 5 capacity constraint."}, {"name": "time_window_1", "expr_lhs": "arrival_time[v]['1']", "sense": ">=", "expr_rhs": "time_window_start['1']", "description": "Vehicle v must arrive at customer 1 after the start of the time window."}, {"name": "time_window_2", "expr_lhs": "arrival_time[v]['2']", "sense": ">=", "expr_rhs": "time_window_start['2']", "description": "Vehicle v must arrive at customer 2 after the start of the time window."}, {"name": "time_window_3", "expr_lhs": "arrival_time[v]['3']", "sense": ">=", "expr_rhs": "time_window_start['3']", "description": "Vehicle v must arrive at customer 3 after the start of the time window."}, {"name": "time_window_4", "expr_lhs": "arrival_time[v]['4']", "sense": ">=", "expr_rhs": "time_window_start['4']", "description": "Vehicle v must arrive at customer 4 after the start of the time window."}, {"name": "time_window_5", "expr_lhs": "arrival_time[v]['5']", "sense": ">=", "expr_rhs": "time_window_start['5']", "description": "Vehicle v must arrive at customer 5 after the start of the time window."}], "graph": null}, "eval": {"ground_truth_raw": "1644.63", "ground_truth_value": 1644.63, "obj_value": null, "gurobi_status_name": "NONE", "correct": 0}}
{"meta": {"problem_id": "industryOR_31", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "solver_build", "stages": {"build_prompts": {"ok": true, "t_sec": 4.09991480410099e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 21.921098500024527, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0004240999696776271, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.899928510189056e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0001639999682083726, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00037379993591457605, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.00003045797348e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": false, "t_sec": 0.14757999998982996, "error_type": "NameError", "error_msg": "name 't' is not defined", "traceback": "Traceback (most recent call last):\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_pipeline.py\", line 254, in run_gm4opt_pipeline\n    model = ir_to_gurobi(ir)\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_ir.py\", line 342, in ir_to_gurobi\n    lhs = eval(cons_def.expr_lhs, global_env, {})\n  File \"<string>\", line 1, in <module>\n  File \"<string>\", line 1, in <genexpr>\nNameError: name 't' is not defined\n"}}, "timings": {"build_prompts": 4.09991480410099e-06, "llm_call": 21.921098500024527, "json_extract": 0.0004240999696776271, "meta_fill": 5.899928510189056e-06, "ir_parse": 0.0001639999682083726, "graph_build": 0.00037379993591457605, "verifier": 4.00003045797348e-06, "solver_build": 0.14757999998982996}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 2, "n_vars": 2, "n_constraints": 2}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": false, "build_error": "NameError: name 't' is not defined", "status": null, "status_name": "NONE", "obj_value": null, "metrics": {}}, "estimation": {"ok": false, "notes": "not run"}, "ir_dict": {"meta": {"problem_id": "industryOR_31", "source": "IndustryOR", "description": "Optimize the allocation of subway crew drivers to minimize the number of drivers needed while considering constraints such as maximum continuous driving time, mileage limits, and attendance location.", "sense": "min", "version": 1}, "sets": [{"name": "PLATFORMS", "elements": ["A", "M", "Z"], "description": "Platforms available for driver transfers and handovers."}, {"name": "TASKS", "elements": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100", "101", "102", "103", "104", "105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", "130", "131", "132", "133", "134", "135", "136", "137", "138", "139", "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", "190", "191", "192", "193", "194", "195", "196", "197", "198", "199", "200"], "description": "Driving tasks to be assigned to drivers."}], "params": [{"name": "mileage", "indices": ["PLATFORMS", "PLATFORMS"], "values": {"A": {"M": 17.1}, "Z": {"M": 26.4}}, "description": "Mileage between platforms."}, {"name": "task_info", "indices": ["TASKS"], "values": {"1": {"pickup_time": "10:03:43", "pickup_location": "Z", "dropoff_time": "10:58:32", "dropoff_location": "M"}, "2": {"pickup_time": "10:09:43", "pickup_location": "Z", "dropoff_time": "11:04:32", "dropoff_location": "M"}, "3": {"pickup_time": "10:15:43", "pickup_location": "Z", "dropoff_time": "11:10:32", "dropoff_location": "M"}, "4": {"pickup_time": "10:21:43", "pickup_location": "Z", "dropoff_time": "11:16:32", "dropoff_location": "M"}, "5": {"pickup_time": "10:27:43", "pickup_location": "Z", "dropoff_time": "11:22:32", "dropoff_location": "M"}, "6": {"pickup_time": "10:33:43", "pickup_location": "Z", "dropoff_time": "11:28:32", "dropoff_location": "M"}, "7": {"pickup_time": "10:39:43", "pickup_location": "Z", "dropoff_time": "11:34:32", "dropoff_location": "M"}, "8": {"pickup_time": "10:45:43", "pickup_location": "Z", "dropoff_time": "11:40:32", "dropoff_location": "M"}, "9": {"pickup_time": "10:51:43", "pickup_location": "Z", "dropoff_time": "11:46:32", "dropoff_location": "M"}, "10": {"pickup_time": "10:57:43", "pickup_location": "Z", "dropoff_time": "11:52:32", "dropoff_location": "M"}, "11": {"pickup_time": "11:03:43", "pickup_location": "Z", "dropoff_time": "11:58:32", "dropoff_location": "M"}, "12": {"pickup_time": "11:09:43", "pickup_location": "Z", "dropoff_time": "12:04:32", "dropoff_location": "M"}, "13": {"pickup_time": "11:15:43", "pickup_location": "Z", "dropoff_time": "12:10:32", "dropoff_location": "M"}, "14": {"pickup_time": "11:21:43", "pickup_location": "Z", "dropoff_time": "12:16:32", "dropoff_location": "M"}, "15": {"pickup_time": "11:27:43", "pickup_location": "Z", "dropoff_time": "12:22:32", "dropoff_location": "M"}, "16": {"pickup_time": "11:33:43", "pickup_location": "Z", "dropoff_time": "12:28:32", "dropoff_location": "M"}, "17": {"pickup_time": "11:39:43", "pickup_location": "Z", "dropoff_time": "12:34:32", "dropoff_location": "M"}, "18": {"pickup_time": "11:45:43", "pickup_location": "Z", "dropoff_time": "12:40:32", "dropoff_location": "M"}, "19": {"pickup_time": "11:51:43", "pickup_location": "Z", "dropoff_time": "12:46:32", "dropoff_location": "M"}, "20": {"pickup_time": "11:57:43", "pickup_location": "Z", "dropoff_time": "12:52:32", "dropoff_location": "M"}, "21": {"pickup_time": "12:03:43", "pickup_location": "Z", "dropoff_time": "12:58:32", "dropoff_location": "M"}, "22": {"pickup_time": "12:09:43", "pickup_location": "Z", "dropoff_time": "13:04:32", "dropoff_location": "M"}, "23": {"pickup_time": "12:15:43", "pickup_location": "Z", "dropoff_time": "13:10:32", "dropoff_location": "M"}, "24": {"pickup_time": "12:21:43", "pickup_location": "Z", "dropoff_time": "13:16:32", "dropoff_location": "M"}, "25": {"pickup_time": "12:27:43", "pickup_location": "Z", "dropoff_time": "13:22:32", "dropoff_location": "M"}, "26": {"pickup_time": "12:33:43", "pickup_location": "Z", "dropoff_time": "13:28:32", "dropoff_location": "M"}, "27": {"pickup_time": "12:39:43", "pickup_location": "Z", "dropoff_time": "13:34:32", "dropoff_location": "M"}, "28": {"pickup_time": "12:45:43", "pickup_location": "Z", "dropoff_time": "13:40:32", "dropoff_location": "M"}, "29": {"pickup_time": "12:51:43", "pickup_location": "Z", "dropoff_time": "13:46:32", "dropoff_location": "M"}, "30": {"pickup_time": "12:57:43", "pickup_location": "Z", "dropoff_time": "13:52:32", "dropoff_location": "M"}, "31": {"pickup_time": "13:03:43", "pickup_location": "Z", "dropoff_time": "13:58:32", "dropoff_location": "M"}, "32": {"pickup_time": "13:09:43", "pickup_location": "Z", "dropoff_time": "14:04:32", "dropoff_location": "M"}, "33": {"pickup_time": "13:15:43", "pickup_location": "Z", "dropoff_time": "14:10:32", "dropoff_location": "M"}, "34": {"pickup_time": "13:21:43", "pickup_location": "Z", "dropoff_time": "14:16:32", "dropoff_location": "M"}, "35": {"pickup_time": "13:27:43", "pickup_location": "Z", "dropoff_time": "14:22:32", "dropoff_location": "M"}, "36": {"pickup_time": "13:33:43", "pickup_location": "Z", "dropoff_time": "14:28:32", "dropoff_location": "M"}, "37": {"pickup_time": "13:39:43", "pickup_location": "Z", "dropoff_time": "14:34:32", "dropoff_location": "M"}, "38": {"pickup_time": "13:45:43", "pickup_location": "Z", "dropoff_time": "14:40:32", "dropoff_location": "M"}, "39": {"pickup_time": "13:51:43", "pickup_location": "Z", "dropoff_time": "14:46:32", "dropoff_location": "M"}, "40": {"pickup_time": "13:57:43", "pickup_location": "Z", "dropoff_time": "14:52:32", "dropoff_location": "M"}}, "description": "Information about each driving task including pickup and dropoff times and locations."}], "vars": [{"name": "x", "indices": ["TASKS", "TASKS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if task i is followed by task j."}, {"name": "y", "indices": ["TASKS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if a driver is assigned to task i."}], "objective": {"name": "min_total_drivers", "sense": "min", "expr": "sum(y[t] for t in TASKS)", "description": "Minimize the total number of drivers needed."}, "constraints": [{"name": "task_assignment", "expr_lhs": "sum(x[t][j] for j in TASKS if j != t)", "sense": "==", "expr_rhs": "y[t]", "description": "Each task must be assigned to exactly one driver."}, {"name": "driver_continuity", "expr_lhs": "sum(x[i][t] for i in TASKS if i != t)", "sense": "==", "expr_rhs": "y[t]", "description": "Ensure continuity of driver assignments."}], "graph": null}, "eval": {"ground_truth_raw": "40", "ground_truth_value": 40.0, "obj_value": null, "gurobi_status_name": "NONE", "correct": 0}}
{"meta": {"problem_id": "industryOR_32", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 6.100046448409557e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 13.472605900024064, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00022879999596625566, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.6999346017837524e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.000278300023637712, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00044219999108463526, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.00003045797348e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0026639000279828906, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.013190300087444484, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.900022082030773e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 6.100046448409557e-06, "llm_call": 13.472605900024064, "json_extract": 0.00022879999596625566, "meta_fill": 6.6999346017837524e-06, "ir_parse": 0.000278300023637712, "graph_build": 0.00044219999108463526, "verifier": 4.00003045797348e-06, "solver_build": 0.0026639000279828906, "solver_optimize": 0.013190300087444484, "estimation": 2.900022082030773e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 5, "n_vars": 2, "n_constraints": 9}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 623.0, "metrics": {"runtime_sec": 0.017999887466430664, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_32", "source": "IndustryOR", "description": "Optimize the number of toy types to manufacture to maximize profit given resource constraints and logical conditions.", "sense": "max", "version": 1}, "sets": [{"name": "TOYS", "elements": ["truck", "plane", "boat", "train"], "description": "Types of toys that can be manufactured."}], "params": [{"name": "profit", "indices": ["TOYS"], "values": {"truck": 5, "plane": 10, "boat": 8, "train": 7}, "description": "Profit from selling one unit of each toy type."}, {"name": "wood_required", "indices": ["TOYS"], "values": {"truck": 12, "plane": 20, "boat": 15, "train": 10}, "description": "Wood required to manufacture one unit of each toy type."}, {"name": "steel_required", "indices": ["TOYS"], "values": {"truck": 6, "plane": 3, "boat": 5, "train": 4}, "description": "Steel required to manufacture one unit of each toy type."}, {"name": "wood_available", "indices": [], "values": 890, "description": "Total units of wood available."}, {"name": "steel_available", "indices": [], "values": 500, "description": "Total units of steel available."}], "vars": [{"name": "x", "indices": ["TOYS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of each type of toy to manufacture."}, {"name": "y", "indices": ["TOYS"], "vartype": "binary", "lb": 0, "ub": 1, "description": "Binary variable indicating whether a type of toy is manufactured."}], "objective": {"name": "max_total_profit", "sense": "max", "expr": "sum(profit[t] * x[t] for t in ['truck', 'plane', 'boat', 'train'])", "description": "Maximize total profit from manufacturing toys."}, "constraints": [{"name": "wood_constraint", "expr_lhs": "sum(wood_required[t] * x[t] for t in ['truck', 'plane', 'boat', 'train'])", "sense": "<=", "expr_rhs": "wood_available", "description": "Total wood used cannot exceed available wood."}, {"name": "steel_constraint", "expr_lhs": "sum(steel_required[t] * x[t] for t in ['truck', 'plane', 'boat', 'train'])", "sense": "<=", "expr_rhs": "steel_available", "description": "Total steel used cannot exceed available steel."}, {"name": "truck_train_exclusion", "expr_lhs": "y['truck'] + y['train']", "sense": "<=", "expr_rhs": "1", "description": "If trucks are manufactured, trains cannot be manufactured and vice versa."}, {"name": "boat_plane_dependency", "expr_lhs": "y['boat']", "sense": "<=", "expr_rhs": "y['plane']", "description": "If boats are manufactured, planes must also be manufactured."}, {"name": "boat_train_limit", "expr_lhs": "x['boat']", "sense": "<=", "expr_rhs": "x['train']", "description": "The number of toy boats manufactured cannot exceed the number of toy trains manufactured."}, {"name": "truck_binary_link", "expr_lhs": "x['truck']", "sense": "<=", "expr_rhs": "1000 * y['truck']", "description": "Link binary and integer variables for trucks."}, {"name": "plane_binary_link", "expr_lhs": "x['plane']", "sense": "<=", "expr_rhs": "1000 * y['plane']", "description": "Link binary and integer variables for planes."}, {"name": "boat_binary_link", "expr_lhs": "x['boat']", "sense": "<=", "expr_rhs": "1000 * y['boat']", "description": "Link binary and integer variables for boats."}, {"name": "train_binary_link", "expr_lhs": "x['train']", "sense": "<=", "expr_rhs": "1000 * y['train']", "description": "Link binary and integer variables for trains."}], "graph": null}, "eval": {"ground_truth_raw": "623.0", "ground_truth_value": 623.0, "obj_value": 623.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_33", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 1.209997572004795e-05, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 12.4513477999717, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0001922000665217638, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.299931555986404e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0002626000205054879, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00020039989612996578, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.300009898841381e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0008131000213325024, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.017586000030860305, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.00001522898674e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 1.209997572004795e-05, "llm_call": 12.4513477999717, "json_extract": 0.0001922000665217638, "meta_fill": 6.299931555986404e-06, "ir_parse": 0.0002626000205054879, "graph_build": 0.00020039989612996578, "verifier": 1.300009898841381e-06, "solver_build": 0.0008131000213325024, "solver_optimize": 0.017586000030860305, "estimation": 2.00001522898674e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 2, "n_vars": 2, "n_constraints": 9}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 240000.0, "metrics": {"runtime_sec": 0.015000104904174805, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_33", "source": "IndustryOR", "description": "Optimize the allocation of land for growing different fruits to maximize profit.", "sense": "max", "version": 1}, "sets": [{"name": "FRUITS", "elements": ["apples", "pears", "oranges", "lemons"], "description": "Types of fruits that can be grown on the farm."}], "params": [{"name": "profit", "indices": ["FRUITS"], "values": {"apples": 2000, "pears": 1800, "oranges": 2200, "lemons": 3000}, "description": "Profit per acre for each type of fruit."}, {"name": "total_land", "indices": [], "values": 120, "description": "Total available land in acres."}], "vars": [{"name": "land", "indices": ["FRUITS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Acres of land allocated to each type of fruit."}, {"name": "grow", "indices": ["FRUITS"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating whether a fruit is grown or not."}], "objective": {"name": "max_total_profit", "sense": "max", "expr": "sum(profit[f] * land[f] for f in ['apples', 'pears', 'oranges', 'lemons'])", "description": "Maximize the total profit from growing fruits."}, "constraints": [{"name": "total_land_constraint", "expr_lhs": "sum(land[f] for f in ['apples', 'pears', 'oranges', 'lemons'])", "sense": "<=", "expr_rhs": "total_land", "description": "Total land used must not exceed available land."}, {"name": "apples_pears_constraint", "expr_lhs": "land['apples']", "sense": ">=", "expr_rhs": "2 * land['pears']", "description": "Land for apples should be at least twice the land for pears."}, {"name": "apples_lemons_constraint", "expr_lhs": "land['apples']", "sense": ">=", "expr_rhs": "3 * land['lemons']", "description": "Land for apples should be at least three times the land for lemons."}, {"name": "oranges_lemons_constraint", "expr_lhs": "land['oranges']", "sense": "==", "expr_rhs": "2 * land['lemons']", "description": "Land for oranges must be twice the land for lemons."}, {"name": "max_two_fruits_constraint", "expr_lhs": "sum(grow[f] for f in ['apples', 'pears', 'oranges', 'lemons'])", "sense": "<=", "expr_rhs": "2", "description": "No more than two types of fruit can be grown."}, {"name": "apples_grow_constraint", "expr_lhs": "land['apples']", "sense": "<=", "expr_rhs": "total_land * grow['apples']", "description": "Land for apples is zero if not grown."}, {"name": "pears_grow_constraint", "expr_lhs": "land['pears']", "sense": "<=", "expr_rhs": "total_land * grow['pears']", "description": "Land for pears is zero if not grown."}, {"name": "oranges_grow_constraint", "expr_lhs": "land['oranges']", "sense": "<=", "expr_rhs": "total_land * grow['oranges']", "description": "Land for oranges is zero if not grown."}, {"name": "lemons_grow_constraint", "expr_lhs": "land['lemons']", "sense": "<=", "expr_rhs": "total_land * grow['lemons']", "description": "Land for lemons is zero if not grown."}], "graph": null}, "eval": {"ground_truth_raw": "240000.0", "ground_truth_value": 240000.0, "obj_value": 240000.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_34", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 3.8000289350748062e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 11.949817900080234, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0001514999894425273, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 5.899928510189056e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00018810003530234098, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00029969995375722647, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.200031980872154e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0023595000384375453, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.003869700012728572, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 3.900029696524143e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 3.8000289350748062e-06, "llm_call": 11.949817900080234, "json_extract": 0.0001514999894425273, "meta_fill": 5.899928510189056e-06, "ir_parse": 0.00018810003530234098, "graph_build": 0.00029969995375722647, "verifier": 4.200031980872154e-06, "solver_build": 0.0023595000384375453, "solver_optimize": 0.003869700012728572, "estimation": 3.900029696524143e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 2, "n_vars": 1, "n_constraints": 5}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 980.0, "metrics": {"runtime_sec": 0.006000041961669922, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_34", "source": "IndustryOR", "description": "Optimize the ordering of tables from suppliers A, B, and C to minimize cost while satisfying constraints.", "sense": "min", "version": 1}, "sets": [{"name": "SUPPLIERS", "elements": ["A", "B", "C"], "description": "The suppliers from which tables can be ordered."}], "params": [{"name": "cost", "indices": ["SUPPLIERS"], "values": {"A": 120, "B": 110, "C": 100}, "description": "Cost per table from each supplier."}, {"name": "tables_per_order", "indices": ["SUPPLIERS"], "values": {"A": 20, "B": 15, "C": 15}, "description": "Number of tables included in each order from each supplier."}], "vars": [{"name": "orders", "indices": ["SUPPLIERS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of orders placed with each supplier."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(cost[s] * orders[s] for s in ['A', 'B', 'C'])", "description": "Minimize the total cost of ordering tables."}, "constraints": [{"name": "min_tables", "expr_lhs": "sum(tables_per_order[s] * orders[s] for s in ['A', 'B', 'C'])", "sense": ">=", "expr_rhs": "150", "description": "The restaurant needs to order at least 150 tables."}, {"name": "max_tables", "expr_lhs": "sum(tables_per_order[s] * orders[s] for s in ['A', 'B', 'C'])", "sense": "<=", "expr_rhs": "600", "description": "The restaurant can order a maximum of 600 tables."}, {"name": "order_B_if_A", "expr_lhs": "orders['B']", "sense": ">=", "expr_rhs": "1", "description": "If the restaurant orders from supplier A, it must also order from supplier B."}, {"name": "min_30_tables_B_if_A", "expr_lhs": "tables_per_order['B'] * orders['B']", "sense": ">=", "expr_rhs": "30", "description": "If the restaurant orders from supplier A, it must order at least 30 tables from supplier B."}, {"name": "order_C_if_B", "expr_lhs": "orders['C']", "sense": ">=", "expr_rhs": "1", "description": "If the restaurant orders from supplier B, it must also order from supplier C."}], "graph": null}, "eval": {"ground_truth_raw": "15000", "ground_truth_value": 15000.0, "obj_value": 980.0, "gurobi_status_name": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_35", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 1.1699972674250603e-05, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 12.909872599993832, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0002527999458834529, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.6999346017837524e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0002266999799758196, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00045419996604323387, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.600035026669502e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.002563999965786934, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.008213000022806227, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 3.600027412176132e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 1.1699972674250603e-05, "llm_call": 12.909872599993832, "json_extract": 0.0002527999458834529, "meta_fill": 6.6999346017837524e-06, "ir_parse": 0.0002266999799758196, "graph_build": 0.00045419996604323387, "verifier": 4.600035026669502e-06, "solver_build": 0.002563999965786934, "solver_optimize": 0.008213000022806227, "estimation": 3.600027412176132e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 6, "n_vars": 1, "n_constraints": 3}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 82999450.0, "metrics": {"runtime_sec": 0.0, "node_count": 0, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_35", "source": "IndustryOR", "description": "Maximize the gross domestic product of Carelland by optimizing the production of steel, engines, electronics, and plastics.", "sense": "max", "version": 1}, "sets": [{"name": "COMMODITIES", "elements": ["steel", "engines", "electronics", "plastics"], "description": "The commodities exported by Carelland."}], "params": [{"name": "unit_price", "indices": ["COMMODITIES"], "values": {"steel": 500, "engines": 1500, "electronics": 300, "plastics": 1200}, "description": "Unit prices of commodities on the world market in Klunz."}, {"name": "production_requirements", "indices": ["COMMODITIES", "COMMODITIES"], "values": {"steel": {"engines": 0.02, "plastics": 0.01, "steel": 0, "electronics": 0}, "engines": {"steel": 0.8, "electronics": 0.15, "plastics": 0.11, "engines": 0}, "electronics": {"steel": 0.01, "engines": 0.01, "plastics": 0.05, "electronics": 0}, "plastics": {"engines": 0.03, "steel": 0.2, "electronics": 0.05, "plastics": 0}}, "description": "Units of other commodities required to produce one unit of each commodity."}, {"name": "import_cost", "indices": ["COMMODITIES"], "values": {"steel": 250, "engines": 300, "electronics": 50, "plastics": 300}, "description": "Cost of other imported goods required to produce one unit of each commodity in Klunz."}, {"name": "labor_requirements", "indices": ["COMMODITIES"], "values": {"steel": 6, "engines": 12, "electronics": 6, "plastics": 24}, "description": "Person-months of work required to produce one unit of each commodity."}, {"name": "production_limits", "indices": ["COMMODITIES"], "values": {"engines": 650000, "plastics": 60000}, "description": "Production limits for certain commodities."}, {"name": "total_labor", "indices": [], "values": 830000, "description": "Total available labor force per year in person-months."}], "vars": [{"name": "production", "indices": ["COMMODITIES"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Units of each commodity to produce."}], "objective": {"name": "max_gdp", "sense": "max", "expr": "sum(production[c] * (unit_price[c] - import_cost[c]) for c in COMMODITIES)", "description": "Maximize the gross domestic product by optimizing the production of commodities."}, "constraints": [{"name": "labor_constraint", "expr_lhs": "sum(production[c] * labor_requirements[c] for c in COMMODITIES)", "sense": "<=", "expr_rhs": "total_labor", "description": "Total labor used must not exceed available labor."}, {"name": "engines_production_limit", "expr_lhs": "production['engines']", "sense": "<=", "expr_rhs": "production_limits['engines']", "description": "Production of engines must not exceed its limit."}, {"name": "plastics_production_limit", "expr_lhs": "production['plastics']", "sense": "<=", "expr_rhs": "production_limits['plastics']", "description": "Production of plastics must not exceed its limit."}], "graph": null}, "eval": {"ground_truth_raw": "435431000", "ground_truth_value": 435431000.0, "obj_value": 82999450.0, "gurobi_status_name": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_36", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 1.0900082997977734e-05, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 21.426042500068434, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00011030002497136593, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 1.9000144675374031e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00012610002886503935, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0002680000616237521, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.300009898841381e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0015388999599963427, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.013281299965456128, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.00001522898674e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 1.0900082997977734e-05, "llm_call": 21.426042500068434, "json_extract": 0.00011030002497136593, "meta_fill": 1.9000144675374031e-06, "ir_parse": 0.00012610002886503935, "graph_build": 0.0002680000616237521, "verifier": 1.300009898841381e-06, "solver_build": 0.0015388999599963427, "solver_optimize": 0.013281299965456128, "estimation": 2.00001522898674e-06}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 5, "n_vars": 3, "n_constraints": 20}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 10755.0, "metrics": {"runtime_sec": 0.01399993896484375, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_36", "source": "IndustryOR", "description": "Optimize production to minimize total compensation and storage costs for three products over four quarters.", "sense": "min", "version": 1}, "sets": [{"name": "PRODUCTS", "elements": ["I", "II", "III"], "description": "The products to be produced."}, {"name": "QUARTERS", "elements": ["1", "2", "3", "4"], "description": "The quarters of the year."}], "params": [{"name": "contract_booking", "indices": ["PRODUCTS", "QUARTERS"], "values": {"I": {"1": 1500, "2": 1000, "3": 2000, "4": 1200}, "II": {"1": 1500, "2": 1500, "3": 1200, "4": 1500}, "III": {"1": 1000, "2": 2000, "3": 1500, "4": 2500}}, "description": "Contract booking numbers for each product and quarter."}, {"name": "production_time_per_unit", "indices": ["PRODUCTS"], "values": {"I": 2, "II": 4, "III": 3}, "description": "Production time required per unit for each product."}, {"name": "production_time_limit", "indices": [], "values": 15000, "description": "Total production time available per quarter."}, {"name": "compensation_cost", "indices": ["PRODUCTS"], "values": {"I": 20, "II": 20, "III": 10}, "description": "Compensation cost per unit for late delivery for each product."}, {"name": "storage_cost", "indices": [], "values": 5, "description": "Storage cost per unit per quarter for products produced but not delivered."}], "vars": [{"name": "produce", "indices": ["PRODUCTS", "QUARTERS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of units produced for each product in each quarter."}, {"name": "inventory", "indices": ["PRODUCTS", "QUARTERS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Inventory level for each product at the end of each quarter."}, {"name": "compensate", "indices": ["PRODUCTS", "QUARTERS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of units not delivered on time for each product in each quarter."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(compensation_cost[p] * compensate[p][q] + storage_cost * inventory[p][q] for p in PRODUCTS for q in QUARTERS)", "description": "Minimize the total compensation and storage costs."}, "constraints": [{"name": "production_time_limit_q1", "expr_lhs": "sum(produce[p]['1'] * production_time_per_unit[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "production_time_limit", "description": "Production time limit for quarter 1."}, {"name": "production_time_limit_q2", "expr_lhs": "sum(produce[p]['2'] * production_time_per_unit[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "production_time_limit", "description": "Production time limit for quarter 2."}, {"name": "production_time_limit_q3", "expr_lhs": "sum(produce[p]['3'] * production_time_per_unit[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "production_time_limit", "description": "Production time limit for quarter 3."}, {"name": "production_time_limit_q4", "expr_lhs": "sum(produce[p]['4'] * production_time_per_unit[p] for p in PRODUCTS)", "sense": "<=", "expr_rhs": "production_time_limit", "description": "Production time limit for quarter 4."}, {"name": "inventory_balance_I_q1", "expr_lhs": "produce['I']['1'] - contract_booking['I']['1'] - compensate['I']['1']", "sense": "==", "expr_rhs": "inventory['I']['1']", "description": "Inventory balance for product I in quarter 1."}, {"name": "inventory_balance_I_q2", "expr_lhs": "produce['I']['2'] - contract_booking['I']['2'] - compensate['I']['2'] + inventory['I']['1']", "sense": "==", "expr_rhs": "inventory['I']['2']", "description": "Inventory balance for product I in quarter 2."}, {"name": "inventory_balance_I_q3", "expr_lhs": "produce['I']['3'] - contract_booking['I']['3'] - compensate['I']['3'] + inventory['I']['2']", "sense": "==", "expr_rhs": "inventory['I']['3']", "description": "Inventory balance for product I in quarter 3."}, {"name": "inventory_balance_I_q4", "expr_lhs": "produce['I']['4'] - contract_booking['I']['4'] - compensate['I']['4'] + inventory['I']['3']", "sense": "==", "expr_rhs": "inventory['I']['4']", "description": "Inventory balance for product I in quarter 4."}, {"name": "inventory_balance_II_q1", "expr_lhs": "produce['II']['1'] - contract_booking['II']['1'] - compensate['II']['1']", "sense": "==", "expr_rhs": "inventory['II']['1']", "description": "Inventory balance for product II in quarter 1."}, {"name": "inventory_balance_II_q2", "expr_lhs": "produce['II']['2'] - contract_booking['II']['2'] - compensate['II']['2'] + inventory['II']['1']", "sense": "==", "expr_rhs": "inventory['II']['2']", "description": "Inventory balance for product II in quarter 2."}, {"name": "inventory_balance_II_q3", "expr_lhs": "produce['II']['3'] - contract_booking['II']['3'] - compensate['II']['3'] + inventory['II']['2']", "sense": "==", "expr_rhs": "inventory['II']['3']", "description": "Inventory balance for product II in quarter 3."}, {"name": "inventory_balance_II_q4", "expr_lhs": "produce['II']['4'] - contract_booking['II']['4'] - compensate['II']['4'] + inventory['II']['3']", "sense": "==", "expr_rhs": "inventory['II']['4']", "description": "Inventory balance for product II in quarter 4."}, {"name": "inventory_balance_III_q1", "expr_lhs": "produce['III']['1'] - contract_booking['III']['1'] - compensate['III']['1']", "sense": "==", "expr_rhs": "inventory['III']['1']", "description": "Inventory balance for product III in quarter 1."}, {"name": "inventory_balance_III_q2", "expr_lhs": "produce['III']['2'] - contract_booking['III']['2'] - compensate['III']['2'] + inventory['III']['1']", "sense": "==", "expr_rhs": "inventory['III']['2']", "description": "Inventory balance for product III in quarter 2."}, {"name": "inventory_balance_III_q3", "expr_lhs": "produce['III']['3'] - contract_booking['III']['3'] - compensate['III']['3'] + inventory['III']['2']", "sense": "==", "expr_rhs": "inventory['III']['3']", "description": "Inventory balance for product III in quarter 3."}, {"name": "inventory_balance_III_q4", "expr_lhs": "produce['III']['4'] - contract_booking['III']['4'] - compensate['III']['4'] + inventory['III']['3']", "sense": "==", "expr_rhs": "inventory['III']['4']", "description": "Inventory balance for product III in quarter 4."}, {"name": "end_inventory_requirement_I", "expr_lhs": "inventory['I']['4']", "sense": ">=", "expr_rhs": "150", "description": "End of year inventory requirement for product I."}, {"name": "end_inventory_requirement_II", "expr_lhs": "inventory['II']['4']", "sense": ">=", "expr_rhs": "150", "description": "End of year inventory requirement for product II."}, {"name": "end_inventory_requirement_III", "expr_lhs": "inventory['III']['4']", "sense": ">=", "expr_rhs": "150", "description": "End of year inventory requirement for product III."}, {"name": "no_production_I_q2", "expr_lhs": "produce['I']['2']", "sense": "==", "expr_rhs": "0", "description": "No production of product I in quarter 2 due to equipment replacement."}], "graph": null}, "eval": {"ground_truth_raw": "10755", "ground_truth_value": 10755.0, "obj_value": 10755.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_37", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "solver_build", "stages": {"build_prompts": {"ok": true, "t_sec": 5.599926225841045e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 9.053220200003125, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0001897999318316579, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 7.2999391704797745e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00021049997303634882, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0003312999615445733, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 3.900029696524143e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": false, "t_sec": 0.001043599913828075, "error_type": "NameError", "error_msg": "name 'int' is not defined", "traceback": "Traceback (most recent call last):\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_pipeline.py\", line 254, in run_gm4opt_pipeline\n    model = ir_to_gurobi(ir)\n  File \"e:\\pyworkspace\\GM4OPT\\gm4opt_ir.py\", line 342, in ir_to_gurobi\n    lhs = eval(cons_def.expr_lhs, global_env, {})\n  File \"<string>\", line 1, in <module>\n  File \"<string>\", line 1, in <genexpr>\nNameError: name 'int' is not defined\n"}}, "timings": {"build_prompts": 5.599926225841045e-06, "llm_call": 9.053220200003125, "json_extract": 0.0001897999318316579, "meta_fill": 7.2999391704797745e-06, "ir_parse": 0.00021049997303634882, "graph_build": 0.0003312999615445733, "verifier": 3.900029696524143e-06, "solver_build": 0.001043599913828075}, "features": {"graph_built": 1, "n_sets": 2, "n_params": 2, "n_vars": 1, "n_constraints": 4}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": false, "build_error": "NameError: name 'int' is not defined", "status": null, "status_name": "NONE", "obj_value": null, "metrics": {}}, "estimation": {"ok": false, "notes": "not run"}, "ir_dict": {"meta": {"problem_id": "industryOR_37", "source": "IndustryOR", "description": "Optimize warehouse rental contracts to minimize total rental fees over 4 months.", "sense": "min", "version": 1}, "sets": [{"name": "MONTHS", "elements": ["1", "2", "3", "4"], "description": "Months for which warehouse space is required."}, {"name": "PERIODS", "elements": ["1", "2", "3", "4"], "description": "Possible contract rental periods in months."}], "params": [{"name": "required_area", "indices": ["MONTHS"], "values": {"1": 1500, "2": 1000, "3": 2000, "4": 1200}, "description": "Required warehouse area for each month in m^2."}, {"name": "rental_fee", "indices": ["PERIODS"], "values": {"1": 28, "2": 45, "3": 60, "4": 73}, "description": "Rental fee per m^2 for each contract period."}], "vars": [{"name": "x", "indices": ["MONTHS", "PERIODS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Area in m^2 rented with a contract starting in a given month for a given period."}], "objective": {"name": "min_total_cost", "sense": "min", "expr": "sum(x[m][p] * rental_fee[p] for m in MONTHS for p in PERIODS)", "description": "Minimize the total rental cost over all months and contract periods."}, "constraints": [{"name": "satisfy_demand_month_1", "expr_lhs": "sum(x['1'][p] for p in PERIODS if int(p) <= 1)", "sense": ">=", "expr_rhs": "required_area['1']", "description": "Ensure the required area is rented for month 1."}, {"name": "satisfy_demand_month_2", "expr_lhs": "sum(x['1'][p] for p in PERIODS if int(p) >= 2) + sum(x['2'][p] for p in PERIODS if int(p) <= 2)", "sense": ">=", "expr_rhs": "required_area['2']", "description": "Ensure the required area is rented for month 2."}, {"name": "satisfy_demand_month_3", "expr_lhs": "sum(x['1'][p] for p in PERIODS if int(p) >= 3) + sum(x['2'][p] for p in PERIODS if int(p) >= 2) + sum(x['3'][p] for p in PERIODS if int(p) <= 3)", "sense": ">=", "expr_rhs": "required_area['3']", "description": "Ensure the required area is rented for month 3."}, {"name": "satisfy_demand_month_4", "expr_lhs": "sum(x['1'][p] for p in PERIODS if int(p) >= 4) + sum(x['2'][p] for p in PERIODS if int(p) >= 3) + sum(x['3'][p] for p in PERIODS if int(p) >= 2) + sum(x['4'][p] for p in PERIODS if int(p) <= 4)", "sense": ">=", "expr_rhs": "required_area['4']", "description": "Ensure the required area is rented for month 4."}], "graph": null}, "eval": {"ground_truth_raw": "118400", "ground_truth_value": 118400.0, "obj_value": null, "gurobi_status_name": "NONE", "correct": 0}}
{"meta": {"problem_id": "industryOR_38", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.900037311017513e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 18.289917400106788, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00035640003625303507, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 7.300055585801601e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0003848000196740031, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.00033730000723153353, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 1.700012944638729e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0016021999763324857, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.014722199994139373, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.700012944638729e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.900037311017513e-06, "llm_call": 18.289917400106788, "json_extract": 0.00035640003625303507, "meta_fill": 7.300055585801601e-06, "ir_parse": 0.0003848000196740031, "graph_build": 0.00033730000723153353, "verifier": 1.700012944638729e-06, "solver_build": 0.0016021999763324857, "solver_optimize": 0.014722199994139373, "estimation": 1.700012944638729e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 1, "n_vars": 2, "n_constraints": 20}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 85.0, "metrics": {"runtime_sec": 0.020000219345092773, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_38", "source": "IndustryOR", "description": "Traveling Salesman Problem with 5 cities and specific distance matrix.", "sense": "min", "version": 1}, "sets": [{"name": "CITIES", "elements": ["0", "1", "2", "3", "4"], "description": "Set of cities including the starting city."}], "params": [{"name": "d", "indices": ["CITIES", "CITIES"], "values": {"0": {"0": 0, "1": 10, "2": 15, "3": 20, "4": 25}, "1": {"0": 10, "1": 0, "2": 35, "3": 25, "4": 30}, "2": {"0": 15, "1": 35, "2": 0, "3": 30, "4": 20}, "3": {"0": 20, "1": 25, "2": 30, "3": 0, "4": 15}, "4": {"0": 25, "1": 30, "2": 20, "3": 15, "4": 0}}, "description": "Distance matrix between cities."}], "vars": [{"name": "x", "indices": ["CITIES", "CITIES"], "vartype": "binary", "lb": 0.0, "ub": 1.0, "description": "Binary variable indicating if the path from city i to city j is taken."}, {"name": "u", "indices": ["CITIES"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Helper variable to eliminate subtours."}], "objective": {"name": "min_total_distance", "sense": "min", "expr": "sum(d[i][j] * x[i][j] for i in CITIES for j in CITIES)", "description": "Minimize the total travel distance."}, "constraints": [{"name": "visit_each_city_once_0", "expr_lhs": "sum(x['0'][j] for j in CITIES if j != '0')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman leaves city 0 exactly once."}, {"name": "visit_each_city_once_1", "expr_lhs": "sum(x['1'][j] for j in CITIES if j != '1')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman leaves city 1 exactly once."}, {"name": "visit_each_city_once_2", "expr_lhs": "sum(x['2'][j] for j in CITIES if j != '2')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman leaves city 2 exactly once."}, {"name": "visit_each_city_once_3", "expr_lhs": "sum(x['3'][j] for j in CITIES if j != '3')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman leaves city 3 exactly once."}, {"name": "visit_each_city_once_4", "expr_lhs": "sum(x['4'][j] for j in CITIES if j != '4')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman leaves city 4 exactly once."}, {"name": "enter_each_city_once_0", "expr_lhs": "sum(x[i]['0'] for i in CITIES if i != '0')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman enters city 0 exactly once."}, {"name": "enter_each_city_once_1", "expr_lhs": "sum(x[i]['1'] for i in CITIES if i != '1')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman enters city 1 exactly once."}, {"name": "enter_each_city_once_2", "expr_lhs": "sum(x[i]['2'] for i in CITIES if i != '2')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman enters city 2 exactly once."}, {"name": "enter_each_city_once_3", "expr_lhs": "sum(x[i]['3'] for i in CITIES if i != '3')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman enters city 3 exactly once."}, {"name": "enter_each_city_once_4", "expr_lhs": "sum(x[i]['4'] for i in CITIES if i != '4')", "sense": "==", "expr_rhs": "1", "description": "Ensure the salesman enters city 4 exactly once."}, {"name": "subtour_elimination_1", "expr_lhs": "u['0'] - u['1'] + 5 * x['0']['1']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 0 and 1."}, {"name": "subtour_elimination_2", "expr_lhs": "u['0'] - u['2'] + 5 * x['0']['2']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 0 and 2."}, {"name": "subtour_elimination_3", "expr_lhs": "u['0'] - u['3'] + 5 * x['0']['3']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 0 and 3."}, {"name": "subtour_elimination_4", "expr_lhs": "u['0'] - u['4'] + 5 * x['0']['4']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 0 and 4."}, {"name": "subtour_elimination_5", "expr_lhs": "u['1'] - u['2'] + 5 * x['1']['2']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 1 and 2."}, {"name": "subtour_elimination_6", "expr_lhs": "u['1'] - u['3'] + 5 * x['1']['3']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 1 and 3."}, {"name": "subtour_elimination_7", "expr_lhs": "u['1'] - u['4'] + 5 * x['1']['4']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 1 and 4."}, {"name": "subtour_elimination_8", "expr_lhs": "u['2'] - u['3'] + 5 * x['2']['3']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 2 and 3."}, {"name": "subtour_elimination_9", "expr_lhs": "u['2'] - u['4'] + 5 * x['2']['4']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 2 and 4."}, {"name": "subtour_elimination_10", "expr_lhs": "u['3'] - u['4'] + 5 * x['3']['4']", "sense": "<=", "expr_rhs": "4", "description": "Subtour elimination constraint for cities 3 and 4."}], "graph": null}, "eval": {"ground_truth_raw": "85", "ground_truth_value": 85.0, "obj_value": 85.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_39", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.599918611347675e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 7.054954500054009, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00015670002903789282, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.4999330788850784e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.0001981999957934022, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0003677000058814883, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 8.300063200294971e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0021424998994916677, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.0062182999681681395, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.700012944638729e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.599918611347675e-06, "llm_call": 7.054954500054009, "json_extract": 0.00015670002903789282, "meta_fill": 6.4999330788850784e-06, "ir_parse": 0.0001981999957934022, "graph_build": 0.0003677000058814883, "verifier": 8.300063200294971e-06, "solver_build": 0.0021424998994916677, "solver_optimize": 0.0062182999681681395, "estimation": 1.700012944638729e-06}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 1, "n_vars": 1, "n_constraints": 6}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 150.0, "metrics": {"runtime_sec": 0.00800013542175293, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_39", "source": "IndustryOR", "description": "Determine the minimum number of drivers and crew members required for a bus route over different shifts.", "sense": "min", "version": 1}, "sets": [{"name": "SHIFTS", "elements": ["1", "2", "3", "4", "5", "6"], "description": "Different time periods for bus route shifts."}], "params": [{"name": "required", "indices": ["SHIFTS"], "values": {"1": 60, "2": 70, "3": 60, "4": 50, "5": 20, "6": 30}, "description": "Number of drivers and crew members required for each shift."}], "vars": [{"name": "x", "indices": ["SHIFTS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of drivers and crew members assigned to each shift."}], "objective": {"name": "min_total_staff", "sense": "min", "expr": "sum(x[s] for s in ['1', '2', '3', '4', '5', '6'])", "description": "Minimize the total number of drivers and crew members assigned."}, "constraints": [{"name": "shift_1_requirement", "expr_lhs": "x['1'] + x['6']", "sense": ">=", "expr_rhs": "required['1']", "description": "Ensure enough staff for shift 1."}, {"name": "shift_2_requirement", "expr_lhs": "x['1'] + x['2']", "sense": ">=", "expr_rhs": "required['2']", "description": "Ensure enough staff for shift 2."}, {"name": "shift_3_requirement", "expr_lhs": "x['2'] + x['3']", "sense": ">=", "expr_rhs": "required['3']", "description": "Ensure enough staff for shift 3."}, {"name": "shift_4_requirement", "expr_lhs": "x['3'] + x['4']", "sense": ">=", "expr_rhs": "required['4']", "description": "Ensure enough staff for shift 4."}, {"name": "shift_5_requirement", "expr_lhs": "x['4'] + x['5']", "sense": ">=", "expr_rhs": "required['5']", "description": "Ensure enough staff for shift 5."}, {"name": "shift_6_requirement", "expr_lhs": "x['5'] + x['6']", "sense": ">=", "expr_rhs": "required['6']", "description": "Ensure enough staff for shift 6."}], "graph": null}, "eval": {"ground_truth_raw": "150", "ground_truth_value": 150.0, "obj_value": 150.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
{"meta": {"problem_id": "industryOR_40", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 4.500034265220165e-06, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 21.293886400060728, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.00026929995510727167, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.199930794537067e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00028300005942583084, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0005414000479504466, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 4.399917088449001e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0031756000826135278, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.015354700037278235, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 2.100015990436077e-06, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 4.500034265220165e-06, "llm_call": 21.293886400060728, "json_extract": 0.00026929995510727167, "meta_fill": 6.199930794537067e-06, "ir_parse": 0.00028300005942583084, "graph_build": 0.0005414000479504466, "verifier": 4.399917088449001e-06, "solver_build": 0.0031756000826135278, "solver_optimize": 0.015354700037278235, "estimation": 2.100015990436077e-06}, "features": {"graph_built": 1, "n_sets": 3, "n_params": 8, "n_vars": 2, "n_constraints": 5}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 700.25, "metrics": {"runtime_sec": 0.013000011444091797, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_40", "source": "IndustryOR", "description": "Determine the optimal production plan to maximize profit for a factory producing three products using different equipment for two procedures.", "sense": "max", "version": 1}, "sets": [{"name": "PRODUCTS", "elements": ["I", "II", "III"], "description": "The products produced by the factory."}, {"name": "EQUIPMENT_A", "elements": ["A1", "A2"], "description": "Equipment types for procedure A."}, {"name": "EQUIPMENT_B", "elements": ["B1", "B2", "B3"], "description": "Equipment types for procedure B."}], "params": [{"name": "processing_time_A", "indices": ["EQUIPMENT_A", "PRODUCTS"], "values": {"A1": {"I": 5, "II": 10, "III": null}, "A2": {"I": 7, "II": 9, "III": 12}}, "description": "Processing time for each product on equipment A."}, {"name": "processing_time_B", "indices": ["EQUIPMENT_B", "PRODUCTS"], "values": {"B1": {"I": 6, "II": 8, "III": null}, "B2": {"I": 4, "II": null, "III": 11}, "B3": {"I": 7, "II": null, "III": null}}, "description": "Processing time for each product on equipment B."}, {"name": "available_time_A", "indices": ["EQUIPMENT_A"], "values": {"A1": 6000, "A2": 10000}, "description": "Available operating time for equipment A."}, {"name": "available_time_B", "indices": ["EQUIPMENT_B"], "values": {"B1": 4000, "B2": 7000, "B3": 4000}, "description": "Available operating time for equipment B."}, {"name": "equipment_cost_A", "indices": ["EQUIPMENT_A"], "values": {"A1": 300, "A2": 321}, "description": "Equipment cost at full load for equipment A."}, {"name": "equipment_cost_B", "indices": ["EQUIPMENT_B"], "values": {"B1": 250, "B2": 783, "B3": 200}, "description": "Equipment cost at full load for equipment B."}, {"name": "raw_material_cost", "indices": ["PRODUCTS"], "values": {"I": 0.25, "II": 0.35, "III": 0.5}, "description": "Raw material cost per unit for each product."}, {"name": "unit_price", "indices": ["PRODUCTS"], "values": {"I": 1.25, "II": 2.0, "III": 2.8}, "description": "Selling price per unit for each product."}], "vars": [{"name": "x_A", "indices": ["EQUIPMENT_A", "PRODUCTS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of units of each product processed on equipment A."}, {"name": "x_B", "indices": ["EQUIPMENT_B", "PRODUCTS"], "vartype": "integer", "lb": 0, "ub": null, "description": "Number of units of each product processed on equipment B."}], "objective": {"name": "max_profit", "sense": "max", "expr": "sum((unit_price[p] - raw_material_cost[p]) * (sum(x_A[e][p] for e in EQUIPMENT_A if processing_time_A[e][p] is not None) + sum(x_B[e][p] for e in EQUIPMENT_B if processing_time_B[e][p] is not None)) - sum(equipment_cost_A[e] for e in EQUIPMENT_A) - sum(equipment_cost_B[e] for e in EQUIPMENT_B) for p in PRODUCTS)", "description": "Maximize the profit from selling products after accounting for raw material and equipment costs."}, "constraints": [{"name": "time_constraint_A1", "expr_lhs": "sum(processing_time_A['A1'][p] * x_A['A1'][p] for p in PRODUCTS if processing_time_A['A1'][p] is not None)", "sense": "<=", "expr_rhs": "available_time_A['A1']", "description": "Ensure equipment A1 does not exceed available operating time."}, {"name": "time_constraint_A2", "expr_lhs": "sum(processing_time_A['A2'][p] * x_A['A2'][p] for p in PRODUCTS if processing_time_A['A2'][p] is not None)", "sense": "<=", "expr_rhs": "available_time_A['A2']", "description": "Ensure equipment A2 does not exceed available operating time."}, {"name": "time_constraint_B1", "expr_lhs": "sum(processing_time_B['B1'][p] * x_B['B1'][p] for p in PRODUCTS if processing_time_B['B1'][p] is not None)", "sense": "<=", "expr_rhs": "available_time_B['B1']", "description": "Ensure equipment B1 does not exceed available operating time."}, {"name": "time_constraint_B2", "expr_lhs": "sum(processing_time_B['B2'][p] * x_B['B2'][p] for p in PRODUCTS if processing_time_B['B2'][p] is not None)", "sense": "<=", "expr_rhs": "available_time_B['B2']", "description": "Ensure equipment B2 does not exceed available operating time."}, {"name": "time_constraint_B3", "expr_lhs": "sum(processing_time_B['B3'][p] * x_B['B3'][p] for p in PRODUCTS if processing_time_B['B3'][p] is not None)", "sense": "<=", "expr_rhs": "available_time_B['B3']", "description": "Ensure equipment B3 does not exceed available operating time."}], "graph": null}, "eval": {"ground_truth_raw": "1146.57", "ground_truth_value": 1146.57, "obj_value": 700.25, "gurobi_status_name": "OPTIMAL", "correct": 0}}
{"meta": {"problem_id": "industryOR_41", "model_name": "gpt-4o", "temperature": 0.0, "timelimit_sec": 60.0}, "failure_stage": "", "stages": {"build_prompts": {"ok": true, "t_sec": 1.5400000847876072e-05, "error_type": "", "error_msg": "", "traceback": ""}, "llm_call": {"ok": true, "t_sec": 8.401583099970594, "error_type": "", "error_msg": "", "traceback": ""}, "json_extract": {"ok": true, "t_sec": 0.0001762000611051917, "error_type": "", "error_msg": "", "traceback": ""}, "meta_fill": {"ok": true, "t_sec": 6.6999346017837524e-06, "error_type": "", "error_msg": "", "traceback": ""}, "ir_parse": {"ok": true, "t_sec": 0.00020839995704591274, "error_type": "", "error_msg": "", "traceback": ""}, "graph_build": {"ok": true, "t_sec": 0.0003700000233948231, "error_type": "", "error_msg": "", "traceback": ""}, "verifier": {"ok": true, "t_sec": 3.900029696524143e-06, "error_type": "", "error_msg": "", "traceback": ""}, "solver_build": {"ok": true, "t_sec": 0.0022080999333411455, "error_type": "", "error_msg": "", "traceback": ""}, "solver_optimize": {"ok": true, "t_sec": 0.006814599968492985, "error_type": "", "error_msg": "", "traceback": ""}, "estimation": {"ok": true, "t_sec": 1.850002445280552e-05, "error_type": "", "error_msg": "", "traceback": ""}}, "timings": {"build_prompts": 1.5400000847876072e-05, "llm_call": 8.401583099970594, "json_extract": 0.0001762000611051917, "meta_fill": 6.6999346017837524e-06, "ir_parse": 0.00020839995704591274, "graph_build": 0.0003700000233948231, "verifier": 3.900029696524143e-06, "solver_build": 0.0022080999333411455, "solver_optimize": 0.006814599968492985, "estimation": 1.850002445280552e-05}, "features": {"graph_built": 1, "n_sets": 1, "n_params": 1, "n_vars": 1, "n_constraints": 6}, "verifier": {"ok": true, "issues": [], "repairs": [], "notes": "verifier placeholder (no-op)", "graph_required": true}, "solver": {"build_ok": true, "build_error": "", "status": 2, "status_name": "OPTIMAL", "obj_value": 22.0, "metrics": {"runtime_sec": 0.009999990463256836, "node_count": 1, "mip_gap": 0.0}}, "estimation": {"ok": true, "notes": "estimation placeholder (no-op)"}, "ir_dict": {"meta": {"problem_id": "industryOR_41", "source": "IndustryOR", "description": "Determine the minimum number of waitstaff required to meet the minimum staffing requirements for each time period in a 24-hour restaurant operation.", "sense": "min", "version": 1}, "sets": [{"name": "TIME_PERIODS", "elements": ["2am-6am", "6am-10am", "10am-2pm", "2pm-6pm", "6pm-10pm", "10pm-2am"], "description": "Time periods during which the restaurant operates."}], "params": [{"name": "min_waitstaff", "indices": ["TIME_PERIODS"], "values": {"2am-6am": 4, "6am-10am": 8, "10am-2pm": 10, "2pm-6pm": 4, "6pm-10pm": 8, "10pm-2am": 4}, "description": "Minimum number of waitstaff required for each time period."}], "vars": [{"name": "x", "indices": ["TIME_PERIODS"], "vartype": "integer", "lb": 0.0, "ub": null, "description": "Number of waitstaff starting their shift at the beginning of each time period."}], "objective": {"name": "min_total_waitstaff", "sense": "min", "expr": "sum(x[t] for t in TIME_PERIODS)", "description": "Minimize the total number of waitstaff scheduled."}, "constraints": [{"name": "min_staff_2am_6am", "expr_lhs": "x['2am-6am'] + x['10pm-2am']", "sense": ">=", "expr_rhs": "min_waitstaff['2am-6am']", "description": "Ensure minimum waitstaff requirement for 2am-6am is met."}, {"name": "min_staff_6am_10am", "expr_lhs": "x['6am-10am'] + x['2am-6am']", "sense": ">=", "expr_rhs": "min_waitstaff['6am-10am']", "description": "Ensure minimum waitstaff requirement for 6am-10am is met."}, {"name": "min_staff_10am_2pm", "expr_lhs": "x['10am-2pm'] + x['6am-10am']", "sense": ">=", "expr_rhs": "min_waitstaff['10am-2pm']", "description": "Ensure minimum waitstaff requirement for 10am-2pm is met."}, {"name": "min_staff_2pm_6pm", "expr_lhs": "x['2pm-6pm'] + x['10am-2pm']", "sense": ">=", "expr_rhs": "min_waitstaff['2pm-6pm']", "description": "Ensure minimum waitstaff requirement for 2pm-6pm is met."}, {"name": "min_staff_6pm_10pm", "expr_lhs": "x['6pm-10pm'] + x['2pm-6pm']", "sense": ">=", "expr_rhs": "min_waitstaff['6pm-10pm']", "description": "Ensure minimum waitstaff requirement for 6pm-10pm is met."}, {"name": "min_staff_10pm_2am", "expr_lhs": "x['10pm-2am'] + x['6pm-10pm']", "sense": ">=", "expr_rhs": "min_waitstaff['10pm-2am']", "description": "Ensure minimum waitstaff requirement for 10pm-2am is met."}], "graph": null}, "eval": {"ground_truth_raw": "22.0", "ground_truth_value": 22.0, "obj_value": 22.0, "gurobi_status_name": "OPTIMAL", "correct": 1}}
